diff -ruN a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c
--- a/arch/x86/kernel/reboot.c	2024-05-07 14:48:20.276413631 +0800
+++ b/arch/x86/kernel/reboot.c	2024-05-07 15:46:53.845848753 +0800
@@ -478,6 +478,56 @@
 		},
 	},
 
+	/* NETGEAR */
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR3312",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR3312"),
+		},
+	},
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR4312",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR4312X"),
+		},
+	},
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR4360",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR4360"),
+		},
+	},
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR3312V2",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR3312V2"),
+		},
+	},
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR4312V2",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR4312XV2"),
+		},
+	},
+	{	/* Fix reboot hang on some NETGEAR ReadyNAS */
+		.callback = set_pci_reboot,
+		.ident = "NETGEAR ReadyNAS RR4312V2",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "NETGEAR"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "RR4312SV2"),
+		},
+	},
+
 	/* Sony */
 	{	/* Handle problems with rebooting on Sony VGN-Z540N */
 		.callback = set_bios_reboot,
diff -ruN a/Documentation/devicetree/bindings/misc/hd44780-lcd.txt b/Documentation/devicetree/bindings/misc/hd44780-lcd.txt
--- a/Documentation/devicetree/bindings/misc/hd44780-lcd.txt	1970-01-01 08:00:00.000000000 +0800
+++ b/Documentation/devicetree/bindings/misc/hd44780-lcd.txt	2024-05-07 15:46:53.845848753 +0800
@@ -0,0 +1,33 @@
+Driver to drive Hitachi HD44780 based LCD displays through GPIO lines.
+
+This is a generic HD44780-based LCD driver not using GPIO.
+
+Required properties:
+- compatible : should be "gpio-lcd" or "hd44780-lcd".
+- lcm-bits : an array of 4 or 8 GPIO line references. The 3rd argument
+  (polarity or active high/low) is honored.
+  lcm-en, lcm-rs, lcm-rw : GPIO line references to the corresponding
+  HD44780 signals, EN, RS, and RW.
+  lcm-bl : a GPIO line reference to control LCD backlight.
+  locm-data-4bit : a boolean property to indicate 4-bit data mode.
+
+Optional properties:
+- lcm-lines : the number of LCD lines (default is 2). The HD44780 does not
+  support more than 2 lines.
+- lcm-cols : the number of LCD columns. Currently ignored.
+
+Example:
+
+gpio_lcd: gpio_lcd {
+	compatible = "gpio-lcd";
+	lcm-data-4bit;
+	lcm-lines  = <2>;
+	lcm-bits = <&gpio4 4 0>,
+		   <&gpio4 5 0>,
+		   <&gpio4 6 0>,
+		   <&gpio4 7 0>;
+	lcm-rs   = <&gpio4 3 0>;
+	lcm-bl   = <&gpio5 0 0>;
+	lcm-rw   = <&gpio5 1 0>;
+	lcm-en   = <&gpio5 2 0>;
+};
diff -ruN a/Documentation/devicetree/bindings/misc/readynas-lcd.txt b/Documentation/devicetree/bindings/misc/readynas-lcd.txt
--- a/Documentation/devicetree/bindings/misc/readynas-lcd.txt	1970-01-01 08:00:00.000000000 +0800
+++ b/Documentation/devicetree/bindings/misc/readynas-lcd.txt	2024-05-07 15:46:53.845848753 +0800
@@ -0,0 +1,22 @@
+Driver to implement NETGEAR ReadyNAS's LCD user land API over the procfs
+using the Hitachi HD44780 based LCD driver "gpio-lcd."
+
+This driver creates the following /proc entries:
+/proc/LCD : 'echo 1 \"Hello\" > /proc/LCD' displays "Hello" on line #1.
+          : 'echo 2 \"World\" > /proc/LCD' displays "World" on line #2.
+          : 'echo 3 > /proc/LCD' turns LCD on.
+          : 'echo 4 > /proc/LCD' turns LCD off.
+          : 'echo 0 > /proc/LCD' clears LCD.
+/proc/LCDstatus : a read-only entry to return LCD on/off status.
+/proc/LCDinfo : a read-only entry to return LCD information
+
+Required properties:
+- compatible : should be "readynas-lcd."
+- lcd-device : a reference to the HD33780 device.
+
+Example:
+
+readynas_lcd {
+	compatible = "readynas-lcd";
+	lcd-device = <&gpio_lcd>;
+};
diff -ruN a/drivers/acpi/acpica/evgpe.c b/drivers/acpi/acpica/evgpe.c
--- a/drivers/acpi/acpica/evgpe.c	2024-05-07 14:48:20.856417079 +0800
+++ b/drivers/acpi/acpica/evgpe.c	2024-05-07 15:46:53.845848753 +0800
@@ -729,6 +729,8 @@
 	return (int_status);
 }
 
+extern bool readynas_ignore_acpi_event(u32);
+
 /*******************************************************************************
  *
  * FUNCTION:    acpi_ev_gpe_dispatch
@@ -753,6 +755,9 @@
 
 	ACPI_FUNCTION_TRACE(ev_gpe_dispatch);
 
+	if (readynas_ignore_acpi_event(gpe_number))
+		return_UINT32(ACPI_INTERRUPT_HANDLED);
+
 	/*
 	 * Always disable the GPE so that it does not keep firing before
 	 * any asynchronous activity completes (either from the execution
diff -ruN a/drivers/gpio/gpio-ich.c b/drivers/gpio/gpio-ich.c
--- a/drivers/gpio/gpio-ich.c	2024-05-07 14:48:22.156424809 +0800
+++ b/drivers/gpio/gpio-ich.c	2024-05-07 15:46:53.845848753 +0800
@@ -11,6 +11,9 @@
 #include <linux/mfd/lpc_ich.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
 
 #define DRV_NAME "gpio_ich"
 
@@ -27,21 +30,46 @@
 	GPIO_USE_SEL = 0,
 	GPIO_IO_SEL,
 	GPIO_LVL,
-	GPO_BLINK
+	GPO_BLINK,
+
+	GPI_INV,
+	GPI_IRQ_EN,
+	GPI_IRQ_STS,
+
+	GPIO_REGS
+};
+
+static const u8 ich9_regs[GPIO_REGS][3] = {
+	{0x00, 0x30, 0x40},	/* USE_SEL[1-3] offsets */
+	{0x04, 0x34, 0x44},	/* IO_SEL[1-3] offsets */
+	{0x0c, 0x38, 0x48},	/* LVL[1-3] offsets */
+	{0x18, 0xff, 0xff},	/* BLINK offset */
+
+	{0x2c, 0xff, 0xff},	/* INV offset */
+	{0x28, 0x2c, 0x2c},	/* GPE0_EN offset */
+	{0x20, 0x24, 0x24},	/* GPE0_STS offset */
 };
 
-static const u8 ichx_regs[4][3] = {
+static const u8 ich9_reglen[3] = {
+	0x30, 0x10, 0x10,
+};
+
+static const u8 ichx_regs[GPIO_REGS][3] = {
 	{0x00, 0x30, 0x40},	/* USE_SEL[1-3] offsets */
 	{0x04, 0x34, 0x44},	/* IO_SEL[1-3] offsets */
 	{0x0c, 0x38, 0x48},	/* LVL[1-3] offsets */
-	{0x18, 0x18, 0x18},	/* BLINK offset */
+	{0x18, 0xff, 0x18},	/* BLINK offsets */
+
+	{0x2c, 0xff, 0xff},	/* INV offsets */
+	{0x28, 0xff, 0xff},	/* GPE0_EN offsets */
+	{0x20, 0xff, 0xff},	/* GPE0_STS offsets */
 };
 
 static const u8 ichx_reglen[3] = {
 	0x30, 0x10, 0x10,
 };
 
-static const u8 avoton_regs[4][3] = {
+static const u8 avoton_regs[GPIO_REGS][3] = {
 	{0x00, 0x80, 0x00},
 	{0x04, 0x84, 0x00},
 	{0x08, 0x88, 0x00},
@@ -51,6 +79,24 @@
 	0x10, 0x10, 0x00,
 };
 
+static const u8 lpt_regs[GPIO_REGS][3] = {
+	{0x00, 0x30, 0x40},	/* USE_SEL[1-3] offsets */
+	{0x04, 0x34, 0x44},	/* IO_SEL[1-3] offsets */
+	{0x0c, 0x38, 0x48},	/* LVL[1-3] offsets */
+	{0x18, 0xff, 0xff},	/* BLINK offsets */
+
+	{0x2c, 0xff, 0xff},	/* INV offsets */
+	{0x28, 0xff, 0x50},	/* GPE0_EN offsets */
+	{0x20, 0x3e, 0x54},	/* GPE0_STS offsets */
+};
+
+static const u8 lpt_reglen[3] = {
+	0x30, 0x10, 0x10,
+};
+
+#define ICHX_PM1_CNT_REG	0x4
+#define ICHX_PM1_CNT_SCI_EN	0x1
+
 #define ICHX_WRITE(val, reg, base_res)	outl(val, (reg) + (base_res)->start)
 #define ICHX_READ(reg, base_res)	inl((reg) + (base_res)->start)
 
@@ -80,9 +126,12 @@
 	 * this option allows driver caching written output values
 	 */
 	bool use_outlvl_cache;
+
+	/* Nmber of GPIOs (from 0) capable of IRQ generation. */
+	u8 ngpi_irq;
 };
 
-static struct {
+static struct ichx_priv {
 	spinlock_t lock;
 	struct device *dev;
 	struct gpio_chip chip;
@@ -91,7 +140,9 @@
 	struct ichx_desc *desc;	/* Pointer to chipset-specific description */
 	u32 orig_gpio_ctrl;	/* Orig CTRL value, used to restore on exit */
 	u8 use_gpio;		/* Which GPIO groups are usable */
+	u8 hwirq;
 	int outlvl_cache[3];	/* cached output values */
+	struct pci_dev *pci_dev;	/* PCI device holder from lpt_ich */
 } ichx_priv;
 
 static int modparam_gpiobase = -1;	/* dynamic */
@@ -329,6 +380,7 @@
 	.have_blink = true,
 	.regs = ichx_regs,
 	.reglen = ichx_reglen,
+	.ngpi_irq = 61,
 };
 
 /* ICH10-based - Consumer/corporate versions have different amount of GPIO */
@@ -337,12 +389,14 @@
 	.have_blink = true,
 	.regs = ichx_regs,
 	.reglen = ichx_reglen,
+	.ngpi_irq = 16,
 };
 static struct ichx_desc ich10_corp_desc = {
 	.ngpio = 72,
 	.have_blink = true,
 	.regs = ichx_regs,
 	.reglen = ichx_reglen,
+	.ngpi_irq = 16,
 };
 
 /* Intel 5 series, 6 series, 3400 series, and C200 series */
@@ -350,6 +404,7 @@
 	.ngpio = 76,
 	.regs = ichx_regs,
 	.reglen = ichx_reglen,
+	.ngpi_irq = 16,
 };
 
 /* Avoton */
@@ -363,6 +418,319 @@
 	.use_outlvl_cache = true,
 };
 
+/* Lynx Point */
+static struct ichx_desc lpt_desc = {
+	.ngpio = 76,
+	.regs = lpt_regs,
+	.reglen = lpt_reglen,
+	.use_outlvl_cache = true,
+	.ngpi_irq = 61,
+};
+
+static struct gpi_irq {
+	u8	gpi_num;
+	u8	_gpi_bank;
+	u8	_rout_reg;
+	u8	_rout_shift;
+	u8	_gpe0_shift;
+	u8	_irq_type;
+	u32	_gpi_bit;
+	char *name;
+} ichx_lpt_gpi_irq[64];
+
+static struct resource *ichx_lpt_pm_base;
+
+#define gpi_valid(i)	((i) < ARRAY_SIZE(ichx_lpt_gpi_irq) &&	\
+				ichx_lpt_gpi_irq[(i)].gpi_num == (i))
+#define rout_reg(i)	ichx_lpt_gpi_irq[(i)]._rout_reg
+#define rout_shift(i)	ichx_lpt_gpi_irq[(i)]._rout_shift
+#define rout_bit(i)	(0x3 << rout_shift(i))
+#define gpi_bank(i)	ichx_lpt_gpi_irq[(i)]._gpi_bank
+#define gpi_bit(i)	ichx_lpt_gpi_irq[(i)]._gpi_bit
+#define gpe0_shift(i)	ichx_lpt_gpi_irq[(i)]._gpe0_shift
+#define gpe0_modbit(i)	(0x1UL << (gpe0_shift(i) % 32))
+#define gpe0_reg_offset(i)	((gpe0_shift(i) >= 32) ? 0x4 : 0)
+#define	irq_type(i)	ichx_lpt_gpi_irq[(i)]._irq_type
+
+#define ICH_GPIO_IRQ_TYPE_NONE	0
+#define ICH_GPIO_IRQ_TYPE_SMI	1
+#define ICH_GPIO_IRQ_TYPE_SCI	2
+#define ICH_GPIO_IRQ_TYPE_NMI	3
+
+#define ICH_GPIO_IRQ_POLARITY_POS	0
+#define ICH_GPIO_IRQ_POLARITY_NEG	1
+#define ICH_GPIO_IRQ_POLARITY_INV	2
+
+static inline struct ichx_priv *irq_data_to_ichx_priv(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+
+	return container_of(gc, struct ichx_priv, chip);
+}
+
+static void ichx_gpio_irq_polarity(struct irq_data *d, unsigned int gpi,
+					unsigned int polarity)
+{
+	unsigned long flags;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct ichx_priv *priv = irq_data_to_ichx_priv(d);
+	u32 inv;
+	u32 inv_reg = priv->desc->regs[GPI_INV][gpi_bank(gpi)];
+
+	if (ichx_gpio_get_direction(gc, gpi) != GPIOF_DIR_IN)
+		return;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	inv = ICHX_READ(inv_reg, priv->gpio_base);
+
+	switch (polarity) {
+	case ICH_GPIO_IRQ_POLARITY_POS:
+		inv &= ~gpi_bit(gpi);
+		break;
+	case ICH_GPIO_IRQ_POLARITY_NEG:
+		inv |= gpi_bit(gpi);
+		break;
+	case ICH_GPIO_IRQ_POLARITY_INV:
+		inv ^= gpi_bit(gpi);
+		break;
+	}
+	ICHX_WRITE(inv, inv_reg, priv->gpio_base);
+
+	spin_unlock_irqrestore(&priv->lock, flags);
+}
+
+static int ichx_gpio_irq_setup(struct irq_data *d, unsigned int gpi,
+				unsigned int type)
+{
+	unsigned long flags;
+	u32 rout, gpe0_en;
+	struct ichx_priv *priv = irq_data_to_ichx_priv(d);
+	u32 gpe0_en_reg = priv->desc->regs[GPI_IRQ_EN][gpi_bank(gpi)];
+
+	if (gpe0_en_reg == 0xff)
+		return -EINVAL;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	gpe0_en = ICHX_READ(gpe0_en_reg, ichx_lpt_pm_base);
+
+	pci_read_config_dword(priv->pci_dev, rout_reg(gpi), &rout);
+	rout &= ~rout_bit(gpi);
+
+	/* Set TYPE */
+	rout |= (type << rout_shift(gpi));
+	pci_write_config_dword(priv->pci_dev, rout_reg(gpi), rout);
+
+	if (type == ICH_GPIO_IRQ_TYPE_NONE)
+		gpe0_en &= ~gpe0_modbit(gpi);
+	else
+		gpe0_en |= gpe0_modbit(gpi);
+
+	ICHX_WRITE(gpe0_en, gpe0_en_reg, ichx_lpt_pm_base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return 0;
+}
+
+static int ichx_gpio_irq_chk_ack(struct ichx_priv *priv,
+				unsigned int gpi, bool ack)
+{
+	int err = 0;
+	int gpe0_sts_reg = priv->desc->regs[GPI_IRQ_STS][gpi_bank(gpi)];
+	u32 gpe0_sts;
+	unsigned long flags;
+
+	if (gpe0_sts_reg == 0xff)
+		return -ENODEV;
+
+	spin_lock_irqsave(&priv->lock, flags);
+	gpe0_sts = ICHX_READ(gpe0_sts_reg, ichx_lpt_pm_base);
+
+	if (!(gpe0_sts & gpe0_modbit(gpi)))
+		err = -ENODEV;
+	if (ack)
+		ICHX_WRITE(gpe0_modbit(gpi), gpe0_sts_reg, ichx_lpt_pm_base);
+	spin_unlock_irqrestore(&priv->lock, flags);
+	return err;
+}
+
+static void ichx_gpio_irq_ack(struct irq_data *d)
+{
+	u32 gpi = irqd_to_hwirq(d);
+
+	if (irq_type(gpi) == IRQ_TYPE_EDGE_BOTH)
+		ichx_gpio_irq_polarity(d, gpi, ICH_GPIO_IRQ_POLARITY_INV);
+	ichx_gpio_irq_chk_ack(irq_data_to_ichx_priv(d), gpi, true);
+}
+
+static irqreturn_t ichx_gpio_irq_handler(int hwirq, void *data)
+{
+	struct ichx_priv *priv = data;
+	int gpi;
+
+	for (gpi = 0; gpi < priv->desc->ngpi_irq; gpi++)
+		if (irq_type(gpi) != IRQ_TYPE_NONE &&
+				!ichx_gpio_irq_chk_ack(priv, gpi, false)) {
+			unsigned int virq =
+				irq_find_mapping(priv->chip.irq.domain, gpi);
+
+			generic_handle_irq(virq);
+		}
+
+	return IRQ_HANDLED;
+}
+
+static void ichx_gpio_irq_unmask(struct irq_data *d) { }
+
+static void ichx_gpio_irq_mask(struct irq_data *d) { }
+
+static int ichx_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	u32 gpi = irqd_to_hwirq(d);
+	int err = IRQ_SET_MASK_OK;
+
+	if (!gpi_valid(gpi))
+		return -EINVAL;
+
+	if (type == IRQ_TYPE_NONE) {
+		irq_type(gpi) = type;
+		return ichx_gpio_irq_setup(d, gpi, 0);
+	}
+
+	switch (type) {
+	case IRQ_TYPE_LEVEL_HIGH:
+		ichx_gpio_irq_polarity(d, gpi, ICH_GPIO_IRQ_POLARITY_POS);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		ichx_gpio_irq_polarity(d, gpi, ICH_GPIO_IRQ_POLARITY_NEG);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		ichx_gpio_irq_polarity(d, gpi, ICH_GPIO_IRQ_POLARITY_INV);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	if (!err)
+		err = ichx_gpio_irq_setup(d, gpi, ICH_GPIO_IRQ_TYPE_SCI);
+	if (!err)
+		irq_type(gpi) = type;
+	return err;
+}
+
+
+static struct irq_chip ichx_irqchip = {
+	.name 		= DRV_NAME,
+	.irq_mask	= ichx_gpio_irq_mask,
+	.irq_unmask	= ichx_gpio_irq_unmask,
+	.irq_set_type	= ichx_gpio_irq_set_type,
+	.irq_ack	= ichx_gpio_irq_ack,
+};
+
+static void lpt_irq_exit(struct ichx_priv *priv)
+{
+	if (ichx_lpt_pm_base != priv->pm_base)
+		kfree(ichx_lpt_pm_base);
+	ichx_lpt_pm_base = NULL;
+}
+
+#define	PCI_ICH_PMBASE_OFFSET		0x40
+
+static int lpt_irq_init(struct ichx_priv *priv)
+{
+	int gpi;
+	u32 d;
+
+	if (!(ichx_lpt_pm_base = priv->pm_base)) {
+		u32 aba;
+		int err = pci_read_config_dword(priv->pci_dev,
+						PCI_ICH_PMBASE_OFFSET,
+						&aba);
+		if (err)
+			return err;
+
+		if (!(ichx_lpt_pm_base =
+				kzalloc(sizeof *ichx_lpt_pm_base, GFP_KERNEL)))
+			return -ENOMEM;
+
+		ichx_lpt_pm_base->start = aba & 0xff80;
+		ichx_lpt_pm_base->end = ichx_lpt_pm_base->start + 0x7f;
+		ichx_lpt_pm_base->name = "ich_pmbase";
+	}
+
+	for (gpi = 0; gpi < priv->desc->ngpi_irq; gpi++) {
+		ichx_lpt_gpi_irq[gpi].gpi_num = gpi;
+		irq_type(gpi) = IRQ_TYPE_NONE;
+		rout_reg(gpi) = 0xbc;	/* Assume GPI_ROUT2 */
+
+		switch (gpi) {
+		case 0 ... 15:
+			rout_reg(gpi)	= 0xb8;	/* GPI_ROUT */
+			gpi_bank(gpi)	= 0;
+			break;
+		case 17 ... 22:
+			gpi_bank(gpi)	= 1;
+			break;
+		case 43 ... 60:
+			gpi_bank(gpi)	= 2;
+			break;
+		default:
+			gpi_bank(gpi)	= 0xff;
+			break;
+		}
+		gpi_bit(gpi)	= 0x1 << (gpi - gpi_bank(gpi) * 16);
+
+		switch (gpi) {
+		case 0 ... 15:
+			gpe0_shift(gpi)	= gpi + 16;
+			rout_shift(gpi)	= gpi * 2;
+			break;
+		case 17:
+			gpe0_shift(gpi)	= 56;
+			rout_shift(gpi)	= 0;
+			break;
+		case 19:
+			gpe0_shift(gpi)	= 57;
+			rout_shift(gpi)	= 2;
+			break;
+		case 21:
+			gpe0_shift(gpi)	= 58;
+			rout_shift(gpi)	= 4;
+			break;
+		case 22:
+			gpe0_shift(gpi)	= 59;
+			rout_shift(gpi)	= 6;
+			break;
+		case 43:
+			gpe0_shift(gpi)	= 60;
+			rout_shift(gpi)	= 8;
+			break;
+		case 56:
+			gpe0_shift(gpi)	= 61;
+			rout_shift(gpi)	= 10;
+			break;
+		case 57:
+			gpe0_shift(gpi)	= 62;
+			rout_shift(gpi)	= 12;
+			break;
+		case 60:
+			gpe0_shift(gpi)	= 63;
+			rout_shift(gpi)	= 14;
+			break;
+		default:
+			ichx_lpt_gpi_irq[gpi].gpi_num = 0xff;
+			break;
+		}
+	}
+
+	while (gpi < ARRAY_SIZE(ichx_lpt_gpi_irq))
+		ichx_lpt_gpi_irq[gpi++].gpi_num = 0xff;
+
+	d = ICHX_READ(ICHX_PM1_CNT_REG, ichx_lpt_pm_base);
+
+	ICHX_WRITE(d | ICHX_PM1_CNT_SCI_EN, ICHX_PM1_CNT_REG, ichx_lpt_pm_base);
+	return 0;
+}
+
 static int ichx_gpio_request_regions(struct device *dev,
 	struct resource *res_base, const char *name, u8 use_gpio)
 {
@@ -385,9 +753,11 @@
 static int ichx_gpio_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
+	struct gpio_chip *gc = &ichx_priv.chip;
 	struct lpc_ich_info *ich_info = dev_get_platdata(dev);
 	struct resource *res_base, *res_pm;
-	int err;
+	struct gpio_irq_chip *girq;
+	int err, i;
 
 	if (!ich_info)
 		return -ENODEV;
@@ -417,6 +787,9 @@
 	case AVOTON_GPIO:
 		ichx_priv.desc = &avoton_desc;
 		break;
+	case LPT_GPIO:
+		ichx_priv.desc = &lpt_desc;
+		break;
 	default:
 		return -ENODEV;
 	}
@@ -432,6 +805,13 @@
 
 	ichx_priv.gpio_base = res_base;
 	ichx_priv.use_gpio = ich_info->use_gpio;
+	ichx_priv.pci_dev = ich_info->pci_dev;
+
+	if (ichx_priv.desc->ngpi_irq && (err = lpt_irq_init(&ichx_priv))) {
+		pr_err("%s: failed to initialize IRQ for %s (%d).\n",
+			__func__, ich_info->name, err);
+		return err;
+	}
 
 	/*
 	 * If necessary, determine the I/O address of ACPI/power management
@@ -456,15 +836,61 @@
 	ichx_priv.pm_base = res_pm;
 
 init:
-	ichx_gpiolib_setup(&ichx_priv.chip);
-	err = devm_gpiochip_add_data(dev, &ichx_priv.chip, NULL);
+	ichx_gpiolib_setup(gc);
+
+	if (ichx_priv.desc->ngpi_irq) {
+		girq = &gc->irq;
+		girq->chip = &ichx_irqchip;
+		girq->parent_handler = NULL;
+		girq->num_parents = 0;
+		girq->parents = NULL;
+		girq->default_type = IRQ_TYPE_NONE;
+		girq->handler = handle_simple_irq;
+	}
+
+	err = devm_gpiochip_add_data(dev, gc, NULL);
 	if (err) {
 		dev_err(dev, "Failed to register GPIOs\n");
 		return err;
 	}
 
-	dev_info(dev, "GPIO from %d to %d\n", ichx_priv.chip.base,
-		 ichx_priv.chip.base + ichx_priv.chip.ngpio - 1);
+	dev_info(dev, "GPIO from %d to %d on %s\n", gc->base,
+		 gc->base + gc->ngpio - 1, gc->label);
+
+	if (ichx_priv.desc->ngpi_irq) {
+		ichx_priv.hwirq = 9;    /* Same as ACPI */
+
+		if ((err = request_irq(ichx_priv.hwirq,
+					ichx_gpio_irq_handler,
+					IRQF_SHARED,
+					ichx_irqchip.name,
+					&ichx_priv))) {
+			pr_err("%s: failed to request irq %d (%d)\n",
+				__func__, ichx_priv.hwirq, err);
+			gpiochip_remove(gc);
+			return err;
+		}
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ichx_priv.desc->regs[0]); i++) {
+		ichx_priv.outlvl_cache[i] =
+			ICHX_READ(ichx_priv.desc->regs[GPIO_LVL][i],
+					ichx_priv.gpio_base);
+	}
+
+	return 0;
+}
+
+static int ichx_gpio_remove(struct platform_device *pdev)
+{
+	struct lpc_ich_info *ich_info = dev_get_platdata(&pdev->dev);
+
+	if (ich_info->gpio_version == LPT_GPIO) {
+		free_irq(ichx_priv.hwirq, &ichx_priv);
+		lpt_irq_exit(&ichx_priv);
+	}
+
+	gpiochip_remove(&ichx_priv.chip);
 
 	return 0;
 }
@@ -474,6 +900,7 @@
 		.name	= DRV_NAME,
 	},
 	.probe		= ichx_gpio_probe,
+	.remove		= ichx_gpio_remove,
 };
 
 module_platform_driver(ichx_gpio_driver);
diff -ruN a/drivers/gpio/gpio-it87.c b/drivers/gpio/gpio-it87.c
--- a/drivers/gpio/gpio-it87.c	2024-05-07 14:48:22.156424809 +0800
+++ b/drivers/gpio/gpio-it87.c	2024-05-07 15:46:53.845848753 +0800
@@ -5,6 +5,8 @@
  *  Author: Diego Elio Petten√≤ <flameeyes@flameeyes.eu>
  *  Copyright (c) 2017 Google, Inc.
  *
+ *  IRQ handling by Hiro Sugawara (c) 2016,2017
+ *
  *  Based on it87_wdt.c     by Oliver Schuster
  *           gpio-it8761e.c by Denis Turischev
  *           gpio-stmpe.c   by Rabin Vincent
@@ -20,11 +22,13 @@
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/gpio/driver.h>
+#include <linux/platform_device.h>
 
 /* Chip Id numbers */
 #define NO_DEV_ID	0xffff
 #define IT8613_ID	0x8613
 #define IT8620_ID	0x8620
+#define IT8625_ID	0x8625
 #define IT8628_ID	0x8628
 #define IT8718_ID       0x8718
 #define IT8728_ID	0x8728
@@ -66,6 +70,17 @@
 	u8 output_base;
 	u8 simple_base;
 	u8 simple_size;
+
+	u16 chip_type;
+	u8 polarity_base;
+	u8 debounce_irq_level;
+	u8 debounce_irq_map[2];
+	u8 smi_status_reg2;
+
+	u8 *valid_irq_mapping;	 /* Pointer to bool map of IRQ-possible GPIOs */
+	u8 *valid_irq_levels;	 /* Pointer to bool map of possible IRQs */
+	u16 irq_base;
+	struct platform_device *pdev;
 };
 
 static struct it87_gpio it87_gpio_chip = {
@@ -74,6 +89,12 @@
 
 /* Superio chip access functions; copied from wdt_it87 */
 
+static inline void superio_select(int ldn)
+{
+	outb(LDNREG, REG);
+	outb(ldn, VAL);
+}
+
 static inline int superio_enter(void)
 {
 	/*
@@ -86,6 +107,7 @@
 	outb(0x01, REG);
 	outb(0x55, REG);
 	outb(0x55, REG);
+	superio_select(GPIO);
 	return 0;
 }
 
@@ -96,12 +118,6 @@
 	release_region(REG, 2);
 }
 
-static inline void superio_select(int ldn)
-{
-	outb(LDNREG, REG);
-	outb(ldn, VAL);
-}
-
 static inline int superio_inb(int reg)
 {
 	outb(reg, REG);
@@ -143,16 +159,82 @@
 		superio_outb(new_val, reg);
 }
 
+static int it87_debounce_irq_slot(struct it87_gpio *it87_gpio, unsigned int gpi)
+{
+	int i;
+
+	gpi += 8;
+	for (i = 0; i< ARRAY_SIZE(it87_gpio->debounce_irq_map); i++)
+		if ((superio_inb(it87_gpio->debounce_irq_map[i]) & 0x3f) == gpi)
+			return i;
+	return -ENODEV;
+}
+
+static void simple_or_alternative(struct it87_gpio *it87_gpio,
+					unsigned int gpio_num)
+{
+	u8 mask = BIT(gpio_num % 8);
+	u8 group = gpio_num / 8;
+
+	/* Panel button => ALTERNATE, otherwise => Simple IO */
+	if (it87_debounce_irq_slot(it87_gpio, gpio_num) >= 0)
+		superio_clear_mask(mask, group + it87_gpio->simple_base);
+	else
+		superio_set_mask(mask, group + it87_gpio->simple_base);
+
+	/* Select GPIO on multi-function pin. */
+	switch (gpio_num) {
+#if 0	/* Manipulating Set 1 register reboots to BIOS on RR2304. */
+	/* Set 1 (group 0) */
+	case 0:		/* i.e. GP10 */
+	case 2 ... 3:	/* i.e. GP12 ... GP13 */
+		mask = BIT(gpio_num);
+		break;
+#endif
+	/* Set 2 (group 1) */
+	case 9 ... 11:	/* i.e. GP21 ... GP23 */
+		mask = BIT(gpio_num - 8);
+		break;
+	/* Set 3 (group 2) */
+	case 16 ... 19:	/* i.e. GP30 ... GP33 */
+	case 22 ... 23:	/* i.e. GP36 ... GP37 */
+		mask = BIT(gpio_num - 16);
+		break;
+	/* Set 4 (group 3) */
+	case 24 ... 29:	/* i.e. GP40 ... GP45 */
+		mask = BIT(gpio_num - 24);
+		break;
+	/* Set 5 (group 4) */
+	case 32 ... 37:	/* i.e. GP50 ... GP55 */
+		mask = BIT(gpio_num - 32);
+		break;
+	case 38 ... 39: /* i.e. GP56 ... GP57 */
+		mask = BIT(7);
+		break;
+	case 40 ... 42: /* i.e. GP60 ... GP62 */
+		mask = BIT(6);
+		group = 4;
+		break;
+	default:
+		mask = 0;
+		break;
+	}
+
+	if (mask)
+		superio_set_mask(mask, group + 0x25);
+}
+
 static int it87_gpio_request(struct gpio_chip *chip, unsigned gpio_num)
 {
 	u8 mask, group;
 	int rc = 0;
 	struct it87_gpio *it87_gpio = gpiochip_get_data(chip);
+	unsigned long flags;
 
 	mask = 1 << (gpio_num % 8);
 	group = (gpio_num / 8);
 
-	spin_lock(&it87_gpio->lock);
+	spin_lock_irqsave(&it87_gpio->lock, flags);
 
 	rc = superio_enter();
 	if (rc)
@@ -162,7 +244,7 @@
 	 * them allow all the lines to be set/unset to Simple I/O.
 	 */
 	if (group < it87_gpio->simple_size)
-		superio_set_mask(mask, group + it87_gpio->simple_base);
+		simple_or_alternative(it87_gpio, gpio_num);
 
 	/* clear output enable, setting the pin to input, as all the
 	 * newly-exported GPIO interfaces are set to input.
@@ -172,7 +254,7 @@
 	superio_exit();
 
 exit:
-	spin_unlock(&it87_gpio->lock);
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
 	return rc;
 }
 
@@ -203,6 +285,8 @@
 	if (rc)
 		goto exit;
 
+	simple_or_alternative(it87_gpio, gpio_num);
+
 	/* clear the output enable bit */
 	superio_clear_mask(mask, group + it87_gpio->output_base);
 
@@ -213,12 +297,11 @@
 	return rc;
 }
 
-static void it87_gpio_set(struct gpio_chip *chip,
-			  unsigned gpio_num, int val)
+static void __it87_gpio_set(struct it87_gpio *it87_gpio,
+			  unsigned int gpio_num, int val)
 {
 	u8 mask, curr_vals;
 	u16 reg;
-	struct it87_gpio *it87_gpio = gpiochip_get_data(chip);
 
 	mask = 1 << (gpio_num % 8);
 	reg = (gpio_num / 8) + it87_gpio->io_base;
@@ -230,6 +313,17 @@
 		outb(curr_vals & ~mask, reg);
 }
 
+static void it87_gpio_set(struct gpio_chip *chip,
+			  unsigned gpio_num, int val)
+{
+	struct it87_gpio *it87_gpio = gpiochip_get_data(chip);
+	unsigned long flags;
+
+	spin_lock_irqsave(&it87_gpio->lock, flags);
+	__it87_gpio_set(it87_gpio, gpio_num, val);
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
+}
+
 static int it87_gpio_direction_out(struct gpio_chip *chip,
 				   unsigned gpio_num, int val)
 {
@@ -246,10 +340,12 @@
 	if (rc)
 		goto exit;
 
+	simple_or_alternative(it87_gpio, gpio_num);
+
 	/* set the output enable bit */
 	superio_set_mask(mask, group + it87_gpio->output_base);
 
-	it87_gpio_set(chip, gpio_num, val);
+	__it87_gpio_set(it87_gpio, gpio_num, val);
 
 	superio_exit();
 
@@ -258,7 +354,346 @@
 	return rc;
 }
 
-static const struct gpio_chip it87_template_chip = {
+static void it87_gpio_polarity(struct it87_gpio *it87_gpio,
+				   unsigned int gpio_num, bool active_low)
+{
+	u8 mask = BIT(gpio_num % 8);
+	u16 reg = it87_gpio->polarity_base + (gpio_num / 8);
+
+	if (active_low)
+		superio_set_mask(mask, reg);
+	else
+		superio_clear_mask(mask, reg);
+}
+
+#ifdef _P
+#undef _P
+#endif
+
+/* Valid GPIO IRQ mapping using IT's GPxx port naming convention. */
+#define	_P(x)	[(((x)/10)-1)*8 + ((x)%10)] = 1
+static u8
+it8613_valid_irq_mapping[] = {/* Table 8-10 */
+	_P(10),       _P(12),_P(13),
+	       _P(21),_P(22),_P(23),
+	_P(30),_P(31),_P(32),_P(33),              _P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+},
+it8625_valid_irq_mapping[] = {/* Table 8-13 */
+	_P(10),_P(11),_P(12),_P(13),_P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(31),_P(32),_P(32),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),_P(46),_P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+},
+#if 0
+it8702_valid_irq_mapping[] = {/* Note 4 */
+	_P(10),_P(11),_P(12),_P(13),_P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(31),_P(32),_P(33),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),_P(46),_P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),
+},
+#endif
+it8728_valid_irq_mapping[] = {/* Table 8-14 */
+	_P(10),_P(11),_P(12),       _P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(31),_P(32),_P(33),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),       _P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+},
+it8732_valid_irq_mapping[] = {/* Table 8-17 */
+	_P(10),_P(11),_P(12),       _P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(42),_P(43),_P(44),_P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+};
+
+#define _Q(x)	[(x)] = 1
+static u8
+it8613_valid_irq_levels[] = {/* Table 8-9 */
+	       _Q(1),        _Q(3), _Q(4), _Q(5), _Q(6), _Q(7),
+	_Q(8), _Q(9), _Q(10),_Q(11),_Q(12),
+},
+it8625_valid_irq_levels[] = {/* Table 8-11 */
+	       _Q(1),        _Q(3), _Q(4), _Q(5), _Q(6), _Q(7),
+	_Q(8), _Q(9), _Q(10),_Q(11),_Q(12),
+},
+it8728_valid_irq_levels[] = {/* Table 8-12 */
+	       _Q(1),        _Q(3), _Q(12),
+},
+it8732_valid_irq_levels[] = {/* Table 8-16 */
+	       _Q(1),        _Q(3), _Q(4), _Q(5), _Q(6), _Q(7),
+	_Q(8), _Q(9), _Q(10),_Q(11),_Q(12),
+};
+
+#define	IT87_DEBIRQ_MASK(i)	BIT((i) + 6)
+
+/* Clear IRQ status to accept next one. */
+static void it87_gpio_debounce_irq_ack(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct it87_gpio *it87_gpio = gpiochip_get_data(gc);
+	u16 reg = it87_gpio->smi_status_reg2;
+	int i;
+
+	superio_enter();
+	if ((i = it87_debounce_irq_slot(it87_gpio, d->hwirq)) >= 0) {
+		u8 mask = IT87_DEBIRQ_MASK(i);
+
+		if (superio_inb(reg) & mask)
+			superio_outb(mask, reg);
+	}
+	superio_exit();
+}
+
+static void it87_gpio_irq_mask(struct irq_data *d) { }
+static void it87_gpio_irq_unmask(struct irq_data *d) { }
+
+/*
+ * Set GPIO number to vacant De-bounce IRQ map register, or clear it.
+ * Returns positive if such map register found.
+ */
+static int it87_goio_irq_set(struct it87_gpio *it87_gpio,
+				unsigned int gpio, bool clear)
+{
+	int i = it87_debounce_irq_slot(it87_gpio, gpio);
+	u8 setirq = (gpio + 8) | 0x40;
+
+	/* Already set in either register? */
+	if (i >= 0) {
+		superio_outb(clear ? 0 : setirq,
+				it87_gpio->debounce_irq_map[i]);
+		return i;
+	}
+	/* If not and to clear, we are done. */
+	if (clear)
+		return 0;
+	/* Look for a vacant register. */
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->debounce_irq_map); i++)
+		if (!superio_inb(it87_gpio->debounce_irq_map[i])) {
+			superio_outb(setirq, it87_gpio->debounce_irq_map[i]);
+			return i;
+		}
+	pr_err("%s: No vacant IRQ slot register.\n", __func__);
+	return -EBUSY;
+}
+
+#include <linux/delay.h>
+
+/* Kernel thread to take care of initially active De-bounce GPIO's IRQ. */
+static struct it87_sticky_debounce_work {
+	struct work_struct worker;
+	u8 gpio;
+	u8 chan;
+} it87_sticky_debounce_work[ARRAY_SIZE(it87_gpio_chip.debounce_irq_map)];
+
+static void it87_sticky_debounce_checker(struct work_struct *work)
+{
+	unsigned long flags;
+	struct it87_gpio *it87_gpio = &it87_gpio_chip;
+	struct it87_sticky_debounce_work *sdw =
+		container_of(work, struct it87_sticky_debounce_work, worker);
+
+	do {
+		msleep_interruptible(10);
+	} while (!it87_gpio_get(&it87_gpio->chip, sdw->gpio));
+
+	spin_lock_irqsave(&it87_gpio->lock, flags);
+	if (!superio_enter()) {
+		superio_outb(IT87_DEBIRQ_MASK(sdw->chan),
+				it87_gpio->smi_status_reg2);
+		superio_exit();
+	}
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
+}
+
+/* De-bounce IRQ responds to a negative pulse whose polarity is subject
+ * to polarity control. To avoide confusion with GPIO polarity control,
+ * we let de-bounce IRQ always respond to a negative pulse regardless of
+ * irq_type.
+ */
+static int it87_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	unsigned long flags;
+	int err = 0;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	unsigned int gpio = irqd_to_hwirq(d);
+	struct it87_gpio *it87_gpio = gpiochip_get_data(gc);
+
+	if (!it87_gpio->valid_irq_mapping[gpio]) {
+		pr_err("%s: gpionum %d (a.k.a.GP%o) cannot be mapped "
+			"for IRQ\n", __func__, gpio, gpio + 8);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&it87_gpio->lock, flags);
+	if ((err = superio_enter()))
+		goto exit;
+
+	switch (type) {
+	case IRQ_TYPE_NONE:
+		/* Dsiable IRQ for this GPIO. */
+		err = it87_goio_irq_set(it87_gpio, gpio, true);
+		goto exit2;
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		err = it87_goio_irq_set(it87_gpio, gpio, false);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+	if (err < 0)
+		goto exit2;
+
+	/* Select simple or alternative. */
+	simple_or_alternative(it87_gpio, gpio);
+
+	/* Set IRQ level register. */
+	superio_outb(it87_gpio->irq_base, it87_gpio->debounce_irq_level);
+
+	if (!work_busy(&it87_sticky_debounce_work[err].worker)) {
+		it87_sticky_debounce_work[err].gpio = gpio;
+		it87_sticky_debounce_work[err].chan = err;
+		schedule_work(&it87_sticky_debounce_work[err].worker);
+	}
+exit2:
+	superio_exit();
+exit:
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
+	return err;
+}
+
+static struct irq_chip it87_gpio_irq_chip = {
+	.irq_ack	= it87_gpio_debounce_irq_ack,
+	.irq_mask	= it87_gpio_irq_mask,
+	.irq_unmask	= it87_gpio_irq_unmask,
+	.irq_set_type	= it87_gpio_irq_set_type,
+};
+
+static void it87_gpio_debounce_irq_handler(struct irq_desc *desc)
+{
+	struct irq_data *data	= irq_desc_get_irq_data(desc);
+	struct gpio_chip *gc	= irq_desc_get_handler_data(desc);
+	struct it87_gpio *it87_gpio = gpiochip_get_data(gc);
+	struct irq_chip *ichip	= irq_data_get_irq_chip(data);
+	u8 smi_stat2;
+	int i;
+
+	superio_enter();
+	smi_stat2 = superio_inb(it87_gpio->smi_status_reg2);
+
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->debounce_irq_map); i++) {
+		const u8 mask = IT87_DEBIRQ_MASK(i);
+
+		if (smi_stat2 & mask) {
+			unsigned int gpio =
+		(superio_inb(it87_gpio->debounce_irq_map[i]) & 0x3f) - 8;
+			unsigned int virq =
+				irq_find_mapping(gc->irq.domain, gpio);
+
+			generic_handle_irq(virq);
+		}
+	}
+	superio_exit();
+	ichip->irq_eoi(data);
+}
+
+static int it87_gpio_irq_probe(struct platform_device *pdev)
+{
+	struct it87_gpio *it87_gpio = &it87_gpio_chip;
+	struct resource *rsc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	struct gpio_irq_chip *girq;
+	int i;
+
+	if (!rsc || !rsc->start) {
+		pr_err("%s: No IRQ resource.\n", __func__);
+		return -ENODEV;
+	}
+
+	if (rsc->start >= 16 || !it87_gpio->valid_irq_levels[rsc->start]) {
+		pr_err("%s: Bad IRQ level %u.\n",
+			__func__, (unsigned int)rsc->start);
+		return -EINVAL;
+	}
+
+	it87_gpio->irq_base = rsc->start;
+	it87_gpio->chip.parent = &pdev->dev;
+
+	for (i = 0; i < ARRAY_SIZE(it87_sticky_debounce_work); i++)
+		INIT_WORK(&it87_sticky_debounce_work[i].worker,
+					it87_sticky_debounce_checker);
+
+	/* Get a pointer to the gpio_irq_chip */
+	girq = &it87_gpio->chip.irq;
+	girq->chip = &it87_gpio_irq_chip;
+	girq->parent_handler = it87_gpio_debounce_irq_handler;
+	girq->num_parents = 1;
+	girq->parents = devm_kcalloc(&pdev->dev, 1, sizeof(*girq->parents),
+					GFP_KERNEL);
+	if (!girq->parents)
+		return -ENOMEM;
+	girq->default_type = IRQ_TYPE_NONE;
+	girq->handler = handle_simple_irq;
+	girq->parents[0] = rsc->start;
+
+	superio_enter();
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->debounce_irq_map); i++)
+		superio_outb(0, it87_gpio->debounce_irq_map[i]);
+	superio_exit();
+	return 0;
+}
+
+static const struct resource it87_gpio_resources[] = {
+	{
+		.name	= "gpio_it87_irq",
+		.start	= 11,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_driver it87_gpio_irq_driver = {
+	.probe	= it87_gpio_irq_probe,
+	.driver	= {
+		.name	= KBUILD_MODNAME,
+	},
+};
+
+static int it87_gpio_irq_init(struct it87_gpio *it87_gpio)
+{
+	struct platform_device *pdev =
+		platform_device_register_simple(
+					it87_gpio_irq_driver.driver.name,
+					0,
+					it87_gpio_resources,
+					ARRAY_SIZE(it87_gpio_resources));
+
+	if (IS_ERR_OR_NULL(pdev)) {
+		int err = pdev ? PTR_ERR(pdev) : -EIO;
+
+		pr_err("%s: failed in platform_device_register (%d)\n",
+			__func__, err);
+		return err;
+	}
+	it87_gpio->pdev = pdev;
+	return platform_driver_register(&it87_gpio_irq_driver);
+}
+
+static void it87_gpio_irq_exit(struct it87_gpio *it87_gpio)
+{
+	platform_device_unregister(it87_gpio->pdev);
+	platform_driver_unregister(&it87_gpio_irq_driver);
+}
+
+static int it87_gpio_to_irq(struct gpio_chip *gpio, unsigned int offset)
+{
+	return it87_gpio_chip.irq_base + offset;
+}
+
+static struct gpio_chip it87_template_chip = {
 	.label			= KBUILD_MODNAME,
 	.owner			= THIS_MODULE,
 	.request		= it87_gpio_request,
@@ -266,29 +701,30 @@
 	.direction_input	= it87_gpio_direction_in,
 	.set			= it87_gpio_set,
 	.direction_output	= it87_gpio_direction_out,
+	.to_irq			= it87_gpio_to_irq,
 	.base			= -1
 };
 
 static int __init it87_gpio_init(void)
 {
 	int rc = 0, i;
-	u16 chip_type;
 	u8 chip_rev, gpio_ba_reg;
 	char *labels, **labels_table;
 
 	struct it87_gpio *it87_gpio = &it87_gpio_chip;
 
+	spin_lock_init(&it87_gpio->lock);
 	rc = superio_enter();
 	if (rc)
 		return rc;
 
-	chip_type = superio_inw(CHIPID);
+	it87_gpio->chip_type = superio_inw(CHIPID);
 	chip_rev  = superio_inb(CHIPREV) & 0x0f;
 	superio_exit();
 
 	it87_gpio->chip = it87_template_chip;
 
-	switch (chip_type) {
+	switch (it87_gpio->chip_type) {
 	case IT8613_ID:
 		gpio_ba_reg = 0x62;
 		it87_gpio->io_size = 8;  /* it8613 only needs 6, use 8 for alignment */
@@ -296,17 +732,46 @@
 		it87_gpio->simple_base = 0xc0;
 		it87_gpio->simple_size = 6;
 		it87_gpio->chip.ngpio = 64;  /* has 48, use 64 for convenient calc */
+		it87_gpio->polarity_base = 0xb0;
+		it87_gpio->debounce_irq_level = 0x70;
+		it87_gpio->debounce_irq_map[0] = 0xe0;
+		it87_gpio->debounce_irq_map[1] = 0xe1;
+		it87_gpio->smi_status_reg2 = 0xf3;
+		it87_gpio->valid_irq_mapping = it8613_valid_irq_mapping;
+		it87_gpio->valid_irq_levels = it8613_valid_irq_levels;
 		break;
 	case IT8620_ID:
+	case IT8625_ID:
 	case IT8628_ID:
 		gpio_ba_reg = 0x62;
 		it87_gpio->io_size = 11;
 		it87_gpio->output_base = 0xc8;
 		it87_gpio->simple_size = 0;
 		it87_gpio->chip.ngpio = 64;
+		it87_gpio->polarity_base = 0xb0;
+		it87_gpio->debounce_irq_level = 0x70;
+		it87_gpio->debounce_irq_map[0] = 0xe0;
+		it87_gpio->debounce_irq_map[1] = 0xe1;
+		it87_gpio->smi_status_reg2 = 0xf3;
+		it87_gpio->valid_irq_mapping = it8625_valid_irq_mapping;
+		it87_gpio->valid_irq_levels = it8625_valid_irq_levels;
 		break;
 	case IT8718_ID:
 	case IT8728_ID:
+		gpio_ba_reg = 0x62;
+		it87_gpio->io_size = 8;
+		it87_gpio->output_base = 0xc8;
+		it87_gpio->simple_base = 0xc0;
+		it87_gpio->simple_size = 5;
+		it87_gpio->chip.ngpio = 64;
+		it87_gpio->polarity_base = 0xb0;
+		it87_gpio->debounce_irq_level = 0x70;
+		it87_gpio->debounce_irq_map[0] = 0xe0;
+		it87_gpio->debounce_irq_map[1] = 0xe1;
+		it87_gpio->smi_status_reg2 = 0xf3;
+		it87_gpio->valid_irq_mapping = it8728_valid_irq_mapping;
+		it87_gpio->valid_irq_levels = it8728_valid_irq_levels;
+		break;
 	case IT8732_ID:
 	case IT8772_ID:
 	case IT8786_ID:
@@ -316,6 +781,13 @@
 		it87_gpio->simple_base = 0xc0;
 		it87_gpio->simple_size = 5;
 		it87_gpio->chip.ngpio = 64;
+		it87_gpio->polarity_base = 0xb0;
+		it87_gpio->debounce_irq_level = 0x70;
+		it87_gpio->debounce_irq_map[0] = 0xe0;
+		it87_gpio->debounce_irq_map[1] = 0xe1;
+		it87_gpio->smi_status_reg2 = 0xf3;
+		it87_gpio->valid_irq_mapping = it8732_valid_irq_mapping;
+		it87_gpio->valid_irq_levels = it8732_valid_irq_levels;
 		break;
 	case IT8761_ID:
 		gpio_ba_reg = 0x60;
@@ -329,7 +801,7 @@
 		return -ENODEV;
 	default:
 		pr_err("Unknown Chip found, Chip %04x Revision %x\n",
-		       chip_type, chip_rev);
+		       it87_gpio->chip_type, chip_rev);
 		return -ENODEV;
 	}
 
@@ -337,15 +809,21 @@
 	if (rc)
 		return rc;
 
+#if 0
 	superio_select(GPIO);
+#endif
 
 	/* fetch GPIO base address */
 	it87_gpio->io_base = superio_inw(gpio_ba_reg);
 
+	/* Clear regs explicitly. SIO may remain active during PM.*/
+	for (i = 0; i < it87_gpio->chip.ngpio; i++)
+		it87_gpio_polarity(it87_gpio, i, false);
+
 	superio_exit();
 
 	pr_info("Found Chip IT%04x rev %x. %u GPIO lines starting at %04xh\n",
-		chip_type, chip_rev, it87_gpio->chip.ngpio,
+		it87_gpio->chip_type, chip_rev, it87_gpio->chip.ngpio,
 		it87_gpio->io_base);
 
 	if (!request_region(it87_gpio->io_base, it87_gpio->io_size,
@@ -385,6 +863,9 @@
 	if (rc)
 		goto labels_free;
 
+	if ((rc = it87_gpio_irq_init(it87_gpio)))
+		goto labels_free;
+
 	return 0;
 
 labels_free:
@@ -398,6 +879,7 @@
 {
 	struct it87_gpio *it87_gpio = &it87_gpio_chip;
 
+	it87_gpio_irq_exit(it87_gpio);
 	gpiochip_remove(&it87_gpio->chip);
 	release_region(it87_gpio->io_base, it87_gpio->io_size);
 	kfree(it87_gpio->chip.names[0]);
diff -ruN a/drivers/hwmon/it87.c b/drivers/hwmon/it87.c
--- a/drivers/hwmon/it87.c	2024-05-07 14:48:24.876440983 +0800
+++ b/drivers/hwmon/it87.c	2024-05-07 15:46:53.855848812 +0800
@@ -12,10 +12,16 @@
  *  similar parts.  The other devices are supported by different drivers.
  *
  *  Supports: IT8603E  Super I/O chip w/LPC interface
+ *            IT8607E  Super I/O chip w/LPC interface
+ *            IT8613E  Super I/O chip w/LPC interface
  *            IT8620E  Super I/O chip w/LPC interface
  *            IT8622E  Super I/O chip w/LPC interface
  *            IT8623E  Super I/O chip w/LPC interface
+ *            IT8625E  Super I/O chip w/LPC interface
  *            IT8628E  Super I/O chip w/LPC interface
+ *            IT8655E  Super I/O chip w/LPC interface
+ *            IT8665E  Super I/O chip w/LPC interface
+ *            IT8686E  Super I/O chip w/LPC interface
  *            IT8705F  Super I/O chip w/LPC interface
  *            IT8712F  Super I/O chip w/LPC interface
  *            IT8716F  Super I/O chip w/LPC interface
@@ -59,14 +65,18 @@
 #include <linux/dmi.h>
 #include <linux/acpi.h>
 #include <linux/io.h>
+#include <acpi/acpixf.h>
 
 #define DRVNAME "it87"
 
 enum chips { it87, it8712, it8716, it8718, it8720, it8721, it8728, it8732,
 	     it8771, it8772, it8781, it8782, it8783, it8786, it8790,
-	     it8792, it8603, it8620, it8622, it8628, it87952 };
+	     it8792, it8603, it8607, it8613, it8620, it8622, it8625, it8628,
+	     it8655, it8665, it8686, it87952 };
 
 static struct platform_device *it87_pdev[2];
+static acpi_handle it87_acpi_sio_handle;
+static char *it87_acpi_sio_mutex;
 
 #define	REG_2E	0x2e	/* The register to read/write */
 #define	REG_4E	0x4e	/* Secondary register to read/write */
@@ -90,8 +100,18 @@
 
 static inline int superio_inb(int ioreg, int reg)
 {
+	int val;
+
 	outb(reg, ioreg);
-	return inb(ioreg + 1);
+	val = inb(ioreg + 1);
+	if (ioreg == 0x4e && val == 0xff) {
+		__superio_enter(ioreg);
+		outb(reg, ioreg);
+		val = inb(ioreg + 1);
+		pr_warn("Retry access 0x4e:0x%x -> 0x%x\n", reg, val);
+	}
+
+	return val;
 }
 
 static inline void superio_outb(int ioreg, int reg, int val)
@@ -102,13 +122,7 @@
 
 static int superio_inw(int ioreg, int reg)
 {
-	int val;
-
-	outb(reg++, ioreg);
-	val = inb(ioreg + 1) << 8;
-	outb(reg, ioreg);
-	val |= inb(ioreg + 1);
-	return val;
+	return (superio_inb(ioreg, reg) << 8) | superio_inb(ioreg, reg + 1);
 }
 
 static inline void superio_select(int ioreg, int ldn)
@@ -119,23 +133,40 @@
 
 static inline int superio_enter(int ioreg)
 {
+	if (it87_acpi_sio_mutex) {
+		acpi_status status;
+
+		status = acpi_acquire_mutex(NULL, it87_acpi_sio_mutex, 0x10);
+		if (ACPI_FAILURE(status)) {
+			pr_err("Failed to acquire ACPI mutex\n");
+			return -EBUSY;
+		}
+	}
 	/*
 	 * Try to reserve ioreg and ioreg + 1 for exclusive access.
 	 */
 	if (!request_muxed_region(ioreg, 2, DRVNAME))
-		return -EBUSY;
+		goto error;
 
 	__superio_enter(ioreg);
 	return 0;
+
+error:
+	if (it87_acpi_sio_mutex)
+		acpi_release_mutex(it87_acpi_sio_handle, NULL);
+	return -EBUSY;
 }
 
 static inline void superio_exit(int ioreg, bool noexit)
 {
-	if (!noexit) {
+	if (!noexit || ioreg != 0x4e) {
 		outb(0x02, ioreg);
 		outb(0x02, ioreg + 1);
 	}
 	release_region(ioreg, 2);
+
+	if (it87_acpi_sio_mutex)
+		acpi_release_mutex(it87_acpi_sio_handle, NULL);
 }
 
 /* Logical device 4 registers */
@@ -157,16 +188,25 @@
 #define IT8786E_DEVID 0x8786
 #define IT8790E_DEVID 0x8790
 #define IT8603E_DEVID 0x8603
+#define IT8607E_DEVID 0x8607
+#define IT8613E_DEVID 0x8613
 #define IT8620E_DEVID 0x8620
 #define IT8622E_DEVID 0x8622
 #define IT8623E_DEVID 0x8623
+#define IT8625E_DEVID 0x8625
 #define IT8628E_DEVID 0x8628
+#define IT8655E_DEVID 0x8655
+#define IT8665E_DEVID 0x8665
+#define IT8686E_DEVID 0x8686
 #define IT87952E_DEVID 0x8695
 
 /* Logical device 4 (Environmental Monitor) registers */
 #define IT87_ACT_REG	0x30
 #define IT87_BASE_REG	0x60
+#define IT87_PCR1_REG	0xf2	/* APC/PME Control Register 1 */
 #define IT87_SPECIAL_CFG_REG	0xf3	/* special configuration register */
+#define IT87_PCR2_REG	0xf4	/* APC/PME Control Register 2 */
+#define IT87_EUP_REG	0xfa	/* Special PME EUP configure register */
 
 /* Logical device 7 registers (IT8712F and later) */
 #define IT87_SIO_GPIO1_REG	0x25
@@ -174,8 +214,10 @@
 #define IT87_SIO_GPIO3_REG	0x27
 #define IT87_SIO_GPIO4_REG	0x28
 #define IT87_SIO_GPIO5_REG	0x29
+#define IT87_SIO_GPIO9_REG	0xd3
 #define IT87_SIO_PINX1_REG	0x2a	/* Pin selection */
 #define IT87_SIO_PINX2_REG	0x2c	/* Pin selection */
+#define IT87_SIO_PINX4_REG	0x2d	/* Pin selection */
 #define IT87_SIO_SPI_REG	0xef	/* SPI function pin select */
 #define IT87_SIO_VID_REG	0xfc	/* VID value */
 #define IT87_SIO_BEEP_PIN_REG	0xf6	/* Beep pin mapping */
@@ -216,6 +258,8 @@
 #define IT87_REG_ALARM2        0x02
 #define IT87_REG_ALARM3        0x03
 
+#define IT87_REG_BANK		0x06
+
 /*
  * The IT8718F and IT8720F have the VID value in a different register, in
  * Super-I/O configuration space.
@@ -244,11 +288,20 @@
 static const u8 IT87_REG_FAN_MIN[]     = { 0x10, 0x11, 0x12, 0x84, 0x86, 0x4e };
 static const u8 IT87_REG_FANX[]        = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x4d };
 static const u8 IT87_REG_FANX_MIN[]    = { 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0x4f };
-static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59 };
+
+static const u8 IT87_REG_FAN_8665[]      = { 0x0d, 0x0e, 0x0f, 0x80, 0x82, 0x93 };
+static const u8 IT87_REG_FAN_MIN_8665[]  = { 0x10, 0x11, 0x12, 0x84, 0x86, 0xb2 };
+static const u8 IT87_REG_FANX_8665[]     = { 0x18, 0x19, 0x1a, 0x81, 0x83, 0x94 };
+static const u8 IT87_REG_FANX_MIN_8665[] = { 0x1b, 0x1c, 0x1d, 0x85, 0x87, 0xb3 };
+
+static const u8 IT87_REG_TEMP_OFFSET[] = { 0x56, 0x57, 0x59, 0x5a, 0x90, 0x91 };
+static const u8 IT87_REG_TEMP_OFFSET_8686[] = { 0x56, 0x57, 0x59, 0x90, 0x91, 0x92 };
 
 #define IT87_REG_FAN_MAIN_CTRL 0x13
 #define IT87_REG_FAN_CTL       0x14
+
 static const u8 IT87_REG_PWM[]         = { 0x15, 0x16, 0x17, 0x7f, 0xa7, 0xaf };
+static const u8 IT87_REG_PWM_8665[]    = { 0x15, 0x16, 0x17, 0x1e, 0x1f, 0x92 };
 static const u8 IT87_REG_PWM_DUTY[]    = { 0x63, 0x6b, 0x73, 0x7b, 0xa3, 0xab };
 
 static const u8 IT87_REG_VIN[]	= { 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26,
@@ -258,8 +311,12 @@
 
 #define IT87_REG_VIN_MAX(nr)   (0x30 + (nr) * 2)
 #define IT87_REG_VIN_MIN(nr)   (0x31 + (nr) * 2)
-#define IT87_REG_TEMP_HIGH(nr) (0x40 + (nr) * 2)
-#define IT87_REG_TEMP_LOW(nr)  (0x41 + (nr) * 2)
+
+static const u8 IT87_REG_TEMP_HIGH[] = { 0x40, 0x42, 0x44, 0x46, 0xb4, 0xb6 };
+static const u8 IT87_REG_TEMP_LOW[]  = { 0x41, 0x43, 0x45, 0x47, 0xb5, 0xb7 };
+
+static const u8 IT87_REG_TEMP_HIGH_8686[] = { 0x40, 0x42, 0x44, 0xb4, 0xb6, 0xb8 };
+static const u8 IT87_REG_TEMP_LOW_8686[]  = { 0x41, 0x43, 0x45, 0xb5, 0xb7, 0xb9 };
 
 #define IT87_REG_VIN_ENABLE    0x50
 #define IT87_REG_TEMP_ENABLE   0x51
@@ -275,11 +332,14 @@
 
 #define IT87_REG_TEMP456_ENABLE	0x77
 
+static const u16 IT87_REG_TEMP_SRC1[] =	{ 0x21d, 0x21e, 0x21f };
+
+#define IT87_REG_TEMP_SRC2	0x23d
+
 #define NUM_VIN			ARRAY_SIZE(IT87_REG_VIN)
 #define NUM_VIN_LIMIT		8
 #define NUM_TEMP		6
 #define NUM_TEMP_OFFSET		ARRAY_SIZE(IT87_REG_TEMP_OFFSET)
-#define NUM_TEMP_LIMIT		3
 #define NUM_FAN			ARRAY_SIZE(IT87_REG_FAN)
 #define NUM_FAN_DIV		3
 #define NUM_PWM			ARRAY_SIZE(IT87_REG_PWM)
@@ -289,6 +349,7 @@
 	const char *name;
 	const char * const model;
 	u32 features;
+	u8 num_temp_limit;
 	u8 peci_mask;
 	u8 old_peci_mask;
 	u8 smbus_bitmap;	/* SMBus enable bits in extra config register */
@@ -325,6 +386,9 @@
 #define FEAT_FOUR_PWM		BIT(21)	/* Supports four fan controls */
 #define FEAT_FOUR_TEMP		BIT(22)
 #define FEAT_FANCTL_ONOFF	BIT(23)	/* chip has FAN_CTL ON/OFF */
+#define FEAT_BANK_SEL		BIT(24)	/* Chip has multi-bank support */
+#define FEAT_NEW_TEMPMAP	BIT(25)	/* new temp input selection */
+#define FEAT_TACH_CLOSED_LOOP	BIT(26)
 
 static const struct it87_devices it87_devices[] = {
 	[it87] = {
@@ -332,12 +396,14 @@
 		.model = "IT87F",
 		.features = FEAT_OLD_AUTOPWM | FEAT_FANCTL_ONOFF,
 		/* may need to overwrite */
+		.num_temp_limit = 3,
 	},
 	[it8712] = {
 		.name = "it8712",
 		.model = "IT8712F",
 		.features = FEAT_OLD_AUTOPWM | FEAT_VID | FEAT_FANCTL_ONOFF,
 		/* may need to overwrite */
+		.num_temp_limit = 3,
 	},
 	[it8716] = {
 		.name = "it8716",
@@ -345,6 +411,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
 		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 	},
 	[it8718] = {
 		.name = "it8718",
@@ -352,6 +419,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8720] = {
@@ -360,6 +428,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET | FEAT_VID
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8721] = {
@@ -368,7 +437,8 @@
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_FAN16_CONFIG | FEAT_FIVE_FANS | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_TACH_CLOSED_LOOP,
+		.num_temp_limit = 3,
 		.peci_mask = 0x05,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -377,8 +447,8 @@
 		.model = "IT8728F",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
-		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
-		  | FEAT_FANCTL_ONOFF,
+		  | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8732] = {
@@ -387,7 +457,8 @@
 		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FOUR_FANS
-		  | FEAT_FOUR_PWM | FEAT_FANCTL_ONOFF,
+		  | FEAT_FOUR_PWM | FEAT_FANCTL_ONOFF | FEAT_TACH_CLOSED_LOOP,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -396,11 +467,12 @@
 		.model = "IT8771E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_FANCTL_ONOFF,
 				/* PECI: guesswork */
 				/* 12mV ADC (OHM) */
 				/* 16 bit fans (OHM) */
 				/* three fans, always 16 bit (guesswork) */
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8772] = {
@@ -408,11 +480,12 @@
 		.model = "IT8772E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
-		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_FANCTL_ONOFF,
 				/* PECI (coreboot) */
 				/* 12mV ADC (HWSensors4, OHM) */
 				/* 16 bit fans (HWSensors4, OHM) */
 				/* three fans, always 16 bit (datasheet) */
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8781] = {
@@ -421,6 +494,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8782] = {
@@ -429,6 +503,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8783] = {
@@ -437,6 +512,7 @@
 		.features = FEAT_16BIT_FANS | FEAT_TEMP_OFFSET
 		  | FEAT_TEMP_OLD_PECI | FEAT_FAN16_CONFIG | FEAT_PWM_FREQ2
 		  | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.old_peci_mask = 0x4,
 	},
 	[it8786] = {
@@ -445,6 +521,7 @@
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8790] = {
@@ -453,6 +530,7 @@
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF | FEAT_CONF_NOEXIT,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8792] = {
@@ -462,6 +540,7 @@
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF
 		  | FEAT_CONF_NOEXIT,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -471,6 +550,26 @@
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
 		  | FEAT_AVCC3 | FEAT_PWM_FREQ2,
+		.num_temp_limit = 3,
+		.peci_mask = 0x07,
+	},
+	[it8607] = {
+		.name = "it8607",
+		.model = "IT8607E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_IN7_INTERNAL
+		  | FEAT_AVCC3 | FEAT_PWM_FREQ2 | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
+		.peci_mask = 0x07,
+	},
+	[it8613] = {
+		.name = "it8613",
+		.model = "IT8613E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_10_9MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
+		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
+		  | FEAT_AVCC3 | FEAT_NEW_TEMPMAP | FEAT_TACH_CLOSED_LOOP,
+		.num_temp_limit = 6,
 		.peci_mask = 0x07,
 	},
 	[it8620] = {
@@ -480,6 +579,7 @@
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
 		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
 	[it8622] = {
@@ -489,18 +589,56 @@
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_FIVE_FANS
 		  | FEAT_FIVE_PWM | FEAT_IN7_INTERNAL | FEAT_PWM_FREQ2
 		  | FEAT_AVCC3 | FEAT_VIN3_5V | FEAT_FOUR_TEMP,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 		.smbus_bitmap = BIT(1) | BIT(2),
 	},
+	[it8625] = {
+		.name = "it8625",
+		.model = "IT8625E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL | FEAT_TACH_CLOSED_LOOP,
+		.num_temp_limit = 6,
+	},
 	[it8628] = {
 		.name = "it8628",
 		.model = "IT8628E",
 		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_PECI | FEAT_SIX_FANS
 		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
-		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF,
+		  | FEAT_SIX_TEMP | FEAT_VIN3_5V | FEAT_FANCTL_ONOFF
+		  | FEAT_AVCC3,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 	},
+	[it8655] = {
+		.name = "it8655",
+		.model = "IT8655E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_BANK_SEL,
+		.num_temp_limit = 6,
+	},
+	[it8665] = {
+		.name = "it8665",
+		.model = "IT8665E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_AVCC3 | FEAT_NEW_TEMPMAP
+		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_SIX_FANS
+		  | FEAT_SIX_PWM | FEAT_BANK_SEL,
+		.num_temp_limit = 6,
+	},
+	[it8686] = {
+		.name = "it8686",
+		.model = "IT8686E",
+		.features = FEAT_NEWER_AUTOPWM | FEAT_12MV_ADC | FEAT_16BIT_FANS
+		  | FEAT_TEMP_OFFSET | FEAT_SIX_FANS | FEAT_NEW_TEMPMAP
+		  | FEAT_IN7_INTERNAL | FEAT_SIX_PWM | FEAT_PWM_FREQ2
+		  | FEAT_SIX_TEMP | FEAT_BANK_SEL | FEAT_AVCC3,
+		.num_temp_limit = 6,
+	},
 	[it87952] = {
 		.name = "it87952",
 		.model = "IT87952E",
@@ -508,6 +646,7 @@
 		  | FEAT_TEMP_OFFSET | FEAT_TEMP_OLD_PECI | FEAT_TEMP_PECI
 		  | FEAT_10_9MV_ADC | FEAT_IN7_INTERNAL | FEAT_FANCTL_ONOFF
 		  | FEAT_CONF_NOEXIT,
+		.num_temp_limit = 3,
 		.peci_mask = 0x07,
 		.old_peci_mask = 0x02,	/* Actually reports PCH */
 	},
@@ -548,6 +687,10 @@
 #define has_scaling(data)	((data)->features & (FEAT_12MV_ADC | \
 						     FEAT_10_9MV_ADC))
 #define has_fanctl_onoff(data)	((data)->features & FEAT_FANCTL_ONOFF)
+#define has_bank_sel(data)	((data)->features & FEAT_BANK_SEL)
+#define has_new_tempmap(data)	((data)->features & FEAT_NEW_TEMPMAP)
+#define has_tach_closed_loop(data) \
+				((data)->features & FEAT_TACH_CLOSED_LOOP)
 
 struct it87_sio_data {
 	int sioaddr;
@@ -577,9 +720,21 @@
 	int sioaddr;
 	enum chips type;
 	u32 features;
+	u8 bank;
 	u8 peci_mask;
 	u8 old_peci_mask;
 
+	const u8 *REG_FAN;
+	const u8 *REG_FANX;
+	const u8 *REG_FAN_MIN;
+	const u8 *REG_FANX_MIN;
+
+	const u8 *REG_PWM;
+
+	const u8 *REG_TEMP_OFFSET;
+	const u8 *REG_TEMP_LOW;
+	const u8 *REG_TEMP_HIGH;
+
 	u8 smbus_bitmap;	/* !=0 if SMBus needs to be disabled */
 	u8 ec_special_config;	/* EC special config register restore value */
 
@@ -598,6 +753,7 @@
 	u16 fan[NUM_FAN][2];	/* Register values, [nr][0]=fan, [1]=min */
 	u8 has_temp;		/* Bitfield, temp sensors enabled */
 	s8 temp[NUM_TEMP][4];	/* [nr][0]=temp, [1]=min, [2]=max, [3]=offset */
+	u8 num_temp_limit;	/* Number of temp limit/offset registers */
 	u8 sensor;		/* Register value (IT87_REG_TEMP_ENABLE) */
 	u8 extra;		/* Register value (IT87_REG_TEMP_EXTRA) */
 	u8 fan_div[NUM_FAN_DIV];/* Register encoding, shifted right */
@@ -770,16 +926,40 @@
 	return 0;
 }
 
+static int _it87_read_value(struct it87_data *data, u8 reg)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+}
+
+static void _it87_write_value(struct it87_data *data, u8 reg, u8 value)
+{
+	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
+	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+}
+
+static void it87_set_bank(struct it87_data *data, u8 bank)
+{
+	if (has_bank_sel(data) && bank != data->bank) {
+		u8 breg = _it87_read_value(data, IT87_REG_BANK);
+
+		breg &= 0x1f;
+		breg |= (bank << 5);
+		data->bank = bank;
+		_it87_write_value(data, IT87_REG_BANK, breg);
+	}
+}
+
 /*
  * Must be called with data->update_lock held, except during initialization.
  * Must be called with SMBus accesses disabled.
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static int it87_read_value(struct it87_data *data, u8 reg)
+static int it87_read_value(struct it87_data *data, u16 reg)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	return inb_p(data->addr + IT87_DATA_REG_OFFSET);
+	it87_set_bank(data, reg >> 8);
+	return _it87_read_value(data, reg & 0xff);
 }
 
 /*
@@ -788,17 +968,20 @@
  * We ignore the IT87 BUSY flag at this moment - it could lead to deadlocks,
  * would slow down the IT87 access and should not be necessary.
  */
-static void it87_write_value(struct it87_data *data, u8 reg, u8 value)
+static void it87_write_value(struct it87_data *data, u16 reg, u8 value)
 {
-	outb_p(reg, data->addr + IT87_ADDR_REG_OFFSET);
-	outb_p(value, data->addr + IT87_DATA_REG_OFFSET);
+	it87_set_bank(data, reg >> 8);
+	_it87_write_value(data, reg & 0xff, value);
 }
 
 static void it87_update_pwm_ctrl(struct it87_data *data, int nr)
 {
-	data->pwm_ctrl[nr] = it87_read_value(data, IT87_REG_PWM[nr]);
+	data->pwm_ctrl[nr] = it87_read_value(data, data->REG_PWM[nr]);
 	if (has_newer_autopwm(data)) {
-		data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
+		if (has_new_tempmap(data))
+			data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x38;
+		else
+			data->pwm_temp_map[nr] = data->pwm_ctrl[nr] & 0x03;
 		data->pwm_duty[nr] = it87_read_value(data,
 						     IT87_REG_PWM_DUTY[nr]);
 	} else {
@@ -908,15 +1091,15 @@
 				continue;
 
 			data->fan[i][1] =
-				it87_read_value(data, IT87_REG_FAN_MIN[i]);
+				it87_read_value(data, data->REG_FAN_MIN[i]);
 			data->fan[i][0] = it87_read_value(data,
-				       IT87_REG_FAN[i]);
+				       data->REG_FAN[i]);
 			/* Add high byte if in 16-bit mode */
 			if (has_16bit_fans(data)) {
 				data->fan[i][0] |= it87_read_value(data,
-						IT87_REG_FANX[i]) << 8;
+						data->REG_FANX[i]) << 8;
 				data->fan[i][1] |= it87_read_value(data,
-						IT87_REG_FANX_MIN[i]) << 8;
+						data->REG_FANX_MIN[i]) << 8;
 			}
 		}
 		for (i = 0; i < NUM_TEMP; i++) {
@@ -928,15 +1111,15 @@
 			if (has_temp_offset(data) && i < NUM_TEMP_OFFSET)
 				data->temp[i][3] =
 				  it87_read_value(data,
-						  IT87_REG_TEMP_OFFSET[i]);
+						  data->REG_TEMP_OFFSET[i]);
 
-			if (i >= NUM_TEMP_LIMIT)
+			if (i >= data->num_temp_limit)
 				continue;
 
 			data->temp[i][1] =
-				it87_read_value(data, IT87_REG_TEMP_LOW(i));
+				it87_read_value(data, data->REG_TEMP_LOW[i]);
 			data->temp[i][2] =
-				it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+				it87_read_value(data, data->REG_TEMP_HIGH[i]);
 		}
 
 		/* Newer chips don't have clock dividers */
@@ -1116,10 +1299,10 @@
 	switch (index) {
 	default:
 	case 1:
-		reg = IT87_REG_TEMP_LOW(nr);
+		reg = data->REG_TEMP_LOW[nr];
 		break;
 	case 2:
-		reg = IT87_REG_TEMP_HIGH(nr);
+		reg = data->REG_TEMP_HIGH[nr];
 		break;
 	case 3:
 		regval = it87_read_value(data, IT87_REG_BEEP_ENABLE);
@@ -1127,8 +1310,8 @@
 			regval |= 0x80;
 			it87_write_value(data, IT87_REG_BEEP_ENABLE, regval);
 		}
-		data->valid = false;
-		reg = IT87_REG_TEMP_OFFSET[nr];
+		data->valid = 0;
+		reg = data->REG_TEMP_OFFSET[nr];
 		break;
 	}
 
@@ -1160,8 +1343,26 @@
 static SENSOR_DEVICE_ATTR_2(temp3_offset, S_IRUGO | S_IWUSR, show_temp,
 			    set_temp, 2, 3);
 static SENSOR_DEVICE_ATTR_2(temp4_input, S_IRUGO, show_temp, NULL, 3, 0);
+static SENSOR_DEVICE_ATTR_2(temp4_min, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 3, 1);
+static SENSOR_DEVICE_ATTR_2(temp4_max, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 3, 2);
+static SENSOR_DEVICE_ATTR_2(temp4_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 3, 3);
 static SENSOR_DEVICE_ATTR_2(temp5_input, S_IRUGO, show_temp, NULL, 4, 0);
+static SENSOR_DEVICE_ATTR_2(temp5_min, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 4, 1);
+static SENSOR_DEVICE_ATTR_2(temp5_max, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 4, 2);
+static SENSOR_DEVICE_ATTR_2(temp5_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 4, 3);
 static SENSOR_DEVICE_ATTR_2(temp6_input, S_IRUGO, show_temp, NULL, 5, 0);
+static SENSOR_DEVICE_ATTR_2(temp6_min, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 5, 1);
+static SENSOR_DEVICE_ATTR_2(temp6_max, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 5, 2);
+static SENSOR_DEVICE_ATTR_2(temp6_offset, S_IRUGO | S_IWUSR, show_temp,
+			    set_temp, 5, 3);
 
 static int get_temp_type(struct it87_data *data, int index)
 {
@@ -1176,6 +1377,61 @@
 	u8 reg, extra;
 	int ttype, type = 0;
 
+	if (has_bank_sel(data)) {
+		int s1reg = IT87_REG_TEMP_SRC1[index/2] >> ((index % 2) * 4);
+		u8 src1, src2;
+
+		src1 = (it87_read_value(data, s1reg) >> ((index % 2) * 4)) & 0x0f;
+		src2 = it87_read_value(data, IT87_REG_TEMP_SRC2);
+
+		switch (data->type) {
+		case it8686:
+			switch (src1) {
+			case 0:
+				if (index >= 3)
+					return 4;
+				break;
+			case 1:
+				if (index == 1 || index == 2 ||
+				    index == 4 || index == 5)
+					return 6;
+				break;
+			case 2:
+				if (index == 2 || index == 6)
+					return 5;
+				break;
+			default:
+				break;
+			}
+			break;
+		case it8625:
+			if (index < 3)
+				break;
+		case it8655:
+		case it8665:
+			if (src1 < 3) {
+				index = src1;
+				break;
+			}
+			switch(src1) {
+			case 3:
+				type = (src2 & BIT(index)) ? 6 : 5;
+				break;
+			case 4 ... 8:
+				type = (src2 & BIT(index)) ? 4 : 6;
+				break;
+			case 9:
+				type = (src2 & BIT(index)) ? 5 : 0;
+				break;
+			default:
+				break;
+			}
+			return type;
+		default:
+			return 0;
+		}
+	}
+
 	/* Detect PECI vs. AMDTSI */
 	ttype = 6;
 	if ((has_temp_peci(data, index)) || data->type == it8721 ||
@@ -1287,6 +1543,12 @@
 			  set_temp_type, 1);
 static SENSOR_DEVICE_ATTR(temp3_type, S_IRUGO | S_IWUSR, show_temp_type,
 			  set_temp_type, 2);
+static SENSOR_DEVICE_ATTR(temp4_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 3);
+static SENSOR_DEVICE_ATTR(temp5_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 4);
+static SENSOR_DEVICE_ATTR(temp6_type, S_IRUGO | S_IWUSR, show_temp_type,
+			  set_temp_type, 5);
 
 /* 6 Fans */
 
@@ -1295,8 +1557,12 @@
 	if (has_fanctl_onoff(data) && nr < 3 &&
 	    !(data->fan_main_ctrl & BIT(nr)))
 		return 0;			/* Full speed */
-	if (data->pwm_ctrl[nr] & 0x80)
-		return 2;			/* Automatic mode */
+	if (data->pwm_ctrl[nr] & 0x80) {
+		if (data->pwm_ctrl[nr] & 0x04)
+			return 3;		/* Tach closed-loop */
+		else
+			return 2;		/* Automatic mode */
+	}
 	if ((!has_fanctl_onoff(data) || nr >= 3) &&
 	    data->pwm_duty[nr] == pwm_to_reg(data, 0xff))
 		return 0;			/* Full speed */
@@ -1323,6 +1589,18 @@
 	return sprintf(buf, "%d\n", speed);
 }
 
+static ssize_t show_fan_target(struct device *dev, struct device_attribute *attr,
+			       char *buf)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	struct it87_data *data = it87_update_device(dev);
+	int factor = data->type == it8613 ? 32 : 16;
+	int nr = sensor_attr->index;
+
+	return sprintf(buf, "%d\n",
+		       pwm_from_reg(data, data->pwm_duty[nr]) * factor);
+}
+
 static ssize_t show_fan_div(struct device *dev, struct device_attribute *attr,
 			    char *buf)
 {
@@ -1406,9 +1684,9 @@
 
 	if (has_16bit_fans(data)) {
 		data->fan[nr][index] = FAN16_TO_REG(val);
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
+		it87_write_value(data, data->REG_FAN_MIN[nr],
 				 data->fan[nr][index] & 0xff);
-		it87_write_value(data, IT87_REG_FANX_MIN[nr],
+		it87_write_value(data, data->REG_FANX_MIN[nr],
 				 data->fan[nr][index] >> 8);
 	} else {
 		reg = it87_read_value(data, IT87_REG_FAN_DIV);
@@ -1425,7 +1703,7 @@
 		}
 		data->fan[nr][index] =
 		  FAN_TO_REG(val, DIV_FROM_REG(data->fan_div[nr]));
-		it87_write_value(data, IT87_REG_FAN_MIN[nr],
+		it87_write_value(data, data->REG_FAN_MIN[nr],
 				 data->fan[nr][index]);
 	}
 
@@ -1433,6 +1711,38 @@
 	return count;
 }
 
+static ssize_t set_fan_target(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	struct it87_data *data = dev_get_drvdata(dev);
+	int factor = data->type == it8613 ? 32 : 16;
+	int nr = sensor_attr->index;
+	long val, tolerance;
+
+	if (kstrtol(buf, 10, &val) < 0)
+		return -EINVAL;
+
+	val = DIV_ROUND_UP(val, factor);
+	if (val < 0 || val > 255)
+		return -EINVAL;
+
+	if ((data->pwm_ctrl[nr] & 0x84) != 0x84)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+	data->pwm_duty[nr] = pwm_to_reg(data, val);
+	tolerance = max_t(long, val / 18, 6);
+	it87_write_value(data, IT87_REG_PWM_DUTY[nr],
+			 data->pwm_duty[nr]);
+	it87_write_value(data, IT87_REG_AUTO_TEMP(nr, 4),
+			 0x80 | (tolerance / 2));
+	it87_write_value(data, IT87_REG_AUTO_TEMP(nr, 6),
+			 tolerance);
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
 static ssize_t set_fan_div(struct device *dev, struct device_attribute *attr,
 			   const char *buf, size_t count)
 {
@@ -1475,7 +1785,7 @@
 
 	/* Restore fan min limit */
 	data->fan[nr][1] = FAN_TO_REG(min, DIV_FROM_REG(data->fan_div[nr]));
-	it87_write_value(data, IT87_REG_FAN_MIN[nr], data->fan[nr][1]);
+	it87_write_value(data, data->REG_FAN_MIN[nr], data->fan[nr][1]);
 
 	it87_unlock(data);
 	return count;
@@ -1520,7 +1830,10 @@
 	long val;
 	int err;
 
-	if (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 2)
+	if (kstrtol(buf, 10, &val) < 0 || val < 0 || val > 3)
+		return -EINVAL;
+
+	if (val == 3 && !has_tach_closed_loop(data))
 		return -EINVAL;
 
 	/* Check trip points before switching to automatic mode */
@@ -1558,21 +1871,24 @@
 				ctrl = data->pwm_duty[nr];
 			}
 			data->pwm_ctrl[nr] = ctrl;
-			it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+			it87_write_value(data, data->REG_PWM[nr], ctrl);
 		}
 	} else {
 		u8 ctrl;
 
 		if (has_newer_autopwm(data)) {
-			ctrl = (data->pwm_ctrl[nr] & 0x7c) |
-				data->pwm_temp_map[nr];
+			if (val == 3)
+				ctrl = 0x04;
+			else
+				ctrl = (data->pwm_ctrl[nr] & 0x7c) |
+					data->pwm_temp_map[nr];
 			if (val != 1)
 				ctrl |= 0x80;
 		} else {
 			ctrl = (val == 1 ? data->pwm_duty[nr] : 0x80);
 		}
 		data->pwm_ctrl[nr] = ctrl;
-		it87_write_value(data, IT87_REG_PWM[nr], ctrl);
+		it87_write_value(data, data->REG_PWM[nr], ctrl);
 
 		if (has_fanctl_onoff(data) && nr < 3) {
 			/* set SmartGuardian mode */
@@ -1623,7 +1939,7 @@
 		 */
 		if (!(data->pwm_ctrl[nr] & 0x80)) {
 			data->pwm_ctrl[nr] = data->pwm_duty[nr];
-			it87_write_value(data, IT87_REG_PWM[nr],
+			it87_write_value(data, data->REG_PWM[nr],
 					 data->pwm_ctrl[nr]);
 		}
 	}
@@ -1684,10 +2000,16 @@
 		return PTR_ERR(data);
 
 	map = data->pwm_temp_map[nr];
-	if (map >= 3)
-		map = 0;	/* Should never happen */
-	if (nr >= 3)		/* pwm channels 3..6 map to temp4..6 */
-		map += 3;
+	if (has_new_tempmap(data)) {
+		map >>= 3;
+		if (map >= 6)
+			map = 0;	/* Should never happen */
+	} else {
+		if (map >= 3)
+			map = 0;	/* Should never happen */
+		if (nr >= 3)		/* pwm channels 3..6 map to temp4..6 */
+			map += 3;
+	}
 
 	return sprintf(buf, "%d\n", (int)BIT(map));
 }
@@ -1706,7 +2028,7 @@
 	if (kstrtol(buf, 10, &val) < 0)
 		return -EINVAL;
 
-	if (nr >= 3)
+	if (nr >= 3 && !has_new_tempmap(data))
 		val -= 3;
 
 	switch (val) {
@@ -1719,10 +2041,27 @@
 	case BIT(2):
 		reg = 0x02;
 		break;
+	case BIT(3):
+		reg = 0x03;
+		break;
+	case BIT(4):
+		reg = 0x04;
+		break;
+	case BIT(5):
+		reg = 0x05;
+		break;
+	case BIT(6):
+		reg = 0x06;
+		break;
 	default:
 		return -EINVAL;
 	}
 
+	if (has_new_tempmap(data))
+		reg <<= 3;
+	else if (reg > 0x02)
+		return -EINVAL;
+
 	err = it87_lock(data);
 	if (err)
 		return err;
@@ -1734,9 +2073,10 @@
 	 * otherwise, just store it for later use.
 	 */
 	if (data->pwm_ctrl[nr] & 0x80) {
-		data->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & 0xfc) |
+		u8 mask = has_new_tempmap(data) ? 0xc7 : 0xfc;
+		data->pwm_ctrl[nr] = (data->pwm_ctrl[nr] & mask) |
 						data->pwm_temp_map[nr];
-		it87_write_value(data, IT87_REG_PWM[nr], data->pwm_ctrl[nr]);
+		it87_write_value(data, data->REG_PWM[nr], data->pwm_ctrl[nr]);
 	}
 	it87_unlock(data);
 	return count;
@@ -1885,30 +2225,42 @@
 			    0, 1);
 static SENSOR_DEVICE_ATTR(fan1_div, S_IRUGO | S_IWUSR, show_fan_div,
 			  set_fan_div, 0);
+static SENSOR_DEVICE_ATTR(fan1_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 0);
 
 static SENSOR_DEVICE_ATTR_2(fan2_input, S_IRUGO, show_fan, NULL, 1, 0);
 static SENSOR_DEVICE_ATTR_2(fan2_min, S_IRUGO | S_IWUSR, show_fan, set_fan,
 			    1, 1);
 static SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR, show_fan_div,
 			  set_fan_div, 1);
+static SENSOR_DEVICE_ATTR(fan2_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 1);
 
 static SENSOR_DEVICE_ATTR_2(fan3_input, S_IRUGO, show_fan, NULL, 2, 0);
 static SENSOR_DEVICE_ATTR_2(fan3_min, S_IRUGO | S_IWUSR, show_fan, set_fan,
 			    2, 1);
 static SENSOR_DEVICE_ATTR(fan3_div, S_IRUGO | S_IWUSR, show_fan_div,
 			  set_fan_div, 2);
+static SENSOR_DEVICE_ATTR(fan3_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 2);
 
 static SENSOR_DEVICE_ATTR_2(fan4_input, S_IRUGO, show_fan, NULL, 3, 0);
 static SENSOR_DEVICE_ATTR_2(fan4_min, S_IRUGO | S_IWUSR, show_fan, set_fan,
 			    3, 1);
+static SENSOR_DEVICE_ATTR(fan4_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 3);
 
 static SENSOR_DEVICE_ATTR_2(fan5_input, S_IRUGO, show_fan, NULL, 4, 0);
 static SENSOR_DEVICE_ATTR_2(fan5_min, S_IRUGO | S_IWUSR, show_fan, set_fan,
 			    4, 1);
+static SENSOR_DEVICE_ATTR(fan5_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 4);
 
 static SENSOR_DEVICE_ATTR_2(fan6_input, S_IRUGO, show_fan, NULL, 5, 0);
 static SENSOR_DEVICE_ATTR_2(fan6_min, S_IRUGO | S_IWUSR, show_fan, set_fan,
 			    5, 1);
+static SENSOR_DEVICE_ATTR(fan6_target, S_IRUGO | S_IWUSR, show_fan_target,
+			  set_fan_target, 5);
 
 static SENSOR_DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
 			  show_pwm_enable, set_pwm_enable, 0);
@@ -2102,7 +2454,7 @@
 		config |= BIT(5);
 		it87_write_value(data, IT87_REG_CONFIG, config);
 		/* Invalidate cache to force re-read */
-		data->valid = false;
+		data->valid = 0;
 	}
 	it87_unlock(data);
 	return count;
@@ -2125,6 +2477,9 @@
 static SENSOR_DEVICE_ATTR(temp1_alarm, S_IRUGO, show_alarm, NULL, 16);
 static SENSOR_DEVICE_ATTR(temp2_alarm, S_IRUGO, show_alarm, NULL, 17);
 static SENSOR_DEVICE_ATTR(temp3_alarm, S_IRUGO, show_alarm, NULL, 18);
+static SENSOR_DEVICE_ATTR(temp4_alarm, S_IRUGO, show_alarm, NULL, 19);
+static SENSOR_DEVICE_ATTR(temp5_alarm, S_IRUGO, show_alarm, NULL, 20);
+static SENSOR_DEVICE_ATTR(temp6_alarm, S_IRUGO, show_alarm, NULL, 21);
 static SENSOR_DEVICE_ATTR(intrusion0_alarm, S_IRUGO | S_IWUSR,
 			  show_alarm, clear_intrusion, 4);
 
@@ -2185,6 +2540,9 @@
 			  show_beep, set_beep, 2);
 static SENSOR_DEVICE_ATTR(temp2_beep, S_IRUGO, show_beep, NULL, 2);
 static SENSOR_DEVICE_ATTR(temp3_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp4_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp5_beep, S_IRUGO, show_beep, NULL, 2);
+static SENSOR_DEVICE_ATTR(temp6_beep, S_IRUGO, show_beep, NULL, 2);
 
 static ssize_t vrm_show(struct device *dev, struct device_attribute *attr,
 			char *buf)
@@ -2221,6 +2579,115 @@
 }
 static DEVICE_ATTR_RO(cpu0_vid);
 
+static ssize_t eup_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct it87_data *data = dev_get_drvdata(dev);
+	u8 reg;
+
+	mutex_lock(&data->update_lock);
+
+	superio_enter(REG_2E);
+	superio_select(REG_2E, PME);
+	reg = superio_inb(REG_2E, IT87_EUP_REG);
+	superio_exit(REG_2E, has_conf_noexit(data));
+
+	mutex_unlock(&data->update_lock);
+
+	return sprintf(buf, "0x%x\n", reg);
+}
+
+static ssize_t eup_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct it87_data *data = dev_get_drvdata(dev);
+	long val;
+
+	/* Bits 5-7 are reserved */
+	if (kstrtol(buf, 0, &val) < 0 || val < 0 || val > 0x1f)
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+
+	superio_enter(REG_2E);
+	superio_select(REG_2E, PME);
+	superio_outb(REG_2E, IT87_EUP_REG, (int)val);
+	superio_exit(REG_2E, has_conf_noexit(data));
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(eup);
+
+#define POWER_LAST_STATE 2
+#define POWER_ALWAYS_ON  1
+#define POWER_ALWAYS_OFF 0
+static ssize_t poweron_show(struct device *dev, struct device_attribute *attr,
+		char *buf)
+{
+	struct it87_data *data = dev_get_drvdata(dev);
+	const char *desc;
+	u8 reg;
+	u8 pcr1, pcr2;
+
+	mutex_lock(&data->update_lock);
+
+	superio_enter(REG_2E);
+	superio_select(REG_2E, PME);
+	pcr1 = superio_inb(REG_2E, IT87_PCR1_REG);
+	pcr2 = superio_inb(REG_2E, IT87_PCR2_REG);
+	reg = ((pcr1 & 0x20) >> 4) | ((pcr2 & 0x20) >> 5);
+	superio_exit(REG_2E, has_conf_noexit(data));
+
+	mutex_unlock(&data->update_lock);
+
+	if (reg & POWER_ALWAYS_ON)
+		desc = "always_on";
+	else if (reg == POWER_LAST_STATE)
+		desc = "last_state";
+	else if (reg == POWER_ALWAYS_OFF)
+		desc = "always_off";
+	else
+		desc = "unknown";
+
+	return sprintf(buf, "%s\n", desc);
+}
+
+static ssize_t poweron_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct it87_data *data = dev_get_drvdata(dev);
+	int val;
+	u8 reg;
+
+	if (strncasecmp(buf, "always_on", 9) == 0)
+		reg = POWER_ALWAYS_ON;
+	else if (strncasecmp(buf, "last_state", 10) == 0)
+		reg = POWER_LAST_STATE;
+	else if (strncasecmp(buf, "always_off", 10) == 0)
+		reg = POWER_ALWAYS_OFF;
+	else
+		return -EINVAL;
+
+	mutex_lock(&data->update_lock);
+
+	superio_enter(REG_2E);
+	superio_select(REG_2E, PME);
+	val = (superio_inb(REG_2E, IT87_PCR1_REG) & ~0x20) | ((reg & 2) << 4);
+	superio_outb(REG_2E, IT87_PCR1_REG, val);
+	val = (superio_inb(REG_2E, IT87_PCR2_REG) & ~0x60) | ((reg & 1) << 5);
+	superio_outb(REG_2E, IT87_PCR2_REG, val);
+	superio_exit(REG_2E, has_conf_noexit(data));
+
+	mutex_unlock(&data->update_lock);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(poweron);
+
 static ssize_t show_label(struct device *dev, struct device_attribute *attr,
 			  char *buf)
 {
@@ -2361,6 +2828,19 @@
 		return attr->mode;
 	}
 
+	if (a && i >= data->num_temp_limit)
+		return 0;
+
+	if (a == 3) {
+		int type = get_temp_type(data, i);
+
+		if (type == 0)
+			return 0;
+		if (has_bank_sel(data))
+			return 0444;
+		return attr->mode;
+	}
+
 	if (a == 5 && !has_temp_offset(data))
 		return 0;
 
@@ -2374,7 +2854,7 @@
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
 	&sensor_dev_attr_temp1_max.dev_attr.attr,
 	&sensor_dev_attr_temp1_min.dev_attr.attr,
-	&sensor_dev_attr_temp1_type.dev_attr.attr,
+	&sensor_dev_attr_temp1_type.dev_attr.attr,	/* 3 */
 	&sensor_dev_attr_temp1_alarm.dev_attr.attr,
 	&sensor_dev_attr_temp1_offset.dev_attr.attr,	/* 5 */
 	&sensor_dev_attr_temp1_beep.dev_attr.attr,	/* 6 */
@@ -2396,8 +2876,28 @@
 	&sensor_dev_attr_temp3_beep.dev_attr.attr,
 
 	&sensor_dev_attr_temp4_input.dev_attr.attr,	/* 21 */
+	&sensor_dev_attr_temp4_max.dev_attr.attr,
+	&sensor_dev_attr_temp4_min.dev_attr.attr,
+	&sensor_dev_attr_temp4_type.dev_attr.attr,
+	&sensor_dev_attr_temp4_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp4_offset.dev_attr.attr,
+	&sensor_dev_attr_temp4_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp5_input.dev_attr.attr,
+	&sensor_dev_attr_temp5_max.dev_attr.attr,
+	&sensor_dev_attr_temp5_min.dev_attr.attr,
+	&sensor_dev_attr_temp5_type.dev_attr.attr,
+	&sensor_dev_attr_temp5_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp5_offset.dev_attr.attr,
+	&sensor_dev_attr_temp5_beep.dev_attr.attr,
+
 	&sensor_dev_attr_temp6_input.dev_attr.attr,
+	&sensor_dev_attr_temp6_max.dev_attr.attr,
+	&sensor_dev_attr_temp6_min.dev_attr.attr,
+	&sensor_dev_attr_temp6_type.dev_attr.attr,
+	&sensor_dev_attr_temp6_alarm.dev_attr.attr,
+	&sensor_dev_attr_temp6_offset.dev_attr.attr,
+	&sensor_dev_attr_temp6_beep.dev_attr.attr,
 	NULL
 };
 
@@ -2415,7 +2915,7 @@
 	if ((index == 2 || index == 3) && !data->has_vid)
 		return 0;
 
-	if (index > 3 && !(data->in_internal & BIT(index - 4)))
+	if (index > 5 && !(data->in_internal & BIT(index - 6)))
 		return 0;
 
 	return attr->mode;
@@ -2430,6 +2930,8 @@
 	&sensor_dev_attr_in7_label.dev_attr.attr,
 	&sensor_dev_attr_in8_label.dev_attr.attr,
 	&sensor_dev_attr_in9_label.dev_attr.attr,
+	&dev_attr_eup.attr,				/* 8 */
+	&dev_attr_poweron.attr,				/* 9 */
 	NULL
 };
 
@@ -2443,12 +2945,12 @@
 {
 	struct device *dev = kobj_to_dev(kobj);
 	struct it87_data *data = dev_get_drvdata(dev);
-	int i = index / 5;	/* fan index */
-	int a = index % 5;	/* attribute index */
+	int i = index / 6;	/* fan index */
+	int a = index % 6;	/* attribute index */
 
-	if (index >= 15) {	/* fan 4..6 don't have divisor attributes */
-		i = (index - 15) / 4 + 3;
-		a = (index - 15) % 4;
+	if (index >= 18) {	/* fan 4..6 don't have divisor attributes */
+		i = (index - 18) / 5 + 4;
+		a = (index - 18) % 5;
 	}
 
 	if (!(data->has_fan & BIT(i)))
@@ -2462,7 +2964,10 @@
 			return attr->mode | S_IWUSR;
 	}
 
-	if (a == 4 && has_16bit_fans(data))	/* divisor */
+	if (a == 4 && has_16bit_fans(data))		/* divisor */
+		return 0;
+
+	if (a == 5 && !has_tach_closed_loop(data))	/* target */
 		return 0;
 
 	return attr->mode;
@@ -2474,33 +2979,39 @@
 	&sensor_dev_attr_fan1_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan1_beep.dev_attr.attr,	/* 3 */
 	&sensor_dev_attr_fan1_div.dev_attr.attr,	/* 4 */
+	&sensor_dev_attr_fan1_target.dev_attr.attr,	/* 5 */
 
 	&sensor_dev_attr_fan2_input.dev_attr.attr,
 	&sensor_dev_attr_fan2_min.dev_attr.attr,
 	&sensor_dev_attr_fan2_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan2_beep.dev_attr.attr,
-	&sensor_dev_attr_fan2_div.dev_attr.attr,	/* 9 */
+	&sensor_dev_attr_fan2_div.dev_attr.attr,	/* 10 */
+	&sensor_dev_attr_fan2_target.dev_attr.attr,	/* 11 */
 
 	&sensor_dev_attr_fan3_input.dev_attr.attr,
 	&sensor_dev_attr_fan3_min.dev_attr.attr,
 	&sensor_dev_attr_fan3_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan3_beep.dev_attr.attr,
-	&sensor_dev_attr_fan3_div.dev_attr.attr,	/* 14 */
+	&sensor_dev_attr_fan3_div.dev_attr.attr,	/* 16 */
+	&sensor_dev_attr_fan3_target.dev_attr.attr,	/* 17 */
 
-	&sensor_dev_attr_fan4_input.dev_attr.attr,	/* 15 */
+	&sensor_dev_attr_fan4_input.dev_attr.attr,	/* 18 */
 	&sensor_dev_attr_fan4_min.dev_attr.attr,
 	&sensor_dev_attr_fan4_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan4_beep.dev_attr.attr,
+	&sensor_dev_attr_fan4_target.dev_attr.attr,	/* 22 */
 
-	&sensor_dev_attr_fan5_input.dev_attr.attr,	/* 19 */
+	&sensor_dev_attr_fan5_input.dev_attr.attr,	/* 23 */
 	&sensor_dev_attr_fan5_min.dev_attr.attr,
 	&sensor_dev_attr_fan5_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan5_beep.dev_attr.attr,
+	&sensor_dev_attr_fan5_target.dev_attr.attr,	/* 27 */
 
-	&sensor_dev_attr_fan6_input.dev_attr.attr,	/* 23 */
+	&sensor_dev_attr_fan6_input.dev_attr.attr,	/* 28 */
 	&sensor_dev_attr_fan6_min.dev_attr.attr,
 	&sensor_dev_attr_fan6_alarm.dev_attr.attr,
 	&sensor_dev_attr_fan6_beep.dev_attr.attr,
+	&sensor_dev_attr_fan6_target.dev_attr.attr,
 	NULL
 };
 
@@ -2745,15 +3256,33 @@
 	case IT8623E_DEVID:
 		sio_data->type = it8603;
 		break;
+	case IT8607E_DEVID:
+		sio_data->type = it8607;
+		break;
+	case IT8613E_DEVID:
+		sio_data->type = it8613;
+		break;
 	case IT8620E_DEVID:
 		sio_data->type = it8620;
 		break;
 	case IT8622E_DEVID:
 		sio_data->type = it8622;
 		break;
+	case IT8625E_DEVID:
+		sio_data->type = it8625;
+		break;
 	case IT8628E_DEVID:
 		sio_data->type = it8628;
 		break;
+	case IT8655E_DEVID:
+		sio_data->type = it8655;
+		break;
+	case IT8665E_DEVID:
+		sio_data->type = it8665;
+		break;
+	case IT8686E_DEVID:
+		sio_data->type = it8686;
+		break;
 	case IT87952E_DEVID:
 		sio_data->type = it87952;
 		break;
@@ -2884,7 +3413,7 @@
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8603) {
+	} else if (sio_data->type == it8603 || sio_data->type == it8607) {
 		int reg27, reg29;
 
 		superio_select(sioaddr, GPIO);
@@ -2904,12 +3433,56 @@
 		if (reg29 & BIT(2))
 			sio_data->skip_fan |= BIT(1);
 
-		sio_data->skip_in |= BIT(5); /* No VIN5 */
-		sio_data->skip_in |= BIT(6); /* No VIN6 */
+		if (sio_data->type == it8603) {
+			sio_data->skip_in |= BIT(5); /* No VIN5 */
+			sio_data->skip_in |= BIT(6); /* No VIN6 */
+		}
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
-	} else if (sio_data->type == it8620 || sio_data->type == it8628) {
+	} else if (sio_data->type == it8613) {
+		int reg27, reg29, reg2a, regX;
+
+		superio_select(sioaddr, GPIO);
+
+		/* FIXME: Hack to enable internal pull-up on RR2304 PWR LED */
+		regX = superio_inb(sioaddr, 0xbb);
+		superio_outb(sioaddr, 0xbb, regX | BIT(0));
+
+		/* Check for pwm3, fan3, pwm5, fan5 */
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg27 & BIT(1))
+			sio_data->skip_fan |= BIT(4);
+		if (reg27 & BIT(3))
+			sio_data->skip_pwm |= BIT(4);
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for pwm2, fan2 */
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg29 & BIT(2))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm4, fan4 */
+		reg2a = superio_inb(sioaddr, IT87_SIO_PINX1_REG);
+		if (!(reg2a & BIT(0)) || (reg29 & BIT(7))) {
+			sio_data->skip_fan |= BIT(3);
+			sio_data->skip_pwm |= BIT(3);
+		}
+
+		sio_data->skip_pwm |= BIT(0); /* No pwm1 */
+		sio_data->skip_fan |= BIT(0); /* No fan1 */
+		sio_data->skip_in |= BIT(3);  /* No VIN3 */
+		sio_data->skip_in |= BIT(6);  /* No VIN6 */
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8620 || sio_data->type == it8628 ||
+		   sio_data->type == it8686) {
 		int reg;
 
 		superio_select(sioaddr, GPIO);
@@ -2952,10 +3525,14 @@
 
 		/* Check if AVCC is on VIN3 */
 		reg = superio_inb(sioaddr, IT87_SIO_PINX2_REG);
-		if (reg & BIT(0))
-			sio_data->internal |= BIT(0);
-		else
+		if (reg & BIT(0)) {
+			/* For it8686, the bit just enables AVCC3 */
+			if (sio_data->type != it8686)
+				sio_data->internal |= BIT(0);
+		} else {
+			sio_data->internal &= ~BIT(3);
 			sio_data->skip_in |= BIT(9);
+		}
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
@@ -3024,6 +3601,102 @@
 
 		sio_data->beep_pin = superio_inb(sioaddr,
 						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+
+		if (dmi_match(DMI_PRODUCT_NAME, "ReadyNAS 3130") ||
+		    dmi_match(DMI_PRODUCT_NAME, "ReadyNAS 3138")) {
+			/* Set GPIO Set 1 Multi-Function Pin Selection Register
+			 * to put RN3130/3138 USB and Marvell SATA hardware reset
+			 * pins in GPIO mode, so we have control over them during
+			 * runtime. */
+			int reg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);
+			reg25 |= BIT(1) | BIT(2);
+			superio_outb(sioaddr, IT87_SIO_GPIO1_REG, reg25);
+			if (reg & BIT(0)) {
+				reg &= ~BIT(0);
+				pr_notice("Configuring VIN3 for external sensor\n");
+				superio_outb(sioaddr, IT87_SIO_PINX2_REG, reg);
+			}
+			fix_pwm_polarity = true;
+		}
+	} else if (sio_data->type == it8655) {
+		int reg;
+
+		superio_select(sioaddr, GPIO);
+
+		/* Check for pwm2 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		if (reg & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+
+		/* Check for fan2 */
+		reg = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		if (reg & BIT(4))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		reg = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		if (reg & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
+	} else if (sio_data->type == it8665 || sio_data->type == it8625) {
+		int reg27, reg29, reg2d, regd3;
+
+		superio_select(sioaddr, GPIO);
+
+		reg27 = superio_inb(sioaddr, IT87_SIO_GPIO3_REG);
+		reg29 = superio_inb(sioaddr, IT87_SIO_GPIO5_REG);
+		reg2d = superio_inb(sioaddr, IT87_SIO_PINX4_REG);
+		regd3 = superio_inb(sioaddr, IT87_SIO_GPIO9_REG);
+
+		/* Check for pwm2, fan2 */
+		if (reg29 & BIT(1))
+			sio_data->skip_pwm |= BIT(1);
+		if (reg2d & BIT(4))
+			sio_data->skip_fan |= BIT(1);
+
+		/* Check for pwm3, fan3 */
+		if (reg27 & BIT(6))
+			sio_data->skip_pwm |= BIT(2);
+		if (reg27 & BIT(7))
+			sio_data->skip_fan |= BIT(2);
+
+		/* Check for pwm4, fan4, pwm5, fan5 */
+		if (sio_data->type == it8625) {
+			int reg25 = superio_inb(sioaddr, IT87_SIO_GPIO1_REG);
+
+			if (reg25 & BIT(6))
+				sio_data->skip_fan |= BIT(3);
+			if (reg25 & BIT(5))
+				sio_data->skip_pwm |= BIT(3);
+			if (reg27 & BIT(3))
+				sio_data->skip_pwm |= BIT(4);
+			if (!(reg27 & BIT(1)))
+				sio_data->skip_fan |= BIT(4);
+		} else {
+			int reg26 = superio_inb(sioaddr, IT87_SIO_GPIO2_REG);
+
+			if (regd3 & BIT(2))
+				sio_data->skip_pwm |= BIT(3);
+			if (regd3 & BIT(3))
+				sio_data->skip_fan |= BIT(3);
+			if (reg26 & BIT(5))
+				sio_data->skip_pwm |= BIT(4);
+			if (!(reg26 & BIT(4)))
+				sio_data->skip_fan |= BIT(4);
+		}
+
+		/* Check for pwm6, fan6 */
+		if (regd3 & BIT(0))
+			sio_data->skip_pwm |= BIT(5);
+		if (regd3 & BIT(1))
+			sio_data->skip_fan |= BIT(5);
+
+		sio_data->beep_pin = superio_inb(sioaddr,
+						 IT87_SIO_BEEP_PIN_REG) & 0x3f;
 	} else {
 		int reg;
 		bool uart6;
@@ -3147,6 +3820,68 @@
 	return err;
 }
 
+static void it87_init_regs(struct platform_device *pdev)
+{
+	struct it87_data *data = platform_get_drvdata(pdev);
+
+	/* Initialize chip specific register pointers */
+	switch (data->type) {
+	case it8686:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET_8686;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW_8686;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH_8686;
+		break;
+	case it8625:
+	case it8655:
+	case it8665:
+		data->REG_FAN = IT87_REG_FAN_8665;
+		data->REG_FANX = IT87_REG_FANX_8665;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN_8665;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN_8665;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8622:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	case it8613:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM_8665;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	default:
+		data->REG_FAN = IT87_REG_FAN;
+		data->REG_FANX = IT87_REG_FANX;
+		data->REG_FAN_MIN = IT87_REG_FAN_MIN;
+		data->REG_FANX_MIN = IT87_REG_FANX_MIN;
+		data->REG_PWM = IT87_REG_PWM;
+		data->REG_TEMP_OFFSET = IT87_REG_TEMP_OFFSET;
+		data->REG_TEMP_LOW = IT87_REG_TEMP_LOW;
+		data->REG_TEMP_HIGH = IT87_REG_TEMP_HIGH;
+		break;
+	}
+}
+
+
 /*
  * Some chips seem to have default value 0xff for all limit
  * registers. For low voltage limits it makes no sense and triggers
@@ -3163,10 +3898,10 @@
 		if (reg == 0xff)
 			it87_write_value(data, IT87_REG_VIN_MIN(i), 0);
 	}
-	for (i = 0; i < NUM_TEMP_LIMIT; i++) {
-		reg = it87_read_value(data, IT87_REG_TEMP_HIGH(i));
+	for (i = 0; i < data->num_temp_limit; i++) {
+		reg = it87_read_value(data, data->REG_TEMP_HIGH[i]);
 		if (reg == 0xff)
-			it87_write_value(data, IT87_REG_TEMP_HIGH(i), 127);
+			it87_write_value(data, data->REG_TEMP_HIGH[i], 127);
 	}
 }
 
@@ -3305,7 +4040,7 @@
 	 */
 	int tmp = it87_read_value(data, IT87_REG_FAN_CTL);
 
-	if ((tmp & 0x87) == 0) {
+	if ((tmp & 0x80) == 0) {
 		if (fix_pwm_polarity) {
 			/*
 			 * The user asks us to attempt a chip reconfiguration.
@@ -3317,7 +4052,7 @@
 
 			for (i = 0; i < ARRAY_SIZE(pwm); i++)
 				pwm[i] = it87_read_value(data,
-							 IT87_REG_PWM[i]);
+							 data->REG_PWM[i]);
 
 			/*
 			 * If any fan is in automatic pwm mode, the polarity
@@ -3332,7 +4067,7 @@
 						 tmp | 0x87);
 				for (i = 0; i < 3; i++)
 					it87_write_value(data,
-							 IT87_REG_PWM[i],
+							 data->REG_PWM[i],
 							 0x7f & ~pwm[i]);
 				return 1;
 			}
@@ -3379,8 +4114,11 @@
 	data->smbus_bitmap = sio_data->smbus_bitmap;
 	data->ec_special_config = sio_data->ec_special_config;
 	data->features = it87_devices[sio_data->type].features;
+	data->num_temp_limit = it87_devices[sio_data->type].num_temp_limit;
 	data->peci_mask = it87_devices[sio_data->type].peci_mask;
 	data->old_peci_mask = it87_devices[sio_data->type].old_peci_mask;
+	data->bank = 0xff;
+
 	/*
 	 * IT8705F Datasheet 0.4.1, 3h == Version G.
 	 * IT8712F Datasheet 0.9.1, section 8.3.5 indicates 8h == Version J.
@@ -3419,6 +4157,9 @@
 		return -ENODEV;
 	}
 
+	/* Initialize register pointers */
+	it87_init_regs(pdev);
+
 	/* Check PWM configuration */
 	enable_pwm_interface = it87_check_pwm(dev);
 	if (!enable_pwm_interface)
@@ -3511,7 +4252,7 @@
 	return PTR_ERR_OR_ZERO(hwmon_dev);
 }
 
-static void it87_resume_sio(struct platform_device *pdev)
+static void __maybe_unused it87_resume_sio(struct platform_device *pdev)
 {
 	struct it87_data *data = dev_get_drvdata(&pdev->dev);
 	int err;
@@ -3543,7 +4284,7 @@
 	superio_exit(data->sioaddr, has_conf_noexit(data));
 }
 
-static int it87_resume(struct device *dev)
+static int __maybe_unused it87_resume(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
 	struct it87_data *data = dev_get_drvdata(dev);
@@ -3561,7 +4302,7 @@
 	it87_start_monitoring(data);
 
 	/* force update */
-	data->valid = false;
+	data->valid = 0;
 
 	it87_unlock(data);
 
@@ -3744,6 +4485,9 @@
 		if (i && isa_address[i] == isa_address[0])
 			break;
 
+		if (dmi_data)
+			sio_data.skip_pwm |= dmi_data->skip_pwm;
+
 		err = it87_device_add(i, isa_address[i], &sio_data);
 		if (err)
 			goto exit_dev_unregister;
diff -ruN a/drivers/hwmon/pmbus/pmbus.c b/drivers/hwmon/pmbus/pmbus.c
--- a/drivers/hwmon/pmbus/pmbus.c	2024-05-07 14:48:24.916441223 +0800
+++ b/drivers/hwmon/pmbus/pmbus.c	2024-05-07 15:46:53.855848812 +0800
@@ -258,6 +258,13 @@
 
 module_i2c_driver(pmbus_driver);
 
+/* Work-around for preventing PSUs not supporting PAGE command. */
+void __pmbus_set_id_table(const struct i2c_device_id *id_table)
+{
+	pmbus_driver.id_table = id_table;
+}
+EXPORT_SYMBOL_GPL(__pmbus_set_id_table);
+
 MODULE_AUTHOR("Guenter Roeck");
 MODULE_DESCRIPTION("Generic PMBus driver");
 MODULE_LICENSE("GPL");
diff -ruN a/drivers/hwmon/pmbus/pmbus_core.c b/drivers/hwmon/pmbus/pmbus_core.c
--- a/drivers/hwmon/pmbus/pmbus_core.c	2024-05-07 14:48:24.916441223 +0800
+++ b/drivers/hwmon/pmbus/pmbus_core.c	2024-05-07 15:46:53.855848812 +0800
@@ -21,6 +21,7 @@
 #include <linux/regulator/machine.h>
 #include <linux/of.h>
 #include <linux/thermal.h>
+#include <linux/delay.h>
 #include "pmbus.h"
 
 /*
@@ -519,9 +520,18 @@
 }
 EXPORT_SYMBOL_NS_GPL(pmbus_get_fan_rate_cached, PMBUS);
 
+static int pmbus_check_status_cml(struct i2c_client *client);
+
 static void pmbus_clear_fault_page(struct i2c_client *client, int page)
 {
 	_pmbus_write_byte(client, page, PMBUS_CLEAR_FAULTS);
+
+	/* Prevent receive-byte from immediately following.
+	 * CLEAR_FAULTS is write-only.
+	 * ACBEL PSU's bug fatally kills SMBus if i2cdetect follows this.
+	 */
+	msleep(10);
+	pmbus_check_status_cml(client);
 }
 
 void pmbus_clear_faults(struct i2c_client *client)
@@ -548,6 +558,20 @@
 	return 0;
 }
 
+/* Work-around for PSUs that never clear unsupported command error.
+ * Filters checking of register support.
+ */
+static const u8 *supported_regs = NULL;
+
+const u8 *__pmbus_set_supported_regs(const u8 *regs)
+{
+	const u8 *p = supported_regs;
+
+	supported_regs = regs;
+	return p;
+}
+EXPORT_SYMBOL_NS_GPL(__pmbus_set_supported_regs, PMBUS);
+
 static bool pmbus_check_register(struct i2c_client *client,
 				 int (*func)(struct i2c_client *client,
 					     int page, int reg),
@@ -556,6 +580,16 @@
 	int rv;
 	struct pmbus_data *data = i2c_get_clientdata(client);
 
+	if (supported_regs) {
+		const u8 *p;
+
+		for (p = supported_regs; *p; p++)
+			if (reg == *p)
+				break;
+		if (!*p)
+			return false;
+	}
+
 	rv = func(client, page, reg);
 	if (rv >= 0 && !(data->flags & PMBUS_SKIP_STATUS_CHECK))
 		rv = pmbus_check_status_cml(client);
@@ -3646,6 +3680,14 @@
 }
 EXPORT_SYMBOL_NS_GPL(pmbus_do_probe, PMBUS);
 
+int pmbus_num_attributes(struct i2c_client *client)
+{
+	struct pmbus_data *data = i2c_get_clientdata(client);
+
+	return data ? data->num_attributes : 0;
+}
+EXPORT_SYMBOL_NS_GPL(pmbus_num_attributes, PMBUS);
+
 struct dentry *pmbus_get_debugfs_dir(struct i2c_client *client)
 {
 	struct pmbus_data *data = i2c_get_clientdata(client);
diff -ruN a/drivers/hwmon/w83627ehf.c b/drivers/hwmon/w83627ehf.c
--- a/drivers/hwmon/w83627ehf.c	2024-05-07 14:48:24.926441280 +0800
+++ b/drivers/hwmon/w83627ehf.c	2024-05-07 15:46:53.855848812 +0800
@@ -934,6 +934,53 @@
 	return count;
 }
 
+static ssize_t
+show_fan_target(struct device *dev, struct device_attribute *attr,
+			char *buf)
+{
+	struct w83627ehf_data *data = w83627ehf_update_device(dev);
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	int target = fan_from_reg8(data->target_temp[nr], data->fan_div[nr]);
+	return sprintf(buf, "%d\n", target);
+}
+
+static ssize_t
+store_fan_target(struct device *dev, struct device_attribute *attr,
+			const char *buf, size_t count)
+{
+	struct w83627ehf_data *data = dev_get_drvdata(dev);
+	struct sensor_device_attribute *sensor_attr = to_sensor_dev_attr(attr);
+	int nr = sensor_attr->index;
+	long val, low, tolerance;
+	u16 reg;
+	int err;
+
+	err = kstrtol(buf, 10, &val);
+	if (err < 0)
+		return err;
+
+	/* Hard-code tolerance to ~100 RPM */
+	low = clamp_val(fan_from_reg8(val * 9 / 10, data->fan_div[nr]), 0, 255);
+	val = clamp_val(fan_from_reg8(val, data->fan_div[nr]), 0, 255);
+	tolerance = low - val;
+
+	mutex_lock(&data->update_lock);
+	data->target_temp[nr] = val;
+	w83627ehf_write_value(data, W83627EHF_REG_TARGET[nr], val);
+
+	reg = w83627ehf_read_value(data, W83627EHF_REG_TOLERANCE[nr]);
+	if (nr == 1)
+		reg = (reg & 0x0f) | (tolerance << 4);
+	else
+		reg = (reg & 0xf0) | tolerance;
+	w83627ehf_write_value(data, W83627EHF_REG_TOLERANCE[nr], reg);
+	data->tolerance[nr] = tolerance;
+
+	mutex_unlock(&data->update_lock);
+	return count;
+}
+
 static SENSOR_DEVICE_ATTR(pwm1_target, 0644, show_target_temp,
 	    store_target_temp, 0);
 static SENSOR_DEVICE_ATTR(pwm2_target, 0644, show_target_temp,
@@ -952,6 +999,15 @@
 static SENSOR_DEVICE_ATTR(pwm4_tolerance, 0644, show_tolerance,
 	    store_tolerance, 3);
 
+static SENSOR_DEVICE_ATTR(fan1_target, 0644, show_fan_target,
+	    store_fan_target, 0);
+static SENSOR_DEVICE_ATTR(fan2_target, 0644, show_fan_target,
+	    store_fan_target, 1);
+static SENSOR_DEVICE_ATTR(fan3_target, 0644, show_fan_target,
+	    store_fan_target, 2);
+static SENSOR_DEVICE_ATTR(fan4_target, 0644, show_fan_target,
+	    store_fan_target, 3);
+
 /* Smart Fan registers */
 
 #define fan_functions(reg, REG) \
@@ -1195,6 +1251,11 @@
 	&sensor_dev_attr_pwm4_target.dev_attr.attr,
 	&sensor_dev_attr_pwm4_tolerance.dev_attr.attr,
 
+	&sensor_dev_attr_fan1_target.dev_attr.attr,
+	&sensor_dev_attr_fan2_target.dev_attr.attr,
+	&sensor_dev_attr_fan3_target.dev_attr.attr,
+	&sensor_dev_attr_fan4_target.dev_attr.attr,
+
 	&dev_attr_cpu0_vid.attr,
 	NULL
 };
@@ -1272,6 +1333,17 @@
 		else
 			data->temp_type[i] = 4; /* thermistor */
 	}
+
+	/* NETGEAR: If we're going to CPU Thermal Cruise Control mode, we need to make sure
+	 * the CPUFANOUT0_MIN_Value register bit is set so the fan doesn't stop */
+	if (kind == w83627dhg) {
+		u16 reg = w83627ehf_read_value(data, W83627EHF_REG_PWM_ENABLE[2]);
+		if (!(reg & 0x10)) {
+			pr_info("Enabling min RPM for CPU Fan Thermal Cruise Control mode\n");
+			reg |= 0x10;
+			w83627ehf_write_value(data, W83627EHF_REG_PWM_ENABLE[2], reg);
+		}
+	}
 }
 
 static void
diff -ruN a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c
--- a/drivers/i2c/busses/i2c-i801.c	2024-05-07 14:48:25.016441815 +0800
+++ b/drivers/i2c/busses/i2c-i801.c	2024-05-07 15:46:53.855848812 +0800
@@ -335,10 +335,37 @@
 static int i801_check_pre(struct i801_priv *priv)
 {
 	int status;
+	static u8 count;
 
 	status = inb_p(SMBHSTSTS(priv));
 	if (status & SMBHSTSTS_HOST_BUSY) {
-		pci_err(priv->pci_dev, "SMBus is busy, can't use it!\n");
+		count = 0;
+#define HCFG_SSRESET	0x8
+		if (++count >= 4) {
+			u8 hostc, i = 255;
+
+			pci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);
+			pci_write_config_byte(priv->pci_dev, SMBHSTCFG,
+					      hostc | HCFG_SSRESET);
+
+			dev_err(&priv->pci_dev->dev,
+		"SMBus is still busy. SSRESET is in place to reset chip.\n");
+
+			while (i-- > 0) {
+				mdelay(1);
+				pci_read_config_byte(priv->pci_dev, SMBHSTCFG, &hostc);
+				if (!(hostc & HCFG_SSRESET))
+					break;
+			}
+			if (!i)
+				dev_err(&priv->pci_dev->dev, "SSRESET timed out\n");
+			count = 0;
+		} else if (count >= 2) {
+			if (count == 2)
+				dev_err(&priv->pci_dev->dev,
+		"SMBus is busy. Trying to release it by resetting HBSY.\n");
+			outb_p(SMBHSTSTS_HOST_BUSY, SMBHSTSTS(priv));
+		}
 		return -EBUSY;
 	}
 
@@ -868,6 +895,12 @@
 	return result;
 }
 
+#if IS_ENABLED(CONFIG_INPUT_SX8635)
+extern bool readynas_ignore_i801_acpi_conflict(struct i2c_adapter *);
+#else
+#define readynas_ignore_i801_acpi_conflict(adap)	false
+#endif
+
 /* Return negative errno on error. */
 static s32 i801_access(struct i2c_adapter *adap, u16 addr,
 		       unsigned short flags, char read_write, u8 command,
@@ -877,7 +910,7 @@
 	struct i801_priv *priv = i2c_get_adapdata(adap);
 
 	mutex_lock(&priv->acpi_lock);
-	if (priv->acpi_reserved) {
+	if (priv->acpi_reserved && !readynas_ignore_i801_acpi_conflict(adap)) {
 		mutex_unlock(&priv->acpi_lock);
 		return -EBUSY;
 	}
diff -ruN a/drivers/i2c/busses/i2c-nct6775.c b/drivers/i2c/busses/i2c-nct6775.c
--- a/drivers/i2c/busses/i2c-nct6775.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/i2c/busses/i2c-nct6775.c	2024-05-07 15:46:53.855848812 +0800
@@ -0,0 +1,311 @@
+/*
+ * i2c_nct6775 - Driver for SMBUS module of Nuvitin NCT677x Super-I/O chips
+ *
+ * Copyright (c) 2016 Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * Distribution for free use under GNU General Public Licemse.
+ */
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c.h>
+
+#define NCT6775_REG(p, off)	((p)->smba + I2C_NCT6775_##off)
+#define I2C_NCT6775_DATA	0
+#define I2C_NCT6775_WRSIZE	1
+#define I2C_NCT6775_CMD		2
+#define I2C_NCT6775_IDX		3
+#define I2C_NCT6775_CTL		4
+#define I2C_NCT6775_ADDR	5
+#define I2C_NCT6775_FREQ	6
+#define I2C_NCT6775_ERR_STATUS	6
+#define I2C_NCT6775_CTL3	0xe
+
+#define NCT6775_CTL3_F_EMPT	(1 << 0)
+#define NCT6775_CTL3_F_FULL	(1 << 1)
+#define NCT6775_CTL3_CRC_CHK	(1 << 3)
+
+#define NCT6775_READ_BYTE	0x00
+#define NCT6775_READ_WORD	0x01
+#define NCT6775_READ_BLOCK	0x02
+#define NCT6775_WRITE_BYTE	0x08
+#define NCT6775_WRITE_WORD	0x09
+#define NCT6775_WRITE_BLOCK	0x0a
+
+#define NCT6775_CTL_BYTE_EN	0x02
+#define NCT6775_CTL_CRC8_EN	0x20
+#define NCT6775_CTL_S_RST	0x40
+#define NCT6775_CTL_MMODE_S	0x80
+
+#define NCT6775_CLK_365K	0x0
+#define NCT6775_CLK_261K	0x1
+#define NCT6775_CLK_200K	0x2
+#define NCT6775_CLK_162K	0x3
+#define NCT6775_CLK_136K	0x4
+#define NCT6775_CLK_117K	0x5
+#define NCT6775_CLK_103K	0x6
+#define NCT6775_CLK_92K		0x7
+#define NCT6775_CLK_83K		0x8
+#define NCT6775_CLK_76K		0x9
+#define NCT6775_CLK_71K		0xa
+#define NCT6775_CLK_65K		0xb
+#define NCT6775_CLK_61K		0xc
+#define NCT6775_CLK_57K		0xd
+#define NCT6775_CLK_53K		0xe
+#define NCT6775_CLK_47K		0xf
+
+#define NCT6775_STATUS_ADNACK	(1<<5)
+#define NCT6775_STATUS_TIMEOUT	(1<<4)
+#define NCT6775_STATUS_BERR	(1<<2)
+#define NCT6775_STATUS_NACK	(1<<1)
+
+static struct i2c_nct6775_priv {
+	u16 smba;
+	struct i2c_adapter	adapter;
+} *i2c_nct6775_priv;
+
+static inline int wait_for_room(struct i2c_nct6775_priv *priv)
+{
+	int i;
+	u8 ctl3;
+
+	for (i = 0; i < 1000; i++) {
+		ctl3 = inb(NCT6775_REG(priv, CTL3));
+		if (!(ctl3 & NCT6775_CTL3_F_FULL))
+			break;
+		usleep_range(100, 200);
+	}
+	return (ctl3 & NCT6775_CTL3_F_EMPT) ? -ETIMEDOUT : 0;
+}
+
+static inline int fifo_empty(struct i2c_nct6775_priv *priv)
+{
+	return inb(NCT6775_REG(priv, CTL3)) & NCT6775_CTL3_F_EMPT;
+}
+
+static inline int flush_fifo(struct i2c_nct6775_priv *priv)
+{
+	int i;
+
+	for (i = 0; i < 32 && !fifo_empty(priv); i++)
+		inb(NCT6775_REG(priv, DATA));
+	return fifo_empty(priv) ? 0 : -ETIMEDOUT;
+}
+
+static inline int wait_for_data(struct i2c_nct6775_priv *priv, u16 flags)
+{
+	int i;
+	u8 ctl3;
+
+	for (i = 0; i < 1000; i++) {
+		ctl3 = inb(NCT6775_REG(priv, CTL3));
+		if (!(ctl3 & NCT6775_CTL3_F_EMPT))
+			break;
+		usleep_range(100, 200);
+	}
+	if ((ctl3 & NCT6775_CTL3_F_EMPT))
+		return -ETIMEDOUT;
+	if ((flags & I2C_CLIENT_PEC) && !(ctl3 & NCT6775_CTL3_CRC_CHK))
+		return -EIO;
+	return 0;
+}
+
+static s32 i2c_nct6775_xfer(struct i2c_adapter *adap, u16 addr,
+			unsigned short flags, char read_write, u8 command,
+			int size, union i2c_smbus_data *data)
+{
+	u8 op, ctl = NCT6775_CTL_MMODE_S;
+	int err = 0;
+	bool send_command = true;
+	size_t len = 1;
+	struct i2c_nct6775_priv *priv = i2c_get_adapdata(adap);
+
+	if (flags & I2C_CLIENT_PEC)
+		ctl |= NCT6775_CTL_CRC8_EN;
+
+	switch (size) {
+	case I2C_SMBUS_BYTE:
+		ctl |= NCT6775_CTL_BYTE_EN;
+		send_command = (read_write == I2C_SMBUS_WRITE);
+		len = 0;
+		/* Fall through */
+	case I2C_SMBUS_BYTE_DATA:
+		op = (read_write == I2C_SMBUS_WRITE)	? NCT6775_WRITE_BYTE
+							: NCT6775_READ_BYTE;
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		len = 2;
+		op = (read_write == I2C_SMBUS_WRITE)	? NCT6775_WRITE_WORD
+							: NCT6775_READ_WORD;
+		break;
+	case I2C_SMBUS_BLOCK_DATA:
+		len = data->block[0];
+		op = (read_write == I2C_SMBUS_WRITE)	? NCT6775_WRITE_BLOCK
+							: NCT6775_READ_BLOCK;
+		break;
+	default:
+		pr_err("%s: unexpected transfer type: %d\n", __func__, size);
+	case I2C_SMBUS_QUICK:	/* Return error even if claimed "supported" */
+		return -EOPNOTSUPP;
+	}
+
+	if ((err = flush_fifo(priv))) {
+		pr_err("%s: FIFO busy.\n",__func__);
+		return err;
+	}
+
+	outb((addr << 1) | ((read_write == I2C_SMBUS_WRITE) ? 0 : 0x01),
+						NCT6775_REG(priv, ADDR));
+	outb(op, NCT6775_REG(priv, CMD));
+
+	if (read_write == I2C_SMBUS_WRITE) {
+		unsigned int i = 1;
+
+		if (len > 0)
+			outb(len, NCT6775_REG(priv, WRSIZE));
+
+		if (send_command)
+			outb(command, NCT6775_REG(priv, IDX));
+
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			outb(data->byte, NCT6775_REG(priv, DATA));
+			/* Fall through. */
+		case I2C_SMBUS_BYTE:
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			outw(data->word, NCT6775_REG(priv, DATA));
+			break;
+		case I2C_SMBUS_BLOCK_DATA:
+			outb(data->block[0], NCT6775_REG(priv, DATA));
+			while (i < len) {
+				if ((err = wait_for_room(priv)))
+					return err;
+				outb(data->block[i++], NCT6775_REG(priv, DATA));
+			}
+			break;
+		}
+		outb(ctl, NCT6775_REG(priv, CTL));
+		flush_fifo(priv);
+	} else {
+		unsigned int i = 0;
+
+		if (send_command)
+			outb(command, NCT6775_REG(priv, IDX));
+		outb(ctl, NCT6775_REG(priv, CTL));
+		if ((err = wait_for_data(priv, flags))) {
+			pr_err("%s: data timed out addr:%x cmd:%x\n",
+				__func__, addr, command);
+			return err;
+		}
+		data->word = 0;
+		switch (size) {
+		case I2C_SMBUS_BYTE:
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = inb(NCT6775_REG(priv, DATA));
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = inb(NCT6775_REG(priv, DATA));
+			if ((err = wait_for_data(priv, flags))) {
+				pr_err("%s: word data timed out "
+				"addr:%x cmd:%x\n", __func__, addr, command);
+				return err;
+			}
+			data->word |= inb(NCT6775_REG(priv, DATA)) << 8;
+			break;
+		case I2C_SMBUS_BLOCK_DATA:
+			len = inb(NCT6775_REG(priv, DATA));
+			if (len >= 32) {
+				err = -EIO;
+				break;
+			}
+			data->block[i++] = len;
+			while (i < len && !(err = wait_for_data(priv, flags)))
+				data->block[i++] = inb(NCT6775_REG(priv, DATA));
+			if (err)
+				pr_err("%s: block data timed out "
+				"addr:%x cmd:%x\n", __func__, addr, command);
+			break;
+		}
+	}
+
+	usleep_range(1000, 2000);
+	return err;
+}
+
+/**
+ * Backdoor accesses for RNx220 PMBus
+ */
+void __i2c_nct6775_reset(struct i2c_adapter *adapter)
+{
+	struct i2c_nct6775_priv *priv = i2c_get_adapdata(adapter);
+
+	i2c_lock_bus(adapter, I2C_LOCK_ROOT_ADAPTER);
+	outb(NCT6775_CTL_S_RST, NCT6775_REG(priv, CTL));
+	msleep(300);
+	i2c_unlock_bus(adapter, I2C_LOCK_ROOT_ADAPTER);
+}
+
+static u32 i2c_nct6775_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_BYTE |
+		I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_BLOCK_DATA |
+		I2C_FUNC_SMBUS_PEC |
+		I2C_FUNC_SMBUS_QUICK;
+}
+
+static const struct i2c_algorithm i2c_nct6775_algorithm = {
+	.smbus_xfer	= i2c_nct6775_xfer,
+	.functionality	= i2c_nct6775_func,
+};
+
+static const char *chips[] = {"NCT6775", "NCT6776", "NCT6779", NULL};
+int __init __i2c_nct6775_init(u16 ba, const char *name)
+{
+	int err, i;
+
+	for (i = 0; chips[i]; i++)
+		if (strstr(name, chips[i]) == name)
+			break;
+	if (!chips[i]) {
+		pr_err("%s: LPC chip has no I2C master support.\n", __func__);
+		return 0;
+	}
+
+	pr_info("%s: initializing %s SMBus\n", __func__, name);
+	if (!(i2c_nct6775_priv = kzalloc(sizeof *i2c_nct6775_priv, GFP_KERNEL)))
+		return -ENOMEM;
+
+	i2c_set_adapdata(&i2c_nct6775_priv->adapter, i2c_nct6775_priv);
+	i2c_nct6775_priv->adapter.owner	= THIS_MODULE;
+	i2c_nct6775_priv->adapter.class	= I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	i2c_nct6775_priv->adapter.algo	= &i2c_nct6775_algorithm;
+	i2c_nct6775_priv->adapter.timeout	= HZ/5;
+	i2c_nct6775_priv->adapter.retries	= 3;
+	i2c_nct6775_priv->smba = ba;
+
+	outb(NCT6775_CLK_92K, NCT6775_REG(i2c_nct6775_priv, FREQ));
+
+        snprintf(i2c_nct6775_priv->adapter.name,
+		sizeof i2c_nct6775_priv->adapter.name,
+		"SMBus %s adapter at %04x", name, i2c_nct6775_priv->smba);
+
+	err = i2c_add_adapter(&i2c_nct6775_priv->adapter);
+	if (err) {
+		kfree(i2c_nct6775_priv);
+		i2c_nct6775_priv = NULL;
+		return err;
+	}
+
+	return err;
+}
+
+void __exit __i2c_nct6775_exit(void)
+{
+	i2c_del_adapter(&i2c_nct6775_priv->adapter);
+	kfree(i2c_nct6775_priv);
+	i2c_nct6775_priv = NULL;
+}
diff -ruN a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
--- a/drivers/i2c/busses/Kconfig	2024-05-07 14:48:25.016441815 +0800
+++ b/drivers/i2c/busses/Kconfig	2024-05-07 15:46:53.855848812 +0800
@@ -1346,6 +1346,13 @@
 	  River Tech's viperboard.h for detailed meaning
 	  of the module parameters.
 
+config I2C_NCT6775
+	bool "NCT677x I2C/SMBus driver"
+	depends on SENSORS_NCT6775
+	help
+	  Adds I2C/SMBus master driver feature to Nuvoton NCT677x LPC I/O.
+	  NCT6775 NCT6776D/F NCT6779D
+
 comment "Other I2C/SMBus bus drivers"
 
 config I2C_ACORN
diff -ruN a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
--- a/drivers/i2c/busses/Makefile	2024-05-07 14:48:25.016441815 +0800
+++ b/drivers/i2c/busses/Makefile	2024-05-07 15:46:53.855848812 +0800
@@ -29,6 +29,7 @@
 obj-$(CONFIG_I2C_SIS96X)	+= i2c-sis96x.o
 obj-$(CONFIG_I2C_VIA)		+= i2c-via.o
 obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
+obj-$(CONFIG_I2C_NCT6775)	+= i2c-nct6775.o
 
 # Mac SMBus host controller drivers
 obj-$(CONFIG_I2C_HYDRA)		+= i2c-hydra.o
diff -ruN a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
--- a/drivers/input/misc/Kconfig	2024-05-07 14:48:25.526444850 +0800
+++ b/drivers/input/misc/Kconfig	2024-05-07 15:46:53.855848812 +0800
@@ -13,6 +13,8 @@
 
 if INPUT_MISC
 
+source "drivers/input/misc/smtc/Kconfig"
+
 config INPUT_88PM860X_ONKEY
 	tristate "88PM860x ONKEY support"
 	depends on MFD_88PM860X
diff -ruN a/drivers/input/misc/smtc/Kconfig b/drivers/input/misc/smtc/Kconfig
--- a/drivers/input/misc/smtc/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/input/misc/smtc/Kconfig	2024-05-07 15:46:53.855848812 +0800
@@ -0,0 +1,17 @@
+#
+# Input misc drivers configuration for SX8636
+#
+#	depends on I2C && I2C_I801
+menu "Semtech Capacitive Touch Sensors"
+
+config INPUT_SX8635
+	tristate "Semtech SX8635"
+	depends on I2C_I801
+	help
+	  Say Y here if you want to use the SX8635 for Capacitive Buttons/Wheel.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called sx8635.
+
+
+endmenu
diff -ruN a/drivers/md/md.c b/drivers/md/md.c
--- a/drivers/md/md.c	2024-05-07 14:48:25.886446990 +0800
+++ b/drivers/md/md.c	2024-05-07 15:46:53.855848812 +0800
@@ -9113,10 +9113,12 @@
 			/((jiffies-mddev->resync_mark)/HZ +1) +1;
 
 		if (currspeed > speed_min(mddev)) {
-			if (currspeed > speed_max(mddev)) {
+			if ((currspeed > speed_max(mddev)) ||
+					!is_mddev_idle(mddev, 0)) {
 				msleep(500);
 				goto repeat;
 			}
+#if 0
 			if (!is_mddev_idle(mddev, 0)) {
 				/*
 				 * Give other IO more of a chance.
@@ -9125,6 +9127,7 @@
 				wait_event(mddev->recovery_wait,
 					   !atomic_read(&mddev->recovery_active));
 			}
+#endif
 		}
 	}
 	pr_info("md: %s: %s %s.\n",mdname(mddev), desc,
diff -ruN a/drivers/md/raid5.c b/drivers/md/raid5.c
--- a/drivers/md/raid5.c	2024-05-07 14:48:25.886446990 +0800
+++ b/drivers/md/raid5.c	2024-05-07 15:46:53.865848872 +0800
@@ -7269,6 +7269,45 @@
 				raid5_show_group_thread_cnt,
 				raid5_store_group_thread_cnt);
 
+static ssize_t
+stripe_cache_invalidate(struct mddev *mddev, const char *page, size_t len)
+{
+	long long unsigned pos;
+	sector_t sector;
+	struct stripe_head *sh;
+	struct r5conf *conf = mddev->private;
+
+	if (kstrtoull(page, 10, &pos))
+		return -EINVAL;
+	sector = pos >> 9;
+
+	spin_lock_irq(&conf->device_lock);
+	sh = __find_stripe(conf, sector, 0);
+	if (sh) {
+		if (test_bit(STRIPE_HANDLE, &sh->state))
+			sh = (struct stripe_head *)-1;
+		else
+			list_del(&sh->lru);
+	}
+	spin_unlock_irq(&conf->device_lock);
+
+	if (sh == (struct stripe_head *)-1)
+		return -EBUSY;
+	else if (sh) {
+		remove_hash(sh);
+		BUG_ON(atomic_read(&sh->count));
+		shrink_buffers(sh);
+		kmem_cache_free(conf->slab_cache, sh);
+	}
+	return len;
+}
+
+static struct md_sysfs_entry
+raid5_stripecache_invalidate = __ATTR(stripe_cache_invalidate,
+					S_IWUSR,
+					NULL,
+					stripe_cache_invalidate);
+
 static struct attribute *raid5_attrs[] =  {
 	&raid5_stripecache_size.attr,
 	&raid5_stripecache_active.attr,
@@ -7279,6 +7318,7 @@
 	&raid5_stripe_size.attr,
 	&r5c_journal_mode.attr,
 	&ppl_write_hint.attr,
+	&raid5_stripecache_invalidate.attr,
 	NULL,
 };
 static const struct attribute_group raid5_attrs_group = {
diff -ruN a/drivers/mfd/lpc_ich.c b/drivers/mfd/lpc_ich.c
--- a/drivers/mfd/lpc_ich.c	2024-05-07 14:48:26.896452994 +0800
+++ b/drivers/mfd/lpc_ich.c	2024-05-07 15:46:53.865848872 +0800
@@ -569,7 +569,7 @@
 	[LPC_LPT] = {
 		.name = "Lynx Point",
 		.iTCO_version = 2,
-		.gpio_version = ICH_V5_GPIO,
+		.gpio_version = LPT_GPIO,
 		.spi_type = INTEL_SPI_LPT,
 	},
 	[LPC_LPT_LP] = {
@@ -992,7 +992,7 @@
 	if (!acpi_check_region(res->start + 0x30, 0x10, "LPC ICH GPIO2"))
 		use_gpio |= 1 << 1;
 
-	ret = acpi_check_region(res->start + 0x00, 0x30, "LPC ICH GPIO1");
+	ret = acpi_check_region(res->start + 0x00, 0x10, "LPC ICH GPIO1");
 	if (!ret)
 		use_gpio |= 1 << 0;
 
@@ -1051,6 +1051,9 @@
 	case ICH_V10CORP_GPIO:
 		res->end = res->start + 128 - 1;
 		break;
+	case LPT_GPIO:
+		res->end = res->start + 0x50 - 1;
+		break;
 	default:
 		res->end = res->start + 64 - 1;
 		break;
@@ -1060,9 +1063,12 @@
 	if (ret < 0) {
 		/* this isn't necessarily fatal for the GPIO */
 		acpi_conflict = true;
+#if 0	/* Not fatal - keep GPIO alive. */
 		goto gpio_done;
+#endif
 	}
 	lpc_chipset_info[priv->chipset].use_gpio = ret;
+	lpc_chipset_info[priv->chipset].pci_dev = dev;
 	lpc_ich_enable_gpio_space(dev);
 
 	lpc_ich_finalize_gpio_cell(dev);
diff -ruN a/drivers/mtd/mtdchar.c b/drivers/mtd/mtdchar.c
--- a/drivers/mtd/mtdchar.c	2024-05-07 14:48:27.126454362 +0800
+++ b/drivers/mtd/mtdchar.c	2024-05-07 15:46:53.865848872 +0800
@@ -1205,6 +1205,19 @@
 		break;
 	}
 
+	case BLKROSET:
+	{
+		unsigned long ro;
+
+		if (copy_from_user(&ro, argp, sizeof(ro)))
+			return -EFAULT;
+		if (ro)
+			mtd->flags &= ~MTD_WRITEABLE;
+		else
+			mtd->flags |= MTD_WRITEABLE;
+		break;
+	}
+
 	case BLKPG:
 	{
 		struct blkpg_ioctl_arg __user *blk_arg = argp;
diff -ruN a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c
--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2024-05-07 14:48:27.836458586 +0800
+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c	2024-05-07 15:46:53.865848872 +0800
@@ -10697,8 +10697,8 @@
 
 	/* check eeprom to see if WOL is enabled for X540 and newer */
 	if (hw->mac.type >= ixgbe_mac_X540) {
-		if ((wol_cap == IXGBE_DEVICE_CAPS_WOL_PORT0_1) ||
-		    ((wol_cap == IXGBE_DEVICE_CAPS_WOL_PORT0) &&
+		if ((wol_cap & IXGBE_DEVICE_CAPS_WOL_PORT0_1) ||
+		    ((wol_cap & IXGBE_DEVICE_CAPS_WOL_PORT0) &&
 		     (hw->bus.func == 0)))
 			return true;
 	}
diff -ruN a/drivers/platform/Kconfig b/drivers/platform/Kconfig
--- a/drivers/platform/Kconfig	2024-05-07 14:48:29.926471012 +0800
+++ b/drivers/platform/Kconfig	2024-05-07 15:46:53.865848872 +0800
@@ -14,3 +14,5 @@
 source "drivers/platform/surface/Kconfig"
 
 source "drivers/platform/x86/Kconfig"
+
+source "drivers/platform/readynas/Kconfig"
diff -ruN a/drivers/platform/Makefile b/drivers/platform/Makefile
--- a/drivers/platform/Makefile	2024-05-07 14:48:29.926471012 +0800
+++ b/drivers/platform/Makefile	2024-05-07 15:46:53.865848872 +0800
@@ -11,3 +11,4 @@
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
 obj-$(CONFIG_SURFACE_PLATFORMS)	+= surface/
+obj-$(CONFIG_READYNAS_PLATFORMS)	+= readynas/
diff -ruN a/drivers/platform/readynas/hd44780-lcd.c b/drivers/platform/readynas/hd44780-lcd.c
--- a/drivers/platform/readynas/hd44780-lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/hd44780-lcd.c	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,626 @@
+/*
+ * hd44780-lcd.c
+ *
+ * LCD alpha numeric display driver for Hitach HD44780 driven by GPIO
+ *
+ * Copyright (c)2015 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ */
+
+#include "hd44780-lcd.h"
+#include <../drivers/gpio/gpiolib.h>
+
+static bool lcd_backlight_state(struct hd44780_lcd *gl)
+{
+	return !!gl->get_value(gl->lcm_bl);
+}
+
+static void pin_write(struct hd44780_lcd *gl, struct gpio_desc *pin, int value)
+{
+	gl->set_value(pin, value);
+	udelay(1);
+}
+
+static unsigned char lcm_read4(struct hd44780_lcd *gl)
+{
+	unsigned char c = 0;
+
+	c  =  gl->get_value(gl->lcm_data[7]) ? (1 << 7) : 0;
+	c |= (gl->get_value(gl->lcm_data[6]) ? (1 << 6) : 0);
+	c |= (gl->get_value(gl->lcm_data[5]) ? (1 << 5) : 0);
+	c |= (gl->get_value(gl->lcm_data[4]) ? (1 << 4) : 0);
+
+	return c;
+}
+
+static unsigned char lcm_read8(struct hd44780_lcd *gl)
+{
+	unsigned char c = lcm_read4(gl);
+
+	c |=  gl->get_value(gl->lcm_data[3]) ? (1 << 3) : 0;
+	c |= (gl->get_value(gl->lcm_data[2]) ? (1 << 2) : 0);
+	c |= (gl->get_value(gl->lcm_data[1]) ? (1 << 1) : 0);
+	c |= (gl->get_value(gl->lcm_data[0]) ? (1 << 0) : 0);
+
+	return c;
+}
+
+static unsigned char lcm_read(struct hd44780_lcd *gl)
+{
+	unsigned char c;
+
+	pin_write(gl, gl->lcm_rw, 1);
+	pin_write(gl, gl->lcm_en, 1);
+	udelay(50);
+	c = (gl->lcm_data_4bit) ? lcm_read4(gl) : lcm_read8(gl);
+	pin_write(gl, gl->lcm_en, 0);
+
+	if (gl->lcm_data_4bit) {
+		c &= 0xf0;
+		pin_write(gl, gl->lcm_en, 1);
+		udelay(50);
+		c |= lcm_read4(gl) >> 4;
+		pin_write(gl, gl->lcm_en, 0);
+	}
+	udelay(50);
+	return c;
+}
+
+static void wait_busy(struct hd44780_lcd *gl)
+{
+	int try = 10;
+
+	pin_write(gl, gl->lcm_rs, 0);
+	while (try-- > 0) {
+		if (!(lcm_read(gl) & 0x80))
+			break;
+		mdelay(1);
+	}
+}
+
+static void lcm_write4(struct hd44780_lcd *gl, unsigned char c)
+{
+	gl->set_value(gl->lcm_data[7], !!(c & (1 << 7)));
+	gl->set_value(gl->lcm_data[6], !!(c & (1 << 6)));
+	gl->set_value(gl->lcm_data[5], !!(c & (1 << 5)));
+	gl->set_value(gl->lcm_data[4], !!(c & (1 << 4)));
+}
+
+static void lcm_write8(struct hd44780_lcd *gl, unsigned char c)
+{
+	lcm_write4(gl, c);
+	gl->set_value(gl->lcm_data[3], !!(c & (1 << 3)));
+	gl->set_value(gl->lcm_data[2], !!(c & (1 << 2)));
+	gl->set_value(gl->lcm_data[1], !!(c & (1 << 1)));
+	gl->set_value(gl->lcm_data[0], !!(c & (1 << 0)));
+}
+
+static void lcm_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	pin_write(gl, gl->lcm_rw, 0);
+	pin_write(gl, gl->lcm_en, 1);
+	if (gl->lcm_data_4bit)
+		lcm_write4(gl, c);
+	else
+		lcm_write8(gl, c);
+	udelay(50);
+	pin_write(gl, gl->lcm_en, 0);
+	udelay(50);
+	if (gl->lcm_data_4bit) {
+		pin_write(gl, gl->lcm_en, 1);
+		lcm_write4(gl, c << 4);
+		udelay(50);
+		pin_write(gl, gl->lcm_en, 0);
+		udelay(50);
+	}
+}
+
+static void lcd_data_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	wait_busy(gl);
+	pin_write(gl, gl->lcm_rs, 1);
+	lcm_write(gl, c);
+}
+
+static void command_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	wait_busy(gl);
+	pin_write(gl, gl->lcm_rs, 0);
+	lcm_write(gl, c);
+}
+
+static void lcd_sync_data_len(struct hd44780_lcd *gl)
+{
+	/* Regardless of current data length...*/
+	pin_write(gl, gl->lcm_rs, 0);
+	pin_write(gl, gl->lcm_rw, 0);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode again. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode again more. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	if (!gl->lcm_data_4bit)
+		return;
+	pin_write(gl, gl->lcm_en, 1);
+	lcm_write4(gl, 0x20);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+}
+
+static void lcd_entry_mode_set(struct hd44780_lcd *gl, int l2r, int scroll)
+{
+	command_write(gl, 0x04 | (l2r << 1) | scroll);
+}
+
+static void lcd_cursor_set(struct hd44780_lcd *gl, int row, int col)
+{
+	command_write(gl, 0x80 | (row << 6) | col);
+	udelay(53);
+}
+
+static void lcd_clear_display(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_clear_display);
+	mdelay(2);
+}
+
+static void lcd_return_home(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_return_home);
+	mdelay(2);
+}
+
+static void lcd_entry_mode_id(struct hd44780_lcd *gl, bool incr)
+{
+	gl->lcm_entry_mode &= ~0x02;
+	if (incr)
+		gl->lcm_entry_mode |= 0x02;
+	command_write(gl, gl->lcm_entry_mode);
+}
+
+static void lcd_entry_mode_shift(struct hd44780_lcd *gl, bool shift)
+{
+	gl->lcm_entry_mode &= ~0x01;
+	if (shift)
+		gl->lcm_entry_mode |= 0x01;
+	command_write(gl, gl->lcm_entry_mode);
+}
+
+static void lcd_entry_display_on(struct hd44780_lcd *gl, bool on)
+{
+	gl->lcm_display_control &= ~0x04;
+	if (on)
+		gl->lcm_display_control |= 0x04;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_display_cursor_on(struct hd44780_lcd *gl, bool on)
+{
+	gl->lcm_display_control &= ~0x02;
+	if (on)
+		gl->lcm_display_control |= 0x02;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_display_cursor_blink(struct hd44780_lcd *gl, bool blink)
+{
+	gl->lcm_display_control &= ~0x01;
+	if (blink)
+		gl->lcm_display_control |= 0x01;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_shift_display(struct hd44780_lcd *gl, bool right)
+{
+	gl->lcm_display_shift &= ~0x04;
+	gl->lcm_display_shift |= ~0x08;
+	if (right)
+		gl->lcm_display_shift |= 0x04;
+	command_write(gl, gl->lcm_display_shift);
+}
+
+static void lcd_shift_cursor(struct hd44780_lcd *gl, bool right)
+{
+	gl->lcm_display_shift &= ~0x0c;
+	if (right)
+		gl->lcm_display_shift |= 0x04;
+	command_write(gl, gl->lcm_display_shift);
+}
+
+static void lcd_function_8bit(struct hd44780_lcd *gl, bool _8bit)
+{
+	gl->lcm_function &= ~0x10;
+	if (_8bit)
+		gl->lcm_function |= 0x10;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_function_2line(struct hd44780_lcd *gl, bool _2line)
+{
+	gl->lcm_function &= ~0x08;
+	if (_2line)
+		gl->lcm_function |= 0x08;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_function_5x11(struct hd44780_lcd *gl, bool _5x11)
+{
+	gl->lcm_function &= ~0x04;
+	if (_5x11)
+		gl->lcm_function |= 0x04;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_set_cgram_address(struct hd44780_lcd *gl, unsigned char offset)
+{
+	gl->lcm_cgram_address &= ~0x1f;
+	if (offset)
+		gl->lcm_cgram_address |= (offset & 0x1f);
+	command_write(gl, gl->lcm_cgram_address);
+}
+
+static void lcd_set_cursor_pos(struct hd44780_lcd *gl,
+				unsigned char row, unsigned char col)
+{
+	if (gl->lcm_num_rows == 2) {
+		if (col > 0x27)
+			col = 0x27;
+	} else {
+		if (col > 0x4f)
+			col = 0x4f;
+		row = 0;
+	}
+	command_write(gl, 0x80 | (row << 6) | col);
+}
+
+static void lcd_backlight_on(struct hd44780_lcd *gl, bool on)
+{
+	pin_write(gl, gl->lcm_bl, on);
+	gl->backlight_status = on;
+}
+
+static void lcd_add_custom_character(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_cgram_address | (1 << 3)); /* slot 1 */
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+}
+
+static int lcd_init(struct hd44780_lcd *gl)
+{
+	lcd_sync_data_len(gl);
+
+	lcd_function_8bit(gl, !gl->lcm_data_4bit);
+	lcd_function_2line(gl, (gl->lcm_num_rows == 2));
+
+	lcd_clear_display(gl);
+	lcd_entry_mode_set(gl, 1, 0);
+	lcd_cursor_set(gl, 0, 0);	/* 1st line 1st col */
+	lcd_entry_display_on(gl, 1);	/* turn LCD on */
+	lcd_backlight_on(gl, 1);	/* turn backlight on */
+	lcd_add_custom_character(gl);	/* add half block custom character */
+
+	return 0;
+}
+
+static void lcd_exit(struct hd44780_lcd *gl)
+{
+}
+
+#ifndef CONFIG_OF_GPIO
+static int gpio_match_labels(struct gpio_chip *gc, void *data)
+{
+	return !strcmp(gc->label, (const char *)data);
+}
+
+static struct gpio_chip *gpiochip_find_by_label(const char *label)
+{
+	return gpiochip_find((void *)label, gpio_match_labels);
+}
+
+#define SETUP_GPIO(label, member)	\
+	{ label, offsetof(struct hd44780_lcd, member), true }
+#define SETUP_NON(label, member)	\
+	{ label, offsetof(struct hd44780_lcd, member), false }
+#define SETUP_GPIO2(name)	\
+	SETUP_GPIO("lcm-"#name, lcm_##name)
+static const struct {
+	const char *label;
+	const size_t offset;
+	const bool is_gpiod;
+} setup_item[] = {
+	SETUP_GPIO2(rs),
+	SETUP_GPIO2(rw),
+	SETUP_GPIO2(en),
+	SETUP_GPIO2(bl),
+	SETUP_NON("lcm-lines", lcm_num_rows),
+	SETUP_NON("lcm-cols", lcm_num_cols),
+	SETUP_NON("lcm-data-4bit", lcm_data_4bit),
+	SETUP_GPIO("lcm-bit0", lcm_data[0]),
+	SETUP_GPIO("lcm-bit1", lcm_data[1]),
+	SETUP_GPIO("lcm-bit2", lcm_data[2]),
+	SETUP_GPIO("lcm-bit3", lcm_data[3]),
+	SETUP_GPIO("lcm-bit4", lcm_data[4]),
+	SETUP_GPIO("lcm-bit5", lcm_data[5]),
+	SETUP_GPIO("lcm-bit6", lcm_data[6]),
+	SETUP_GPIO("lcm-bit7", lcm_data[7]),
+	{}
+};
+
+static int setup_gpiomap(struct hd44780_lcd *gl,
+				struct gpio_lcd_map const *setup)
+{
+	struct gpio_chip *gc;
+	int i = 0, err = 0;
+
+	gl->lcm_num_rows = 2;
+	gl->lcm_num_cols = 16;
+
+	if (!setup)
+		return -EINVAL;
+
+	gc = gpiochip_find_by_label(setup->gpio_label);
+	if (IS_ERR(gc))
+		err = PTR_ERR(gc);
+	else if (!gc)
+		err = -ENODEV;
+	if (err) {
+		pr_err("%s: cannot find LCD GPIO %s.\n",
+			__func__, setup->gpio_label);
+		return err;
+	}
+
+	while (setup->map[i].label) {
+		int j = 0;
+
+		while (setup_item[j].label) {
+			void *vp;
+
+			if (strcmp(setup_item[j].label, setup->map[i].label)) {
+				j++;
+				continue;
+			}
+
+			vp = (void *)gl + setup_item[j].offset;
+			if (setup_item[j].is_gpiod) {
+				struct gpio_desc *gd =
+					gpio_to_desc(setup->map[i].val +
+							gc->base);
+				if (setup->map[i].active_low)
+					set_bit(FLAG_ACTIVE_LOW, &gd->flags);
+				gpiod_direction_output(gd, 0);
+				*(struct gpio_desc **)vp = gd;
+			} else
+				*(unsigned int *)vp = setup->map[i].val;
+			break;
+		}
+		if (!setup_item[j].label)
+			return -EINVAL;
+		i++;
+	}
+
+	if (!gl->lcm_rs || !gl->lcm_rw || !gl->lcm_en || !gl->lcm_bl ||
+		!gl->lcm_data[7] || !gl->lcm_data[6] ||
+		!gl->lcm_data[5] || !gl->lcm_data[4])
+		return -EINVAL;
+	if (!gl->lcm_data_4bit &&
+		(!gl->lcm_data[3] || !gl->lcm_data[2] ||
+		!gl->lcm_data[1] || !gl->lcm_data[0]))
+		return -EINVAL;
+
+	if (gl->lcm_num_rows == 2)
+		gl->function_2line(gl, 1);
+
+	return 0;
+}
+
+static int gpio_lcd_match(struct device *dev, const void *data)
+{
+	struct gpio_lcd_map *map = dev_get_drvdata(dev);
+
+	return map ?
+		!strncmp(map->magic, (const char *)data, sizeof map->magic) : 0;
+}
+
+static struct gpio_lcd_map *find_gpio_lcd_map(void)
+{
+	struct device *dev = bus_find_device(&platform_bus_type, NULL,
+						GPIO_LCD_MAGIC, gpio_lcd_match);
+	return dev ? dev_get_drvdata(dev) : NULL;
+}
+#endif
+
+static int hd44780_lcd_probe(struct platform_device *pdev)
+{
+	struct hd44780_lcd *gl;
+	int err = 0;
+#ifdef CONFIG_OF_GPIO
+	int i, j;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+#else
+	struct gpio_lcd_map *gpio_map = find_gpio_lcd_map();
+
+	if (!gpio_map)
+		return -ENODEV;
+#endif
+	if (!(gl = devm_kzalloc(&pdev->dev, sizeof *gl, GFP_KERNEL)))
+		return -ENOMEM;
+
+	strncpy(gl->magic, LCD_PLATFORM_MAGIC, sizeof gl->magic);
+	platform_set_drvdata(pdev, gl);
+
+	gl->lcm_clear_display	= 0x01;
+	gl->lcm_return_home	= 0x02;
+	gl->lcm_entry_mode	= 0x04;
+	gl->lcm_display_control	= 0x08;
+	gl->lcm_display_shift	= 0x10;
+	gl->lcm_function	= 0x20;
+	gl->lcm_cgram_address	= 0x40;
+	gl->lcm_ddram_address	= 0x80;
+
+	gl->init	= lcd_init;
+	gl->exit	= lcd_exit;
+
+	gl->get_value = gpiod_get_value;
+	gl->set_value = gpiod_set_value;
+
+	gl->clear_lcd 		= lcd_clear_display;
+	gl->return_home		= lcd_return_home;
+	gl->entry_mode_id	= lcd_entry_mode_id;
+	gl->entry_mode_shift	= lcd_entry_mode_shift;
+	gl->entry_display_on	= lcd_entry_display_on;
+	gl->display_cursor_on	= lcd_display_cursor_on;
+	gl->display_cursor_blink= lcd_display_cursor_blink;
+	gl->shift_display	= lcd_shift_display;
+	gl->shift_cursor	= lcd_shift_cursor;
+	gl->function_8bit	= lcd_function_8bit;
+	gl->function_2line	= lcd_function_2line;
+	gl->function_5x11	= lcd_function_5x11;
+	gl->set_cgram_address	= lcd_set_cgram_address;
+	gl->set_cursor_pos	= lcd_set_cursor_pos;
+
+	gl->backlight_on	= lcd_backlight_on;
+	gl->backlight_state	= lcd_backlight_state;
+	gl->data_write		= lcd_data_write;
+	gl->command_write	= command_write;
+
+	mutex_init(&gl->lcm_lock);
+#ifdef CONFIG_OF_GPIO
+	/* gpiolib is weird. flags' FLAG_ACTIVE_LOW needs to be set outisde. */
+#define GET_GPIO_PIN(np, gl, pin, name, idx)	\
+	do {					\
+		struct gpio_desc *_desc;	\
+		enum of_gpio_flags _flags;	\
+		if (IS_ERR_OR_NULL(_desc =	\
+			of_get_named_gpiod_flags((np),(name),(idx),&_flags))) {\
+			err = PTR_ERR(_desc);	\
+			goto fail;	\
+		}	\
+		if (_flags & OF_GPIO_ACTIVE_LOW)	\
+			set_bit(FLAG_ACTIVE_LOW, &_desc->flags);	\
+		gpiod_direction_output(_desc, 0);	\
+		(gl)->pin = _desc;	\
+	} while (0)
+
+	for (i = 0, j = 4; i < 4; i++, j++)
+		GET_GPIO_PIN(np, gl, lcm_data[j], "lcm-bits", i);
+
+	if (!(gl->lcm_data_4bit = of_get_property(np, "lcm-data-4bit", NULL))) {
+		for ( ; i < 8; i++, j++)
+			GET_GPIO_PIN(np, gl, lcm_data[j], "lcm-bits", i);
+	}
+
+	GET_GPIO_PIN(np, gl, lcm_rs, "lcm-rs", 0);
+	GET_GPIO_PIN(np, gl, lcm_rw, "lcm-rw", 0);
+	GET_GPIO_PIN(np, gl, lcm_en, "lcm-en", 0);
+	GET_GPIO_PIN(np, gl, lcm_bl, "lcm-bl", 0);
+	if (of_property_read_u32(np, "lcm-lines", (u32 *)&gl->lcm_num_rows))
+		gl->lcm_num_rows = 2;
+	if (of_property_read_u32(np, "lcm-cols", (u32 *)&gl->lcm_num_cols))
+		gl->lcm_num_cols = 16;
+#else
+	if ((err = setup_gpiomap(gl, gpio_map)))
+		goto fail;
+#endif
+	if ((err = gl->init(gl)))
+		goto fail;
+	return 0;
+
+fail:
+	devm_kfree(&pdev->dev, gl);
+	return err;
+}
+
+static int hd44780_lcd_remove(struct platform_device *pdev)
+{
+	struct hd44780_lcd *gl = platform_get_drvdata(pdev);
+
+	if (gl && gl->exit)
+		gl->exit(gl);
+	devm_kfree(&pdev->dev, gl);
+	return 0;
+}
+
+static struct of_device_id hd44780_lcd_dt_ids[] = {
+	{
+		.compatible = "hd44780-lcd",
+	}, {
+		.compatible = "gpio-lcd",
+	}, {},
+};
+
+MODULE_DEVICE_TABLE(of, hd44780_lcd_ds_ids);
+
+static struct platform_driver hd44780_lcd_driver = {
+	.probe	= hd44780_lcd_probe,
+	.remove = hd44780_lcd_remove,
+	.driver = {
+		.name = "hd44780-lcd",
+		.of_match_table = hd44780_lcd_dt_ids,
+	},
+};
+
+#ifdef CONFIG_OF_GPIO
+module_platform_driver(hd44780_lcd_driver);
+#else
+static struct platform_device *hd44780_lcd_pdev;
+
+static int __init hd44780_lcd_init(void)
+{
+	int err = platform_driver_register(&hd44780_lcd_driver);
+
+	if (err)
+		return err;
+
+	hd44780_lcd_pdev =
+		platform_device_register_simple(hd44780_lcd_driver.driver.name,
+						-1, NULL, 0);
+	if (IS_ERR(hd44780_lcd_pdev))
+		err = PTR_ERR(hd44780_lcd_pdev);
+	else if (!hd44780_lcd_pdev)
+		err = -ENODEV;
+
+	if (err)
+		platform_driver_unregister(&hd44780_lcd_driver);
+	return err;
+}
+
+static void __exit hd44780_lcd_exit(void)
+{
+	platform_device_unregister(hd44780_lcd_pdev);
+	platform_driver_unregister(&hd44780_lcd_driver);
+}
+
+device_initcall_sync(hd44780_lcd_init);
+module_exit(hd44780_lcd_exit);
+#endif
+
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
+MODULE_DESCRIPTION("generic HD44780 LCD driver");
diff -ruN a/drivers/platform/readynas/hd44780-lcd.h b/drivers/platform/readynas/hd44780-lcd.h
--- a/drivers/platform/readynas/hd44780-lcd.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/hd44780-lcd.h	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,98 @@
+/*
+ * hd44780-lcd.h
+ *
+ * LCD alpha numeric display driver for Hitach HD44780 driven by GPIO
+ *
+ * Copyright (c)2015 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/of.h>
+#ifdef CONFIG_OF_GPIO
+#include <linux/of_fdt.h>
+#endif
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_OF_GPIO
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#else
+
+#define	GPIO_LCD_MAGIC		"gpio-lcd"
+struct gpio_lcd_map {
+	char magic[16];
+	const char *gpio_label;
+	struct {
+		const char *label;
+		const unsigned int val;
+		const bool active_low;
+	} map[];
+};
+#endif
+
+#define	LCD_PLATFORM_MAGIC	"lcd-device"
+struct hd44780_lcd {
+	char magic[12];
+	bool lcm_data_4bit;
+	int  lcm_num_rows;
+	int  lcm_num_cols;
+	struct gpio_desc *lcm_data[8];
+	struct gpio_desc *lcm_rw;
+	struct gpio_desc *lcm_en;
+	struct gpio_desc *lcm_rs;
+	struct gpio_desc *lcm_bl;
+	struct mutex lcm_lock;
+
+	int  (*init)(struct hd44780_lcd *);
+	void (*exit)(struct hd44780_lcd *);
+
+	int  (*get_value)(const struct gpio_desc *);
+	void (*set_value)(struct gpio_desc *, int);
+
+	void (*clear_lcd)(struct hd44780_lcd *);
+	void (*return_home)(struct hd44780_lcd *);
+	void (*entry_mode_id)(struct hd44780_lcd *, bool);
+	void (*entry_mode_shift)(struct hd44780_lcd *, bool);
+	void (*entry_display_on)(struct hd44780_lcd *, bool);
+	void (*display_cursor_on)(struct hd44780_lcd *, bool);
+	void (*display_cursor_blink)(struct hd44780_lcd *, bool);
+	void (*shift_display)(struct hd44780_lcd *, bool);
+	void (*shift_cursor)(struct hd44780_lcd *, bool);
+	void (*function_8bit)(struct hd44780_lcd *, bool);
+	void (*function_2line)(struct hd44780_lcd *, bool);
+	void (*function_5x11)(struct hd44780_lcd *, bool);
+	void (*set_cgram_address)(struct hd44780_lcd *, unsigned char);
+	void (*set_cursor_pos)(struct hd44780_lcd *, unsigned char, unsigned char);
+
+	void (*backlight_on)(struct hd44780_lcd *, bool);
+	bool (*backlight_state)(struct hd44780_lcd *);
+	void (*data_write)(struct hd44780_lcd *, unsigned char);
+	void (*command_write)(struct hd44780_lcd *, unsigned char);
+	bool backlight_status;
+
+	struct platform_device *pdev;
+
+	unsigned char lcm_clear_display;	/* 0x01 */
+	unsigned char lcm_return_home;		/* 0x02 */
+	unsigned char lcm_entry_mode;		/* 0x04 */
+	unsigned char lcm_display_control;	/* 0x08 */
+	unsigned char lcm_display_shift;	/* 0x10 */
+	unsigned char lcm_function;		/* 0x20 */
+	unsigned char lcm_cgram_address;	/* 0x40 */
+	unsigned char lcm_ddram_address;	/* 0x80 */
+};
diff -ruN a/drivers/platform/readynas/Kconfig b/drivers/platform/readynas/Kconfig
--- a/drivers/platform/readynas/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/Kconfig	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,65 @@
+#
+# Platform support for ReadyNAS hardware
+#
+
+menuconfig READYNAS_PLATFORMS
+	bool "Platform support for ReadyNAS hardware"
+	depends on X86 || ARM
+	help
+	  Say Y here to get to see options for platform support for
+	  various ReadyNAS models. This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if READYNAS_PLATFORMS
+
+config GPIO_PWR
+	tristate "Turn off system power using GPIO"
+	depends on OF_GPIO
+	help
+	  Say yes here to enable turning off system power using GPIO.
+
+config HD44780_LCD
+	tristate "Hitachi HD44780 LCD using GPIO"
+	help
+	  Say yes here to enable the alpha numeric LCD driver using
+	  Hitachi HD44780 accessed by GPIO.
+
+config READYNAS_LCD
+	tristate "NETGEAR ReadyNAS LCD driver"
+	depends on HD44780_LCD || READYNAS_IO
+	help
+	  Alpha numeric LCD driver for NETGEAR ReadyNAS.
+
+config READYNAS_IO
+	tristate "NETGEAR ReadyNAS/X86_64 HW UI IO drivers"
+	depends on X86_64
+	select GPIO_IT87
+	select GPIO_NCT6775
+	help
+	  Pseudo GPIO and button handling drivers for NETGEAR ReadyNAS/X86_64.
+
+config READYNAS_LED
+	tristate "NETGEAR ReadyNAS LED drivers"
+	depends on READYNAS_IO
+	select NEW_LEDS
+	select LEDS_CLASS
+	select ENCLOSURE_SERVICES
+	help
+	  Disk and front panel LED drivers for NETGEAR ReadyNAS/X86_64.
+
+config READYNAS_OLED
+	tristate "NETGEAR ReadyNAS OLED driver"
+	depends on READYNAS_IO
+	select READYNAS_LCD
+	help
+	  OLED bitmap character display driver for NETGEAR ReadyNAS/X86_64.
+
+config READYNAS_PMBUS
+	tristate "NETGEAR ReadyNAS PMBus driver interface"
+	depends on READYNAS_IO
+	help
+	  lm-sensors compatible PMBus driver interface for NETGEAR
+	  ReadyNAS/X86_64.
+
+endif # READYNAS_PLATFORMS
diff -ruN a/drivers/platform/readynas/Makefile b/drivers/platform/readynas/Makefile
--- a/drivers/platform/readynas/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/Makefile	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,12 @@
+
+obj-$(CONFIG_GPIO_PWR)		+= readynas-gpio-pwr.o
+#
+# Keep module loading order
+#
+obj-$(CONFIG_READYNAS_IO)	+= readynas-io.o
+obj-$(CONFIG_READYNAS_IO)	+= readynas-gpio.o
+obj-$(CONFIG_HD44780_LCD)	+= hd44780-lcd.o
+obj-$(CONFIG_READYNAS_OLED)	+= readynas-oled.o
+obj-$(CONFIG_READYNAS_LCD)	+= readynas-lcd.o
+obj-$(CONFIG_READYNAS_LED)	+= readynas-led.o
+obj-$(CONFIG_READYNAS_PMBUS)	+= readynas-pmbus.o
diff -ruN a/drivers/platform/readynas/readynas-gpio.c b/drivers/platform/readynas/readynas-gpio.c
--- a/drivers/platform/readynas/readynas-gpio.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-gpio.c	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,468 @@
+/*
+ * Platform-specific psuedo GPIO drivers for ReadyNAS x86_64 plarforms
+ *
+ * Copyright (c) 2016 Hiro Sugawara
+ */
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+
+#include "readynas-io.h"
+
+/*
+ * PCA9505 I2C GPIO for RR[34]312
+ * GPIO functionality is implemented in drivers/gpio/gpio-pca953x.c
+ */
+#define	PCA9505_I2C_CHIPADDR	0x20
+static struct i2c_client *pca9505_i2c_client;
+
+static void pca9505_gpio_exit(void *d)
+{
+	if (!IS_ERR_OR_NULL(pca9505_i2c_client))
+		i2c_unregister_device(pca9505_i2c_client);
+	pca9505_i2c_client = NULL;
+}
+
+static int __init pca9505_gpio_init(void *d)
+{
+	static struct i2c_board_info pca9505_i2c_info = {
+		I2C_BOARD_INFO("pca9505", PCA9505_I2C_CHIPADDR),
+	};
+	int err;
+	struct i2c_adapter *i2c_adapter =
+				readynas_i2c_adapter_find(rn_i2c_adapters_ipch);
+
+	pr_info("%s: initializing PCA9505 GPIO.\n", __func__);
+
+	if (IS_ERR_OR_NULL(i2c_adapter)) {
+		pr_err("%s: failed to locate I2C adapter.\n", __func__);
+		return i2c_adapter ? PTR_ERR(i2c_adapter) : -ENODEV;
+	}
+
+	pca9505_i2c_client = i2c_new_client_device(i2c_adapter, &pca9505_i2c_info);
+	if (IS_ERR_OR_NULL(pca9505_i2c_client)) {
+		pr_err("%s: failed to allocate pca9505 I2C client.\n",
+			__func__);
+		return pca9505_i2c_client ?
+			PTR_ERR(pca9505_i2c_client) : -ENOMEM;
+	}
+
+	if ((err = device_attach(&pca9505_i2c_client->dev)) != 1) {
+		pr_err("%s: failed to attach pca9505 device.\n", __func__);
+		pca9505_gpio_exit(NULL);
+	} else if (!err)
+		err = -ENODEV;
+	else
+		err = 0;
+	return err;
+}
+
+/**
+ * RNS3220/42220 PIC-based GPIO for sataN LEDs
+ */
+static void rnx220pic_gpio_set(struct gpio_chip *gc,
+				unsigned int gpio_num, int val)
+{
+	int err;
+	u8 row = gpio_num / 4;
+	u8 mask = 1 << (gpio_num % 4);
+	union i2c_smbus_data i2c_data;
+	struct i2c_adapter *i2c_adapter =
+			readynas_i2c_adapter_find(rn_i2c_adapters_nct677x);
+
+	static u8 led_bitmap[3];
+	static const u8 led_reg[3] = {0x62, 0x60, 0x61};
+
+	if (IS_ERR_OR_NULL(i2c_adapter)) {
+		pr_err("%s: cannot find compatible I2C chip.\n", __func__);
+		return;
+	}
+
+	if (val)
+		led_bitmap[row] |= mask;
+	else
+		led_bitmap[row] &= ~mask;
+
+	i2c_data.byte = led_bitmap[row];
+	if ((err = i2c_smbus_xfer(i2c_adapter,
+			led_reg[row], 0,
+			I2C_SMBUS_WRITE, 0,
+			I2C_SMBUS_BYTE_DATA, &i2c_data)))
+		pr_err("%s: error in SMBus write (%d)\n", __func__, err);
+}
+
+static int gpio_direction_output_always(struct gpio_chip *gc,
+				unsigned int gpio_num, int val)
+{
+	return 0;
+}
+
+static struct gpio_chip rnx220pic_gpio_chip = {
+	.label		= "gpio_rnx220pic",
+	.owner		= THIS_MODULE,
+	.set		= rnx220pic_gpio_set,
+	.direction_output	= gpio_direction_output_always,
+	.base		= -1,
+	.ngpio		= 12,
+};
+
+static bool rnx220pic_gpio_inited;
+static int __init rnx220pic_gpio_init(void *d)
+{
+	int err = gpiochip_add(&rnx220pic_gpio_chip);
+
+	pr_info("%s: initializing RN3220/4220 PIC GPIO.\n", __func__);
+	if (err) {
+		pr_err("%s: failed to add RN3220/4220 PIC GPIO chip.\n",
+			__func__);
+		return err;
+	}
+	rnx220pic_gpio_inited = true;
+	return 0;
+}
+
+static void rnx220pic_gpio_exit(void *d)
+{
+	if (rnx220pic_gpio_inited)
+		gpiochip_remove(&rnx220pic_gpio_chip);
+	rnx220pic_gpio_inited = false;
+}
+
+static struct marvell_data {
+	const int ndata;
+	const u8 reg0;
+	const u8 data[];
+}
+	marvell_preamble = { 4, 0xa8, {0x58, 0x02, 0x00, 0x00}},
+	marvell_init_1	=  { 4, 0xac, {0x10, 0x32, 0x54, 0x00}},
+	marvell_disk3_1	=  { 4, 0xac, {0x10, 0x37, 0x54, 0x00}},
+	marvell_disk3_2	=  { 4, 0xa8, {0x24, 0x02, 0x00, 0x00}},
+	marvell_disk3_3	=  { 1, 0xac, {0xfb}},
+	marvell_disk4_1	=  { 4, 0xac, {0x10, 0x32, 0x57, 0x00}},
+	marvell_disk4_2	=  { 4, 0xa8, {0x24, 0x02, 0x00, 0x00}},
+	marvell_disk4_3	=  { 1, 0xac, {0xef}, },
+	marvell_disk34_1 = { 4, 0xac, {0x10, 0x37, 0x57, 0x00}},
+	marvell_disk34_2 = { 4, 0xa8, {0x24, 0x02, 0x00, 0x00}},
+	marvell_disk34_3 = { 1, 0xac, {0xeb}},
+	marvell_disk_1	=  { 4, 0xac, {0x10, 0x37, 0x57, 0x00}},
+	marvell_disk_2	=  { 4, 0xa8, {0x24, 0x02, 0x00, 0x00}},
+	marvell_disk_3	=  { 1, 0xac, {0xff}};
+
+static struct marvell_data_seq {
+	int num;
+	struct marvell_data *md[];
+}
+	marvell_init = {
+	/* Set the GPIO to control the HDD LED. */
+	/* Set [AB:A8][def:0x00000008] memory to 0x00000258 */
+	/* Set GPIO_ACTIVITY_SELECT */
+		.num = 2,
+		.md = {&marvell_preamble, &marvell_init_1},
+	},
+	marvell_disk3 = {
+	/* Set [AB:A8] memory to 0x00000258,Set GPIO_ACTIVITY_SELECT */
+		.num = 4,
+		.md = {&marvell_preamble,
+			&marvell_disk3_1, &marvell_disk3_2, &marvell_disk3_3},
+	},
+	marvell_disk4 = {
+	/* Set [AF:AC] memory bit[19:16]/GPIO4/HDD2 to 7H. */
+	/* Set [AB:A8] memory to 0x00000258,Set GPIO_ACTIVITY_SELECT */
+	/* Set [AF:AC][def:0x00543210] memory bit[11:8]/GPIO2/HHD1 to 7h. */
+		.num = 4,
+		.md = {&marvell_preamble,
+			&marvell_disk4_1, &marvell_disk4_2, &marvell_disk4_3},
+		},
+	marvell_disk34 = {
+	/* Set [AB:A8] memory to 0x00000224,Set AC[bit2&4]/GPIO2&4 to 0 */
+		.num = 4,
+		.md = {&marvell_preamble,
+			&marvell_disk34_1, &marvell_disk34_2,&marvell_disk34_3},
+	},
+	marvell_disk = {
+	/* Set [AB:A8] memory to 0x00000224,Set AC[bit2&4]/GPIO2&4 to 1 */
+		.num = 4,
+		.md = {&marvell_preamble,
+		&marvell_disk_1, &marvell_disk_2, &marvell_disk_3},
+	};
+
+static void __iomem *marvell_mem;
+static void marvell_write(const struct marvell_data_seq *mds)
+{
+	/**************************************************
+	1. Enter the Marvell 9170 chip configure space
+	   through PCIE.  Bus 3,Device 0,Function 0.
+	2. Read the BAR Address (offset 0x24-0x27)
+	3. Enter the BAR memory space.
+	4. Write 0x258	to [AB:A8] ,Set  GPIO ACTIVITY_SELECT
+	5. HHD1 ,GPIO02 :	Set 0x00AC bit [11:8] to 7H
+	   HDD2, GPIO04 :	 Set 0x00AC bit [23:20] to 7H
+	6. Write 0x224	to [AB:A8] ,
+	7. HHD1 ,GPIO02 :	 Set bit 2 to on/off
+	   HHD2 ,GPIO04 :	Set Bit 4 to on/off
+	 ****************************************************/
+
+	int i;
+
+	for (i = 0; i < mds->num; i++) {
+		u8 reg = mds->md[i]->reg0;
+		int j, ndata = mds->md[i]->ndata;
+
+		for (j = 0; j < ndata; j++)
+			iowrite8(mds->md[i]->data[j], marvell_mem + reg++);
+	}
+}
+
+/* gpio_num: 0 => DISK3, 1 => DISK4 */
+static void rnx220marvell_gpio_set(struct gpio_chip *gc,
+				unsigned int gpio_num, int val)
+{
+	static const struct marvell_data_seq *mds[] = {
+		[0] = &marvell_disk,
+		[1] = &marvell_disk3,
+		[2] = &marvell_disk4,
+		[3] = &marvell_disk34
+	};
+	static u8 state;
+
+	u8 nstate = state;
+	u8 mask = 1 << gpio_num;
+
+	if (val)
+		nstate |= mask;
+	else
+		nstate &= ~mask;
+
+	if (nstate == state || nstate >= ARRAY_SIZE(mds))
+		return;
+	marvell_write(mds[nstate]);
+	state = nstate;
+}
+
+static struct gpio_chip rnx220marvell_gpio_chip = {
+	.label		= "gpio_rnx220marvell",
+	.owner		= THIS_MODULE,
+	.set		= rnx220marvell_gpio_set,
+	.direction_output	= gpio_direction_output_always,
+	.base		= -1,
+	.ngpio		= 2,
+};
+
+static unsigned int read_pci_config32(unsigned char bus,
+		unsigned char slot, unsigned char func, unsigned char offset)
+{
+	outl((1<<31) | (bus<<16) | (slot<<11) | (func<<8) | offset, 0xcf8);
+	return inl(0xcfc);
+}
+
+static int __init rnx220marvell_gpio_init(void *d)
+{
+#define MARVELL_BUS_ID   0x03
+#define MARVELL_DEV_ID   0x00
+#define MARVELL_FUNC   	 0x00
+#define MARVELL_BAR_ADDR 0x24
+
+	int err;
+	u32 marvell_reg;
+
+	pr_info("%s: initializing RNX220 Marvell GPIO.\n", __func__);
+	marvell_reg = read_pci_config32(MARVELL_BUS_ID, MARVELL_DEV_ID,
+					MARVELL_FUNC, MARVELL_BAR_ADDR);
+	if (!(marvell_mem = ioremap(marvell_reg, 1024))) {
+		pr_err("%s: failed to remap registers.\n", __func__);
+		return -EIO;
+	}
+
+	marvell_write(&marvell_init);
+	if ((err =  gpiochip_add(&rnx220marvell_gpio_chip))) {
+		pr_err("%s: failed to add GPIO chip.\n", __func__);
+		iounmap(marvell_mem);
+		marvell_mem = NULL;
+	}
+	return err;
+}
+
+static void rnx220marvell_gpio_exit(void *d)
+{
+	if (marvell_mem) {
+		gpiochip_remove(&rnx220marvell_gpio_chip);
+		iounmap(marvell_mem);
+		marvell_mem = NULL;
+	}
+}
+
+/*
+ * Intel Apollo Lake GPIO consists of 4 individual GPIOs INT3452:00-03
+ * spread amaong 4 (N, NW, SW, W) pinctrl communities.
+ * This pseudo GPIO translates them into a linear single GPIO.
+ */
+enum { APL_NORTH, APL_NORTHWEST, APL_SOUTHWEST, APL_WEST };
+static struct pinctrl_apl_gpio {
+	const char *label;
+	struct gpio_chip *chip;
+} pinctrl_apl_gpio[] = {
+	[APL_NORTH]	= { "INT3452:00", },
+	[APL_NORTHWEST]	= { "INT3452:01", },
+	[APL_SOUTHWEST]	= { "INT3452:03", },
+	[APL_WEST]	= { "INT3452:02", }, {}
+};
+
+static struct gpio_chip
+*pinctrl_apl_community_gpio_chip(unsigned int *gpio_num)
+{
+	struct gpio_chip *chip = NULL;
+
+#define	CASE_APL_GPIO_N(base, end, off, gpio)	\
+	case (base) ... (end):		\
+		*gpio_num -= ((base) - ((off) - 0x500)/8);	\
+		chip = pinctrl_apl_gpio[APL_##gpio].chip;	\
+		break
+
+	switch (*gpio_num) {
+	CASE_APL_GPIO_N(0,   73,  0x500, NORTH);
+	CASE_APL_GPIO_N(74,  103, 0x610, NORTHWEST);
+	CASE_APL_GPIO_N(104, 123, 0x6e8, NORTHWEST);
+	CASE_APL_GPIO_N(124, 155, 0x500, WEST);
+	CASE_APL_GPIO_N(156, 172, 0x520, SOUTHWEST);
+	CASE_APL_GPIO_N(173, 178, 0x5b0, SOUTHWEST);
+	CASE_APL_GPIO_N(179, 179, 0x5a8, SOUTHWEST);
+	/* 180 & 181 do not exist.*/
+	CASE_APL_GPIO_N(182, 183, 0x5e8, SOUTHWEST);
+	/* 184 & 185 do not exist.*/
+	CASE_APL_GPIO_N(186, 186, 0x5e0, SOUTHWEST);
+	CASE_APL_GPIO_N(187, 204, 0x500, NORTHWEST);
+	CASE_APL_GPIO_N(205, 208, 0x500, SOUTHWEST);
+	CASE_APL_GPIO_N(209, 212, 0x5d0, WEST);
+	CASE_APL_GPIO_N(213, 215, 0x5d0, NORTHWEST);
+	default:
+		break;
+	}
+	return chip;
+}
+
+#define __PINCTRL_APL_CHIP(gpio, rval)	\
+	({	\
+		struct gpio_chip *chip =	\
+			pinctrl_apl_community_gpio_chip(&(gpio)); \
+		if (!chip)	\
+			return rval;	\
+		chip;		\
+	})
+
+#define PINCTRL_APL_CHIP_INT(gpio)	__PINCTRL_APL_CHIP(gpio, -EINVAL)
+#define PINCTRL_APL_CHIP_VOID(gpio)	__PINCTRL_APL_CHIP(gpio, )
+
+static int pinctrl_apl_gpio_get(struct gpio_chip *gc, unsigned int gpio_num)
+{
+	gc = PINCTRL_APL_CHIP_INT(gpio_num);
+	return gc->get(gc, gpio_num);
+}
+
+static void pinctrl_apl_gpio_set(struct gpio_chip *gc,
+				unsigned int gpio_num, int val)
+{
+	gc = PINCTRL_APL_CHIP_VOID(gpio_num);
+	gc->set(gc, gpio_num, val);
+}
+
+static int pinctrl_apl_gpio_direction_output(struct gpio_chip *gc,
+				unsigned int gpio_num, int val)
+{
+	gc = PINCTRL_APL_CHIP_INT(gpio_num);
+	return gc->direction_output(gc, gpio_num, val);
+}
+
+static int pinctrl_apl_gpio_direction_input(struct gpio_chip *gc,
+				unsigned int gpio_num)
+{
+	gc = PINCTRL_APL_CHIP_INT(gpio_num);
+	return gc->direction_input(gc, gpio_num);
+}
+
+static struct gpio_chip pinctrl_apl_gpio_chip = {
+	.label		= "gpio_apl",
+	.owner		= THIS_MODULE,
+	.get		= pinctrl_apl_gpio_get,
+	.set		= pinctrl_apl_gpio_set,
+	.direction_output	= pinctrl_apl_gpio_direction_output,
+	.direction_input	= pinctrl_apl_gpio_direction_input,
+	.base		= -1,
+	/* INT3452:0x add up to 245 ports and CASE_APL_GPIO_N counts
+	 * 214 ports. We, however, enables only the first 100 ports
+	 * for saving available GPIO port number.
+	 */
+	.ngpio		= 100,
+};
+
+static int gpio_match(struct gpio_chip *chip, void *data)
+{
+	return !strcmp(chip->label, (const char *)data);
+}
+
+static int pinctrl_apl_gpio_init(void *d)
+{
+	int i;
+
+	for (i = 0; pinctrl_apl_gpio[i].label; i++) {
+		if (!(pinctrl_apl_gpio[i].chip =
+			gpiochip_find((void *)pinctrl_apl_gpio[i].label,
+					gpio_match))) {
+			pr_err("%s: GPIO chip %s not found\n", __func__,
+					pinctrl_apl_gpio[i].label);
+			return -ENODEV;
+		}
+	}
+	pr_info("%s: Adding Apollo Lake pinctrl psuedo GPIO %s.\n",
+		__func__, pinctrl_apl_gpio_chip.label);
+	return gpiochip_add(&pinctrl_apl_gpio_chip);
+}
+
+static void pinctrl_apl_gpio_exit(void *d)
+{
+}
+
+static const struct {
+	const char *compatible;
+	int (*init)(void *);
+	void (*exit)(void *);
+	void *data;
+} rn_gpio_list[] = {
+	{ "rnx220",  rnx220pic_gpio_init,    rnx220pic_gpio_exit, },
+	{ "rnx220",  rnx220marvell_gpio_init,rnx220marvell_gpio_exit, },
+	{ "rrx312",  pca9505_gpio_init,	     pca9505_gpio_exit, },
+	{ "rr2304",  pinctrl_apl_gpio_init,  pinctrl_apl_gpio_exit, },
+	{}
+};
+
+void __readynas_gpio_exit(int idx)
+{
+	while (--idx >= 0)
+		if (readynas_io_compatible(rn_gpio_list[idx].compatible) &&
+						rn_gpio_list[idx].exit)
+			rn_gpio_list[idx].exit(rn_gpio_list[idx].data);
+}
+
+void readynas_gpio_exit(void)
+{
+	int i;
+
+	for (i = 0; rn_gpio_list[i].compatible; i++)
+		;
+	__readynas_gpio_exit(i);
+}
+
+int __init readynas_gpio_init(void)
+{
+	int i;
+
+	for (i = 0; rn_gpio_list[i].compatible; i++) {
+		int err;
+
+		if (readynas_io_compatible(rn_gpio_list[i].compatible) &&
+			(err = rn_gpio_list[i].init(rn_gpio_list[i].data))) {
+			__readynas_gpio_exit(i);
+			return err;
+		}
+	}
+	return 0;
+}
diff -ruN a/drivers/platform/readynas/readynas-gpio-pwr.c b/drivers/platform/readynas/readynas-gpio-pwr.c
--- a/drivers/platform/readynas/readynas-gpio-pwr.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-gpio-pwr.c	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,66 @@
+/*
+ * NETGEAR ReadyNAS RN2xx GPIO power contoller
+ *
+ * Copyright (C) 2015 NETGEAR, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/gpio.h>
+#include "../../gpio/gpiolib.h"
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+
+static struct gpio_desc *power_off_desc;
+
+static void gpio_power_off(void)
+{
+	gpiod_set_value(power_off_desc, 0);
+	mdelay(10);
+	gpiod_set_value(power_off_desc, 1);
+	pr_emerg("Unable to shut down!!\n");
+}
+
+static int gpio_pwr_probe(struct platform_device *pdev)
+{
+	enum of_gpio_flags flags;
+	struct device_node *np = pdev->dev.of_node;
+	struct gpio_desc *desc =
+			of_get_named_gpiod_flags(np, "gpios", 0, &flags);
+
+	if (IS_ERR(desc))
+		return (int)desc;
+
+	if (flags & OF_GPIO_ACTIVE_LOW)
+		set_bit(FLAG_ACTIVE_LOW, &desc->flags);
+	power_off_desc = desc;
+	pm_power_off = gpio_power_off;
+	return 0;
+}
+
+static struct of_device_id gpio_pwr_dt_ids[] = {
+	{
+		.compatible = "gpio-power-off",
+	}, {},
+};
+
+static struct platform_driver gpio_pwr_driver = {
+	.probe = gpio_pwr_probe,
+	.driver = {
+		.name = "gpio-pwr",
+		.of_match_table = gpio_pwr_dt_ids,
+	},
+};
+
+module_platform_driver(gpio_pwr_driver);
diff -ruN a/drivers/platform/readynas/readynas-io.c b/drivers/platform/readynas/readynas-io.c
--- a/drivers/platform/readynas/readynas-io.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-io.c	2024-05-07 15:46:53.865848872 +0800
@@ -0,0 +1,2089 @@
+/*
+ * readynas-io.c - NETGEAR ReadyNAS Intel platform I/O assortment
+ *
+ * Copyright (c) 2015-2017 NETGEAR, Inc.
+ *
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ */
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/acpi.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/dmi.h>
+#include <linux/timer.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/input.h>
+#include <linux/kthread.h>
+#include <linux/i2c.h>
+#include <linux/uaccess.h>
+
+#include "readynas-io.h"
+
+static struct proc_dir_entry *readynas_proc_root;
+
+struct proc_dir_entry *readynas_proc_create(const char *name,
+			umode_t mode,
+			const struct proc_ops *fops,
+			void *data)
+{
+	return proc_create_data(name, mode, readynas_proc_root, fops, data);
+}
+
+/*
+ * Generic GPIO and model name search functions.
+ */
+static int gpio_match_labels(struct gpio_chip *gc, void *data)
+{
+	return !strcmp(gc->label, (const char *)data);
+}
+
+struct gpio_chip *rn_gpiochip_find_by_label(const char *label)
+{
+	return gpiochip_find((void *)label, gpio_match_labels);
+}
+
+/*
+ * List of supported NAS models.
+ * First element of each internal array is the nominal model name followed
+ * by up to 6 possible DMI name strings.
+ */
+static const struct compatible {
+	const char *nominal;
+	const char *models[12];
+} compatibles[] = {
+	{"ultra2", {"ReadyNAS-ProUltra2", NULL}},
+	{"ultra4", {"ReadyNAS-NVX-V2", "Ultra4", NULL}},
+	{"ultra6", {"FLAME6-2", "Ultra6", NULL}},
+	{"pro6",   {"FLAME6-MB", "Pro6", NULL}},
+	{"rn312",  {"ReadyNAS 312", "RN312", NULL}},
+	{"rn314",  {"ReadyNAS 314", "RN314", NULL}},
+	{"rn316",  {"ReadyNAS 316", "RN316", NULL}},
+	{"rn422",  {"ReadyNAS 422", "RN422", NULL}},
+	{"rn424",  {"ReadyNAS 424", "RN424", NULL}},
+	{"rn426",  {"ReadyNAS 426", "RN426", NULL}},
+	{"rn428",  {"ReadyNAS 428", "RN428", NULL}},
+	{"rnx16",  {"ReadyNAS 516", "RN516", "ReadyNAS 716", "RN716", "ReadyDATA 516", "RDD516", NULL}},
+	{"rnx24",  {"ReadyNAS 524", "RN524", "ReadyNAS 624", "RN624", NULL}},
+	{"rnx26",  {"ReadyNAS 526", "RN526", "ReadyNAS 626", "RN626", NULL}},
+	{"rnx28",  {"ReadyNAS 528", "RN528", "ReadyNAS 628", "RN628", NULL}},
+	{"rr2304", {"ReadyNAS 2304", "RR2304", NULL}},
+	{"rr2308", {"ReadyNAS 2308", "RR2308", NULL}},
+	{"rr2312", {"ReadyNAS 2312", "RR2312", NULL}},
+	{"rn3130", {"ReadyNAS 3130", "ReadyNAS3130", "RN3130", NULL}},
+	{"rn3138", {"ReadyNAS 3138", "ReadyNAS3138", "RN3138", NULL}},
+	{"rnx220", {"ReadyNAS 3220", "ReadyNAS3220", "RN3220",
+	            "ReadyNAS 4220", "ReadyNAS4220", "RN4220", NULL}},
+	{"rrx312", {"ReadyNAS 3312", "ReadyNAS3312", "RR3312",
+	            "ReadyNAS 4312", "ReadyNAS4312", "RR4312",
+		    "ReadyNAS 3312V2", "RR3312V2",
+		    "ReadyNAS 4312V2", "RR4312SV2", "RR4312XV2", NULL}},
+	{"rr4360", {"ReadyNAS 4360", "ReadyNAS4360", "RR4360", NULL}},
+	{}
+},
+gcompatibles[] = {
+	/* Group model names for submodel names. */
+	{"rn42x",  {"rn422", "rn424", "rn426", "rn428", NULL}},
+	{"rn422_4",  {"rn422", "rn424", NULL}},
+	{"rn426_8",  {"rn426", "rn428", NULL}},
+	{"rnx2x",  {"rnx24", "rnx26", "rnx28", NULL}},
+	{"rrx312_60",  {"rrx312", "rr4360", NULL}},
+	{"rr23xx",  {"rr2304", "rr2308", "rr2312", NULL}},
+	{"rn313x",  {"rn3130", "rn3138", NULL}},
+	{}
+};
+
+static bool model_compatible(char const *dmi, const struct compatible *model)
+{
+	const char * const *m = model->models;
+
+	while (*m) {
+		const char *p;
+
+		if (!strcmp(dmi, *m) || !*m)
+			return true;
+		/* Some model names may have an 'X' suffix. */
+		if ((p = strstr(dmi, *m))) {
+			p += strlen(*m);
+			if (!*p || isspace(*p) || *p == 'X' || *p == 'S')
+				return true;
+		}
+		m++;
+	}
+	return false;
+}
+
+bool readynas_io_compatible(char const *nominal)
+{
+	const char *dmi[2];
+	const struct compatible *model;
+	int i;
+	static bool inited;
+
+	dmi[0] = dmi_get_system_info(DMI_PRODUCT_NAME);
+	dmi[1] = dmi_get_system_info(DMI_PRODUCT_VERSION);
+
+	if (!inited) {
+		for (i = 0; i < ARRAY_SIZE(dmi); i++)
+			if (dmi[i] &&
+				strcmp(dmi[i], "ReadyNAS") &&
+				strcmp(dmi[i], "ReadyNAS  ")) {
+				pr_info("ReadyNAS model: %s\n", dmi[i]);
+				break;
+			}
+		inited = true;
+	}
+
+	for (model = &compatibles[0]; model->nominal; model++)
+		if (!strcmp(model->nominal, nominal))
+			break;
+
+	if (model->nominal) {
+		for (i = 0; i < ARRAY_SIZE(dmi); i++)
+			if (dmi[i] && model_compatible(dmi[i], model))
+				return true;
+		return false;
+	}
+
+	/* Submodel names? */
+	for (model = &gcompatibles[0]; model->nominal; model++)
+		if (!strcmp(model->nominal, nominal))
+			break;
+	if (!model->nominal) {
+		WARN(1, "%s: '%s' not found", __func__, nominal);
+		return false;
+	}
+
+	/* Recursive call for submodels. */
+	for (i = 0; model->models[i]; i++)
+		if (readynas_io_compatible(model->models[i]))
+			return true;
+
+	return false;
+}
+
+const char *rn_i2c_adapters_nct677x[] = { "NCT6775", "NCT6776", "NCT6779",
+					"nct6775", "nct6776", "nct6779", NULL };
+const char *rn_i2c_adapters_ipch[] = { "I801", "i801", NULL };
+
+static int i2c_name_match(struct device *dev, const void *data)
+{
+	const char *devname = to_i2c_adapter(dev)->name;
+	const char * const *pp = data;
+
+	while (*pp)
+		if (strstr(devname, *pp++))
+			return 1;
+	return 0;
+}
+
+struct i2c_adapter *readynas_i2c_adapter_find(const char **i2c_names)
+{
+	struct device *i2c_dev = bus_find_device(&i2c_bus_type, NULL,
+						i2c_names, i2c_name_match);
+	return i2c_dev ? to_i2c_adapter(i2c_dev) : ERR_PTR(-ENODEV);
+}
+
+/* ACPI IRQ is hardcoded in each GPIO driver. */
+#if 0
+static int acpi_irq(void)
+{
+	int irq;
+	struct irq_desc *desc;
+
+	for (irq = 0; irq < nr_irqs; irq++) {
+		unsigned long flags;
+		struct irqaction *action;
+
+		if (!(desc = irq_to_desc(irq)))
+			continue;
+		raw_spin_lock_irqsave(&desc->lock, flags);
+		for (action = desc->action; action; action = action->next)
+			if (action->name && !strcmp(action->name, "acpi"))
+				break;
+		raw_spin_unlock_irqrestore(&desc->lock, flags);
+		if (action) {
+			pr_info("%s: acpi irq = %d\n", __func__, irq);
+			return irq;
+		}
+	}
+	pr_err("%s: acpi irq not found.\n", __func__);
+	return -ENODEV;
+}
+
+#define ACPI_IRQ(bw)	\
+	do {					\
+		if (!(bw)->irq) {		\
+			int __irq = acpi_irq();	\
+			if (__irq < 0)		\
+				return __irq;	\
+			(bw)->irq = __irq;	\
+		}				\
+	} while (0)
+#endif
+
+/*
+ * Hitach HD44780 for RN314/Ultra4 LCD alphanumeric display
+ */
+static struct platform_device *rnx4_lcd_pdev;
+
+static int __init rnx4_lcd_init(void)
+{
+	static const struct gpio_lcd_map
+	rn314_lcd_map = {
+		.magic		= GPIO_LCD_MAGIC,
+		.gpio_label	= "gpio_ich",
+		.map = {
+			{"lcm-rs",	33},
+			{"lcm-rw",	19},
+			{"lcm-en",	32},
+			{"lcm-bl",	48, true},
+			{"lcm-bit4",	36},
+			{"lcm-bit5",	37},
+			{"lcm-bit6",	38},
+			{"lcm-bit7",	39},
+			{"lcm-lines",	2},
+			{"lcm-cols",	16},
+			{"lcm-data-4bit",1},
+			{}
+		}
+	},
+	ultra4_lcd_map = {
+		.magic		= GPIO_LCD_MAGIC,
+		.gpio_label	= "gpio_ich",
+		.map = {
+			{"lcm-rs",	33},
+			{"lcm-rw",	34},
+			{"lcm-en",	32},
+			{"lcm-bl",	48, true},
+			{"lcm-bit4",	36},
+			{"lcm-bit5",	37},
+			{"lcm-bit6",	38},
+			{"lcm-bit7",	39},
+			{"lcm-lines",	2},
+			{"lcm-cols",	16},
+			{"lcm-data-4bit",1},
+			{}
+		}
+	};
+
+	static struct rnx4_lcd_info {
+		const char *compatible;
+		struct platform_driver pdriver;
+		const struct gpio_lcd_map *map;
+	} rnx4_lcd_info[] = {
+		{
+			"rn314",
+			{ .driver = { .name	= "rn314-lcd", }, },
+			&rn314_lcd_map
+		}, {
+			"ultra4",
+			{ .driver = { .name	= "ultra4-lcd", }, },
+			&ultra4_lcd_map
+		},{}
+	};
+
+	int err;
+	struct rnx4_lcd_info *lcd =
+		__compatible_find(rnx4_lcd_info, compatible, 0, "");
+
+	pr_info("%s: initializing %s LCD front display.\n",
+		__func__, lcd->compatible);
+	if ((err = platform_driver_register(&lcd->pdriver))) {
+		pr_err("%s: failed to register %s LCD driver.\n", __func__,
+			lcd->compatible);
+		return err;
+	}
+
+	rnx4_lcd_pdev =
+		platform_device_register_simple(lcd->pdriver.driver.name,
+						-1, NULL, 0);
+	if (IS_ERR(rnx4_lcd_pdev))
+		err = PTR_ERR(rnx4_lcd_pdev);
+	else if (!rnx4_lcd_pdev)
+		err = -ENODEV;
+	else
+		platform_set_drvdata(rnx4_lcd_pdev, (void *)lcd->map);
+
+	if (err) {
+		pr_err("%s: failed to register %s LCD device.\n", __func__,
+			lcd->compatible);
+		platform_driver_unregister(&lcd->pdriver);
+		rnx4_lcd_pdev = NULL;
+	}
+
+	return err;
+}
+
+static void rnx4_lcd_exit(void)
+{
+	if (rnx4_lcd_pdev) {
+		struct device_driver *drv = rnx4_lcd_pdev->dev.driver;
+
+		platform_device_unregister(rnx4_lcd_pdev);
+		platform_driver_unregister(to_platform_driver(drv));
+		rnx4_lcd_pdev = NULL;
+	}
+}
+
+/*
+ * Common button event and state handling.
+ */
+#define	BUTTON_ATTR_IRQ		(0<<16)
+#define	BUTTON_ATTR_ACPI	(1<<16)
+#define MK_BUTTON(type, e)	(BUTTON_ATTR_##type | (e))
+#define IS_BUTTON(type, e)	((~0<<16)&(e) == BUTTON_ATTR_##type)
+
+/*
+ * struct button_work - front and rear panel button handling
+ *
+ * @name - button name appearing as name-button in procfs
+ * @gpio_label - handling GPIO's chip name
+ * @gpio_num - handling GPIO's pin number
+ * @gpio_active_low - GPIO pin's polatiry
+ * @gpio_desc - internally filled and used GPIO descriptor
+ * @key - input layer key code: KEY_*
+ * @input_dev - relevant input device struct pointer
+ * @input_dev_name - name string for input device (default: "rn_button")
+ * @worker_to_set - button handling work function (default: button_worker)
+ * @worker - button handling thread
+ * @prev_button_state - for polling
+ * @i2cfb_button_state - for FB button polling
+ * @button - internal button number: BUTTON_BACKUP, BUTTON_RESET, ...
+ * @type - event type: IRQ: spawns thread for each depress to poll for release,
+ *	  THREAD: continues to poll button for release,
+ *	  POLL: a common thread polls for press and release
+ *	  IRQ: both rising and falling edges
+ * @irq_type - IRQ_TYPE_*
+ * @init, @exit - button-specific initializer and exiter
+ * @depressed - depress sensor (default: button_gpio_depressed)
+ * @irq - virtual IRQ number returned by gpio_to_irq()
+ * @notifier - internal optional notifier
+ * @private -  button-specific private item
+ * @private2 - button-specific private item #2
+ * @acpi_event_number - conflicting ACPI GPE number
+ */
+enum button_num {
+	BUTTON_BACKUP	= 0,
+	BUTTON_RESET	= 1,
+	BUTTON_UID	= 2,
+
+	BUTTON_FB_BASE	= 8,
+	BUTTON_LEFT	= 8,
+	BUTTON_RIGHT,
+	BUTTON_UP,
+	BUTTON_DOWN,
+	BUTTON_OK,
+};
+
+enum button_event_type {
+	BUTTON_TYPE_NONE	= 0,
+	BUTTON_TYPE_IRQ,
+	BUTTON_TYPE_THREAD,
+	BUTTON_TYPE_POLL,
+
+	BUTTON_TYPE_I2CFB,
+
+	BUTTON_TYPE_SUBWORK	= 0x10000,
+	BUTTON_TYPE_NOBOUNCE	= 0x20000,
+};
+
+#define BUTTON_TYPE(bw)	((bw)->type & 0xffff)
+#define BUTTON_TYPE_IS_IRQ(bw)	(BUTTON_TYPE(bw) == BUTTON_TYPE_IRQ)
+#define	BUTTON_TYPE_IRQ_I2CFB	\
+		(BUTTON_TYPE_IRQ | BUTTON_TYPE_SUBWORK | BUTTON_TYPE_NOBOUNCE)
+
+static struct button_work {
+	const char *name;
+	const char *gpio_label;
+	unsigned int gpio_num;
+	bool	gpio_active_low;
+	struct	gpio_desc *gpio_desc;
+	unsigned int	key;
+	struct	input_dev *input_dev;
+	const char *input_dev_name;
+	work_func_t	worker_to_set;
+	struct	work_struct worker;
+	unsigned int button;
+	enum button_event_type type;
+	unsigned int irq_type;
+	bool busy;
+	int  (*init)(struct button_work *);
+	void (*exit)(struct button_work *);
+	int  (*depressed)(struct button_work *);
+	void (*irq_handler)(struct irq_desc *);
+	int prev_button_state;
+	u8 i2cfb_button_state;
+	struct proc_dir_entry *status_proc;
+	int  irq;
+	void (*reporter)(struct button_work *, unsigned int);
+	void (*notifier)(struct button_work *, bool);
+	void *private;
+	void *private2;
+	const u32 acpi_event_number;
+} *button_work;	/* Point to platform-specific button array. */
+
+/*
+ * acpi_ev_gpe_dispatch() checks this to see if the interrupt handling
+ * for the GPE number conflicts current button_work's own and ACPI
+ * should ignore the interrupt.
+ */
+bool readynas_ignore_acpi_event(u32 gpe_number)
+{
+	int i;
+
+	if (!button_work)
+		return false;
+	for (i = 0; button_work[i].name; i++)
+		if (button_work[i].acpi_event_number == gpe_number)
+			return true;
+	return false;
+}
+
+static inline struct button_work *work_to_button_work(struct work_struct *work)
+{
+	return container_of(work, struct button_work, worker);
+}
+
+static const char *button_type_str(struct button_work *bw)
+{
+	const char *p = "UNKWON";
+
+	switch (BUTTON_TYPE(bw)) {
+	case BUTTON_TYPE_IRQ:
+		p = "IRQ"; break;
+	case BUTTON_TYPE_POLL:
+		p = "POLL"; break;
+	case BUTTON_TYPE_THREAD:
+		p = "THREAD"; break;
+	case BUTTON_TYPE_I2CFB:
+		p = "I2CFB"; break;
+	default:
+		break;
+	}
+	return p;
+}
+
+static inline int button_gpio_depressed(struct button_work *bw)
+{
+	return gpiod_get_value(bw->gpio_desc);
+}
+
+static inline int button_depressed(struct button_work *bw)
+{
+	return bw->depressed ?  bw->depressed(bw) : button_gpio_depressed(bw);
+}
+
+static void button_reporter(struct button_work *bw, unsigned int state)
+{
+	if (bw->reporter)
+		bw->reporter(bw, state);
+	else {
+		if (bw->input_dev) {
+			input_event(bw->input_dev, EV_KEY, bw->key, !!state);
+			input_sync(bw->input_dev);
+		}
+		if (bw->notifier)
+			bw->notifier(bw, !!state);
+	}
+}
+
+static void button_worker(struct work_struct *work)
+{
+	struct button_work *bw = work_to_button_work(work);
+
+	if (!(bw->type & BUTTON_TYPE_NOBOUNCE))
+		msleep_interruptible(10);
+
+	if (button_depressed(bw) > 0) {
+		button_reporter(bw, 1);
+		while (button_depressed(bw) > 0)
+			msleep_interruptible(10);
+		button_reporter(bw, 0);
+	}
+	bw->busy = false;
+}
+
+#if 0	/* Used only by retired ACPI handler. */
+static void schedule_button_work(unsigned int button)
+{
+	struct button_work *bw;
+
+	for (bw = button_work; bw->name; bw++) {
+		if (bw->button != button || !bw->depressed)
+			continue;
+		else if (bw->busy || button_depressed(bw) <= 0)
+			return;
+
+		bw->busy = true;
+		switch (BUTTON_TYPE(bw)) {
+		case BUTTON_TYPE_IRQ:
+			schedule_work(&bw->worker);
+			break;
+		case BUTTON_TYPE_THREAD:
+			button_worker(&bw->worker);
+			break;
+		default:
+			break;
+		}
+		return;
+	}
+}
+#endif
+
+static int setup_gpio_input(struct button_work *bw)
+{
+	int err;
+	struct gpio_desc *gd;
+	struct gpio_chip *gc = rn_gpiochip_find_by_label(bw->gpio_label);
+
+	if (IS_ERR_OR_NULL(gc)) {
+		pr_err("%s: cannot find button GPIO %s.\n",
+					__func__, bw->gpio_label);
+		return gc ? PTR_ERR(gc) : -ENODEV;
+	}
+
+	gd = gpiochip_get_desc(gc, bw->gpio_num);
+	if (IS_ERR_OR_NULL(gd)) {
+		pr_err("%s: cannot find button GPIO %s:%d.\n",
+			 __func__, bw->gpio_label, bw->gpio_num);
+		return gd ? PTR_ERR(gd) : -ENODEV;
+	}
+
+	if (bw->gpio_active_low)
+		set_bit(FLAG_ACTIVE_LOW, &gd->flags);
+	err = gpiod_direction_input(gd);
+	if (err) {
+		pr_err("%s: failed to set GPIO %s:%d to input (%d).\n",
+			 __func__, bw->gpio_label, bw->gpio_num, err);
+		return err;
+	}
+	bw->gpio_desc = gd;
+	return 0;
+}
+
+#if 0	/* Retired. */
+/*
+ * ACPI event based button handling.
+ */
+static void acpi_notify(struct acpi_device *device, u32 button)
+{
+	schedule_button_work(MK_BUTTON(ACPI, button));
+}
+
+static inline int acpi_add(struct acpi_device *device) { return 0; }
+static inline int acpi_remove(struct acpi_device *device) { return 0; }
+static const struct acpi_device_id button_device_ids[] = {
+	{ "ACPI0006", 0 },
+	{},
+};
+
+static struct acpi_driver acpi_driver = {
+	.name = "ACPI Button",
+	.class = "Button",
+	.ids = button_device_ids,
+	.ops = {
+		.add = acpi_add,
+		.remove = acpi_remove,
+		.notify = acpi_notify,
+	},
+};
+
+static int acpi_driver_registgered;
+static int button_acpi_init(struct button_work *bw)
+{
+	int err = 0;
+
+	pr_info("%s: installing ACPI button notifier for '%s'\n",
+		__func__, bw->name);
+	if (!acpi_driver_registgered)
+		err = acpi_bus_register_driver(&acpi_driver);
+	if (!err)
+		acpi_driver_registgered++;
+	return 0;
+}
+
+static void button_acpi_exit(struct button_work *bw)
+{
+	if (!--acpi_driver_registgered)
+		acpi_bus_unregister_driver(&acpi_driver);
+}
+#endif
+
+/*
+ * Interrupt-driven button worker
+ */
+static void button_worker_irq_ack(struct work_struct *work)
+{
+	struct button_work *bw = work_to_button_work(work);
+	struct irq_data *d = irq_get_irq_data(bw->irq);
+
+	button_worker(work);
+	d->chip->irq_ack(d);
+}
+
+static void button_irq_handler(struct irq_desc *desc)
+{
+	struct irq_data *d	= irq_desc_get_irq_data(desc);
+	struct button_work *bw	= irq_data_get_irq_handler_data(d);
+
+	bw->busy = true;
+	schedule_work(&bw->worker);
+}
+
+static void button_irq_handler_ack(struct irq_desc *desc)
+{
+	struct irq_data *d	= irq_desc_get_irq_data(desc);
+
+	button_irq_handler(desc);
+	d->chip->irq_ack(d);
+}
+
+static void button_irq_exit(struct button_work *bw)
+{
+	struct gpio_chip *gc = rn_gpiochip_find_by_label(bw->gpio_label);
+
+	if (gpiochip_line_is_irq(gc, bw->gpio_num)) {
+		gpiochip_relres_irq(gc, bw->gpio_num);
+	}
+
+	irq_set_irq_type(bw->irq, IRQ_TYPE_NONE);
+	irq_set_chained_handler_and_data(bw->irq, NULL, NULL);
+	bw->gpio_desc = NULL;
+}
+
+static int button_irq_init(struct button_work *bw)
+{
+	struct gpio_chip *gc = rn_gpiochip_find_by_label(bw->gpio_label);
+	int virq = gpio_to_irq(gc->base + bw->gpio_num);
+	int err;
+
+	if (virq < 0) {
+		pr_err("%s: Bad GPIO# (%u+%u)\n",
+			__func__, gc->base, bw->gpio_num);
+		return virq;
+	}
+
+	if (!gpiochip_line_is_irq(gc, bw->gpio_num)) {
+		if ((err = gpiochip_reqres_irq(gc, bw->gpio_num))) {
+			return err;
+		}
+	}
+
+	irq_set_chained_handler_and_data(virq,
+		bw->irq_handler ? bw->irq_handler : button_irq_handler, bw);
+	if ((err = irq_set_irq_type(virq, bw->irq_type)))
+		irq_set_chained_handler_and_data(virq, NULL, NULL);
+	else
+		bw->irq = virq;
+
+	return err;
+}
+
+static struct button_work button_work_rnx220[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 1,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_IRQ,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.acpi_event_number	= 0x11,
+	},
+#if 0	/* Not working */
+	{
+		.name = "uid",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 52,
+		.gpio_active_low	= false,
+		.type	= BUTTON_TYPE_POLL,
+		.button = MK_BUTTON(ACPI, 177),
+	},
+#endif
+	{}
+};
+
+static struct button_work button_work_rn314[] = {
+	{
+		.name		= "backup",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 4,
+		.gpio_active_low	= 1,
+		.key	= KEY_COPY,
+		.button	= BUTTON_BACKUP,
+		.type	= BUTTON_TYPE_IRQ,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.acpi_event_number	= 0x1b,
+	},
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 5,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_IRQ,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.acpi_event_number	= 0x15,
+	}, {}
+};
+
+static struct button_work button_work_rn316[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 5,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_IRQ,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.acpi_event_number	= 0x15,
+	}, {}
+};
+
+static struct button_work button_work_rn516[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 1,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_IRQ,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+		.irq_handler	= button_irq_handler_ack,
+	}, {}
+};
+
+/*
+ * Ultra2/4/6 GPIO poll-base button handler
+ */
+static struct button_work button_work_ultra2_4[] = {
+	{
+		.name		= "backup",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 4,
+		.gpio_active_low	= 1,
+		.key	= KEY_COPY,
+		.button	= BUTTON_BACKUP,
+		.type	= BUTTON_TYPE_POLL,
+	},
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 5,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_POLL,
+	}, {}
+};
+
+static struct button_work button_work_ultra6[] = {
+	{
+		.name		= "backup",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 15,
+		.gpio_active_low	= 1,
+		.key	= KEY_COPY,
+		.button	= BUTTON_BACKUP,
+		.type	= BUTTON_TYPE_POLL,
+	},
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 8,
+		.gpio_active_low	= 1,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_POLL,
+	}, {}
+};
+
+static struct button_work button_work_pro6[] = {
+	{
+		.name		= "backup",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 15,
+		.gpio_active_low	= 0,
+		.key	= KEY_COPY,
+		.button	= BUTTON_BACKUP,
+		.type	= BUTTON_TYPE_POLL,
+	},
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 8,
+		.gpio_active_low	= 0,
+		.key	= KEY_RESTART,
+		.button	= BUTTON_RESET,
+		.type	= BUTTON_TYPE_POLL,
+	}, {}
+};
+
+
+static struct button_work button_work_rn313x[] = {
+	{/* GP77 cannot generate IRQ. */
+		.name 		= "uid",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 55,	/* a.k.a. "GP77" */
+		.button		= BUTTON_UID,
+		.type		= BUTTON_TYPE_POLL,
+	},
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 21,	/* a.k.a. "GP35" */
+		.gpio_active_low	= 1,
+		.key		= KEY_RESTART,
+		.type		= BUTTON_TYPE_IRQ | BUTTON_TYPE_NOBOUNCE,
+		.irq_type	= IRQ_TYPE_EDGE_FALLING,
+		.init		= button_irq_init,
+		.exit		= button_irq_exit,
+		.worker_to_set	= button_worker_irq_ack,
+	}, {}
+};
+
+static const struct common_init_exit {
+	char *name;
+	enum button_event_type type;
+	int  (*init)(struct button_work *);
+	void (*exit)(struct button_work *);
+} gpio_init_exit[] = {
+	{
+		.name	= "gpio_ich",
+		.type	= BUTTON_TYPE_IRQ_I2CFB,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+	},
+	{
+		.name	= "gpio_dnv.0",
+		.type	= BUTTON_TYPE_IRQ_I2CFB,
+		.init	= button_irq_init,
+		.exit	= button_irq_exit,
+	}, {}
+};
+
+static const struct common_init_exit
+*gpio_init_exit_find(const struct button_work *bw)
+{
+	const struct common_init_exit *gie = gpio_init_exit;
+
+	for (; gie->name; gie++)
+		if (!strcmp(gie->name, bw->gpio_label) && gie->type == bw->type)
+			return gie;
+	return NULL;
+}
+
+/*
+ * RN42[2468]/[56]2[468] Front Board button handler.
+ */
+#define I2CFB_I2C_CHIPADDR	0x1c
+
+#define I2CFB_ID		0x0
+#define I2CFB_LED_STATE		0x1
+#define I2CFB_LED_BRIGHTNESS	0x2
+#define I2CFB_BUTTON_EVENT	0x3
+#define I2CFB_BUTTON_STATE	0x4
+#define I2CFB_BUTTON_EVENT_MASK	0x5
+
+/*
+ * Compare current I2c reading with previous one.
+ */
+static void i2cfb_reporter(struct button_work *bw, unsigned int state)
+{
+	u8 diff;
+	struct button_work *sw;
+	int i2cret = i2c_smbus_read_byte_data((struct i2c_client *)bw->private2,
+						I2CFB_BUTTON_STATE);
+	if (i2cret < 0)
+		return;
+
+	if (!(diff = bw->i2cfb_button_state ^ (i2cret & 0xff)))
+		return;
+
+	for (sw = bw->private; sw->name; sw++) {
+		u8 button_mask = (1 << sw->gpio_num);
+
+		if (diff & button_mask)
+			button_reporter(sw, !!(i2cret & button_mask));
+	}
+
+	bw->i2cfb_button_state = i2cret;
+}
+
+/*
+ * FB button processor scheduled by GPIO2 IRQ.
+ */
+static void button_worker_i2cfb(struct work_struct *work)
+{
+	button_reporter(work_to_button_work(work), 1);
+}
+
+static int i2cfb_button_depressed(struct button_work *sw)
+{
+	struct button_work *bw = sw->private;
+	int i2cret = i2c_smbus_read_byte_data((struct i2c_client *)bw->private2,
+						I2CFB_BUTTON_STATE);
+	if (i2cret < 0)
+		return i2cret;
+	return !!(i2cret & (1 << sw->gpio_num));
+}
+
+/*
+ * GPIO IRQ handler FB button events.
+ * Accessing I2c may sleep. Schedule work for processing.
+ * FB button events flip GPIO2 signal. Prepare for next event by inverting
+ * GPIO IRQ polarity.
+ */
+static void i2cfb_exit(struct button_work *bw)
+{
+	const struct common_init_exit *gie = gpio_init_exit_find(bw);
+
+	if (gie && gie->exit)
+		gie->exit(bw);
+
+	if (!IS_ERR_OR_NULL(bw->private2))
+		i2c_unregister_device((struct i2c_client *)bw->private2);
+	bw->private2 = NULL;
+}
+
+static int i2cfb_init(struct button_work *bw)
+{
+	int err;
+	struct i2c_adapter *adapter;
+	struct i2c_client *client;
+	const struct common_init_exit *gie;
+
+	static struct i2c_board_info i2cfb_i2c_info = {
+		I2C_BOARD_INFO("i2cfb", I2CFB_I2C_CHIPADDR),
+	};
+
+	pr_info("%s: initializing I2C FB buttons %s:%d (%s)\n",
+		__func__, bw->gpio_label, bw->gpio_num, button_type_str(bw));
+
+	err = setup_gpio_input(bw);
+	if (err) {
+		pr_err("%s: failed to set up GPIO input.\n", __func__);
+		return err;
+	}
+
+	pr_info("%s: I2C adapter/chip addr %s/0x%x\n",
+		__func__, rn_i2c_adapters_ipch[0], I2CFB_I2C_CHIPADDR);
+	adapter = readynas_i2c_adapter_find(rn_i2c_adapters_ipch);
+	if (IS_ERR_OR_NULL(adapter)) {
+		pr_err("%s: failed to find I2C adapter.\n", __func__);
+		return adapter ? PTR_ERR(adapter) : -ENODEV;
+	}
+
+	client = i2c_new_client_device(adapter, &i2cfb_i2c_info);
+	if (!client) {
+		pr_err("%s: failed to allocate I2CFB client.\n", __func__);
+		return -ENOMEM;
+	}
+
+	bw->private2 = client;
+	if ((err = i2c_smbus_read_byte_data(client, I2CFB_ID)) < 0) {
+		pr_err("%s: failed to read a byte from I2C.\n", __func__);
+		goto exit;
+	}
+	if (err != 'F') {
+		pr_err("%s: ID='%02x' mismatches Front Board.", __func__, err);
+		err = -ENODEV;
+		goto exit;
+	}
+
+	if ((err = i2c_smbus_write_byte_data(client,
+						I2CFB_LED_BRIGHTNESS, 15))) {
+		pr_err("%s: failed to write a byte to I2C.\n", __func__);
+		goto exit;
+	}
+
+	if ((err = i2c_smbus_read_byte_data(client, I2CFB_BUTTON_STATE)) < 0) {
+		pr_err("%s: failed to read a byte from I2C.\n", __func__);
+		goto exit;
+	}
+	bw->i2cfb_button_state = err & 0xff;
+	if ((err = i2c_smbus_write_byte_data(client,
+						I2CFB_BUTTON_EVENT_MASK, 0))) {
+		pr_err("%s: failed to write a byte to I2C.\n", __func__);
+		goto exit;
+	}
+
+	if ((gie = gpio_init_exit_find(bw)) && gie->init)
+		err = gie->init(bw);
+exit:
+	if (err)
+		i2cfb_exit(bw);
+	return err;
+}
+
+static struct button_work button_work_i2cfb[] = {
+	{
+		.name		= "left",
+		.gpio_num	= 0,	/* BUTTON_STATE bit number */
+		.key		= KEY_LEFT,
+		.type		= BUTTON_TYPE_I2CFB,
+		.input_dev_name	= "fb_button",
+		.depressed	= i2cfb_button_depressed,
+	}, {
+		.name		= "right",
+		.gpio_num	= 1,	/* BUTTON_STATE bit number */
+		.key		= KEY_RIGHT,
+		.type		= BUTTON_TYPE_I2CFB,
+		.input_dev_name	= "fb_button",
+		.depressed	= i2cfb_button_depressed,
+	}, {
+		.name		= "up",
+		.gpio_num	= 2,	/* BUTTON_STATE bit number */
+		.key		= KEY_UP,
+		.type		= BUTTON_TYPE_I2CFB,
+		.input_dev_name	= "fb_button",
+		.depressed	= i2cfb_button_depressed,
+	}, {
+		.name		= "down",
+		.gpio_num	= 3,	/* BUTTON_STATE bit number */
+		.key		= KEY_DOWN,
+		.type		= BUTTON_TYPE_I2CFB,
+		.input_dev_name	= "fb_button",
+		.depressed	= i2cfb_button_depressed,
+	}, {
+		.name		= "ok",
+		.gpio_num	= 4,	/* BUTTON_STATE bit number */
+		.key		= KEY_OK,
+		.type		= BUTTON_TYPE_I2CFB,
+		.input_dev_name	= "fb_button",
+		.depressed	= i2cfb_button_depressed,
+	}, {}
+};
+
+static struct button_work button_work_rn42x[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 9,	/* a.k.a. "GP21" */
+		.gpio_active_low	= 1,
+		.key		= KEY_RESTART,
+		.type		= BUTTON_TYPE_IRQ | BUTTON_TYPE_NOBOUNCE,
+		.irq_type	= IRQ_TYPE_EDGE_FALLING,
+		.init		= button_irq_init,
+		.exit		= button_irq_exit,
+		.worker_to_set	= button_worker_irq_ack,
+	}, {
+		.name		= "front-board",
+		.gpio_label	= "gpio_dnv.0",
+		.gpio_num	= 5,
+		.type		= BUTTON_TYPE_IRQ_I2CFB,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init		= i2cfb_init,
+		.exit		= i2cfb_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.reporter	= i2cfb_reporter,
+		.private	= &button_work_i2cfb,
+		.worker_to_set	= button_worker_i2cfb,
+	}, {}
+};
+
+static struct button_work button_work_rn526[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 23,	/* a.k.a. "GP37" */
+		.gpio_active_low	= 1,
+		.key		= KEY_RESTART,
+		.type		= BUTTON_TYPE_IRQ | BUTTON_TYPE_NOBOUNCE,
+		.irq_type	= IRQ_TYPE_EDGE_FALLING,
+		.init		= button_irq_init,
+		.exit		= button_irq_exit,
+		.worker_to_set	= button_worker_irq_ack,
+	}, {
+		.name		= "front-board",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= 2,
+		.type		= BUTTON_TYPE_IRQ_I2CFB,
+		.irq_type	= IRQ_TYPE_EDGE_BOTH,
+		.init		= i2cfb_init,
+		.exit		= i2cfb_exit,
+		.irq_handler	= button_irq_handler_ack,
+		.reporter	= i2cfb_reporter,
+		.private	= &button_work_i2cfb,
+		.worker_to_set	= button_worker_i2cfb,
+	}, {}
+};
+
+static struct button_work button_work_rr23xx[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 9,	/* a.k.a. "GP21" */
+		.gpio_active_low	= 1,
+		.key		= KEY_RESTART,
+		.type		= BUTTON_TYPE_IRQ | BUTTON_TYPE_NOBOUNCE,
+		.irq_type	= IRQ_TYPE_EDGE_FALLING,
+		.init		= button_irq_init,
+		.exit		= button_irq_exit,
+		.worker_to_set	= button_worker_irq_ack,
+	}, {}
+};
+
+/*
+ * RR[34]312 buttons
+ */
+#ifdef CONFIG_RRx312_60_UID_BUTTON
+/* RRx312/4360 have no UID button installed, Not tested. */
+extern void *rnled_get_info(const char *);
+extern int rnled_toggle(void *);
+static void notifier_rnx312_uid_led_toggle(struct button_work *bw,
+						bool depressed)
+{
+	if (depressed) {
+		if (!bw->private)
+			bw->private = rnled_get_info("readynas:blue:uid");
+		if (bw->private)
+			rnled_toggle(bw->private);
+	}
+}
+#endif
+
+static struct button_work button_work_rrx312_60[] = {
+	{
+		.name		= "reset",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 31,	/* a.k.a. "GP47" */
+		.gpio_active_low	= 1,
+		.key		= KEY_RESTART,
+		.type		= BUTTON_TYPE_IRQ | BUTTON_TYPE_NOBOUNCE,
+		.irq_type	= IRQ_TYPE_EDGE_FALLING,
+		.init		= button_irq_init,
+		.exit		= button_irq_exit,
+		.worker_to_set	= button_worker_irq_ack,
+	},
+#ifdef	CONFIG_RRx312_60_UID_BUTTON
+	/* RRx312/4360 have no UID button installed, Not tested. */
+	{
+		.name		= "uid",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 49,	/* a.k.a. "GP71" */
+		.gpio_active_low	= 0,
+		.key		= KEY_FIND,
+		.type		= BUTTON_TYPE_POLL,
+		.notifier	= notifier_rnx312_uid_led_toggle,
+	},
+#endif
+	{}
+};
+
+/*
+ * Array of compatible button handlers.
+ * Generic button state API.
+ */
+static struct button_set {
+	const char *compatible;
+	struct button_work *button_work;
+} button_set[] = {
+	{ "ultra2",	button_work_ultra2_4 },
+	{ "ultra4",	button_work_ultra2_4 },
+	{ "ultra6",	button_work_ultra6 },
+	{ "pro6",	button_work_pro6 },
+	{ "rn312",	button_work_rn314 },
+	{ "rn314",	button_work_rn314 },
+	{ "rn316",	button_work_rn316 },
+	{ "rn42x",	button_work_rn42x },
+	{ "rnx16",	button_work_rn516 },
+	{ "rnx2x",	button_work_rn526 },
+	{ "rr23xx",	button_work_rr23xx },
+	{ "rn313x",	button_work_rn313x },
+	{ "rnx220",	button_work_rnx220 },
+	{ "rrx312_60",	button_work_rrx312_60 },
+	{}
+};
+
+static int button_state_show(struct seq_file *s, void *v)
+{
+	struct button_work *bw = s->private;
+
+	seq_printf(s, "%d\n", button_depressed(bw));
+	return 0;
+}
+
+static int button_state_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, button_state_show, pde_data(inode));
+}
+
+static const struct proc_ops button_state_proc_fop = {
+	.proc_open	= button_state_proc_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int create_button_state_proc(struct button_work *bw)
+{
+	int err;
+	char name[strlen(bw->name) + strlen("-button") + 2];
+
+	snprintf(name, sizeof name, "%s-button", bw->name);
+	bw->status_proc = readynas_proc_create(name, 0444,
+						&button_state_proc_fop, bw);
+	err = bw->status_proc ? 0 : -EIO;
+	if (err)
+		pr_err("%s: failed to create procfs %s\n", __func__, name);
+	return err;
+}
+
+/*
+ * Polling mode button handler kthread
+ */
+#define POLL_INTERVAL_MIN	50
+#define POLL_INTERVAL_MAX	200
+static unsigned int	poll_interval = POLL_INTERVAL_MIN;
+static struct mutex	poller_lock;
+static struct task_struct	*poller_kthread;
+
+static int button_thread_show(struct seq_file *s, void *v)
+{
+	mutex_lock(&poller_lock);
+	seq_printf(s, "%u\n", poller_kthread ? poller_kthread->pid : 0);
+	mutex_unlock(&poller_lock);
+	return 0;
+}
+
+static int button_poller(void *data)
+{
+	while (!kthread_should_stop()) {
+		struct button_work *bw;
+
+		for (bw = data; bw->name; bw++) {
+			int state;
+
+			if (BUTTON_TYPE(bw) != BUTTON_TYPE_POLL ||
+				(state = button_depressed(bw)) ==
+					bw->prev_button_state)
+				continue;
+			if (!(bw->type & BUTTON_TYPE_NOBOUNCE)) {
+				msleep_interruptible(10);
+				if ((state = button_depressed(bw)) ==
+						bw->prev_button_state)
+					continue;
+			}
+			button_reporter(bw, state);
+			bw->prev_button_state = state;
+		}
+		msleep_interruptible(poll_interval);
+	}
+	return 0;
+}
+
+static int button_poller_start(void)
+{
+	int err = 0;
+
+	mutex_lock(&poller_lock);
+	if (!poller_kthread) {
+		poller_kthread = kthread_run(button_poller, button_work,
+						"readynas-button");
+		if (IS_ERR(poller_kthread)) {
+			err = -ENOMEM;
+			poller_kthread = NULL;
+		}
+	}
+	mutex_unlock(&poller_lock);
+	return err;
+}
+
+static void button_poller_stop(void)
+{
+	mutex_lock(&poller_lock);
+	if (poller_kthread) {
+		kthread_stop(poller_kthread);
+		poller_kthread = NULL;
+	}
+	mutex_unlock(&poller_lock);
+}
+
+static ssize_t button_thread_write(struct file *file, const char __user *buffer,
+					size_t count, loff_t *off)
+{
+	size_t size = min_t(size_t, count, 10);
+	char buf[size];
+	unsigned int val;
+
+	copy_from_user(buf, buffer, size - 1);
+	buf[size - 1] = '\0';
+	if (kstrtouint(buf, 0, &val) < 0)
+		return -EINVAL;
+
+	if (val) {
+		if (val < POLL_INTERVAL_MIN)
+			val = POLL_INTERVAL_MIN;
+		if (val > POLL_INTERVAL_MAX)
+			val = POLL_INTERVAL_MAX;
+		poll_interval = val;
+		button_poller_start();
+	} else
+		button_poller_stop();
+	return count;
+}
+
+static int button_thread_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, button_thread_show, pde_data(inode));
+}
+
+static const struct proc_ops button_thread_proc_fop = {
+	.proc_open	= button_thread_proc_open,
+	.proc_read	= seq_read,
+	.proc_write	= button_thread_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+struct proc_dir_entry *poller_proc;
+static int create_button_thread_proc(void)
+{
+	int err;
+
+	if (poller_proc)
+		return 0;
+
+	poller_proc = readynas_proc_create("button-poll", 0666,
+						&button_thread_proc_fop, NULL);
+	err = poller_proc ? 0 : -EIO;
+	if (err)
+		pr_err("%s: failed to create procfs button-poll\n", __func__);
+	return err;
+}
+
+/*
+ * Common button handler initializer/exiter
+ */
+static struct rn_input_dev {
+	struct input_dev *dev;
+	const char *name;
+	const u16 bustype;
+} rn_input_devs[] = {
+	{
+		.name		= "rn_button",
+		.bustype	= BUS_HOST,
+	}, {
+		.name		= "fb_button",
+		.bustype	= BUS_HOST,
+	}, {}
+};
+
+static const char *button_input_dev_name(struct button_work *bw)
+{
+	return (bw->input_dev && bw->input_dev->name) ?
+					bw->input_dev->name : "button";
+}
+
+static void __button_exit(struct button_work *bw);
+static void __button_exit_one(struct button_work *bw)
+{
+	if (!bw)
+		return;
+	if (bw->status_proc) {
+		proc_remove(bw->status_proc);
+		bw->status_proc = NULL;
+	}
+	if (BUTTON_TYPE_IS_IRQ(bw))
+		cancel_work_sync(&bw->worker);
+	if (bw->type & BUTTON_TYPE_SUBWORK)
+		__button_exit((struct button_work *)bw->private);
+
+	if (bw->exit)
+		bw->exit(bw);
+}
+
+static void __button_exit(struct button_work *bw)
+{
+	while (bw->name)
+		__button_exit_one(bw++);
+}
+
+static void button_exit(void)
+{
+	int i;
+
+	if (!button_work)
+		return;
+
+	if (poller_proc) {
+		proc_remove(poller_proc);
+		poller_proc = NULL;
+	}
+
+	button_poller_stop();
+
+	__button_exit(button_work);
+
+	for (i = 0; rn_input_devs[i].name; i++)
+		if (rn_input_devs[i].dev) {
+			input_unregister_device(rn_input_devs[i].dev);
+			input_free_device(rn_input_devs[i].dev);
+			rn_input_devs[i].dev = NULL;
+		}
+}
+
+static int rn_set_button(struct button_work *bw)
+{
+	const char *name = bw->input_dev_name ?
+				bw->input_dev_name : "rn_button";
+	struct rn_input_dev *idev;
+
+	for (idev = rn_input_devs;
+		idev->name && strcmp(idev->name, name); idev++)
+		;
+
+	if (!idev->name) {
+		pr_err("%s: Bad button input device name %s.\n", __func__,name);
+		WARN_ON(1);
+		return -ENODEV;
+	}
+
+	if (!idev->dev) {
+		idev->dev = input_allocate_device();
+		if (!idev->dev) {
+			pr_err("%s: failed to allocate an input device.\n",
+				__func__);
+			return -ENOMEM;
+		}
+		idev->dev->name = idev->name;
+		idev->dev->id.bustype = idev->bustype;
+	}
+
+	bw->input_dev = idev->dev;
+	input_set_capability(bw->input_dev, EV_KEY, bw->key);
+	return 0;
+}
+
+static int __button_init(struct button_work *base, struct button_work *parent)
+{
+	int err = 0, success = 0;
+	struct button_work *bw;
+	bool start_poller = false;
+
+	for (bw = base; bw->name; bw++) {
+		if (parent)
+			bw->private = parent;
+
+		if (bw->gpio_label) {
+			pr_info("%s: %s '%s' %s:%d%s (%s)\n", __func__,
+				button_input_dev_name(bw),
+				bw->name,
+				bw->gpio_label, bw->gpio_num,
+				bw->gpio_active_low ? "n" : "",
+				button_type_str(bw));
+			err = setup_gpio_input(bw);
+			if (err) {
+				pr_err("%s: cannot find button GPIO %s:%d\n",
+					 __func__,
+					bw->gpio_label, bw->gpio_num);
+				continue;
+			}
+		} else
+			pr_info("%s: %s '%s' (%s)\n", __func__,
+				button_input_dev_name(bw),
+				bw->name, button_type_str(bw));
+
+		if (BUTTON_TYPE_IS_IRQ(bw))
+			INIT_WORK(&bw->worker,
+				bw->worker_to_set ?
+					bw->worker_to_set : button_worker);
+
+		/* This must come after GPIO attaching and worker init
+		 * to avoid race.
+		 */
+		if (bw->init && (err = bw->init(bw))) {
+			pr_err("%s: failed to initialize button '%s' (%d).\n",
+				__func__, bw->name, err);
+			continue;
+		}
+
+		bw->prev_button_state = button_depressed(bw);
+
+		/* If button has subwork(s), call recursively. */
+		if (bw->type & BUTTON_TYPE_SUBWORK)
+			err = __button_init(
+				(struct button_work *)bw->private, bw);
+		else {
+			if ((err = create_button_state_proc(bw)))
+				goto exit;
+			if ((err = rn_set_button(bw)))
+				goto exit;
+		}
+exit:
+		if (err) {
+			pr_err("%s: failed to set up button worker %s (%d).\n",
+				__func__, bw->name, err);
+			continue;
+		}
+
+			/* Must be delayed until all buttons get ready. */
+		if (BUTTON_TYPE(bw) == BUTTON_TYPE_POLL)
+			start_poller = true;
+		else if (BUTTON_TYPE_IS_IRQ(bw))
+			pr_info("%s '%s' IRQ#%d\n",
+				button_input_dev_name(bw), bw->name, bw->irq);
+		success++;
+	}
+
+	if (!success)
+		return err;
+
+	/* Delayed starting of button poller thread - avoid race. */
+	if (start_poller && (err = button_poller_start()))
+		return err;
+
+	if ((err = create_button_thread_proc())) {
+		proc_remove(poller_proc);
+		poller_proc = NULL;
+		button_poller_stop();
+	}
+
+	return err;
+}
+
+static int button_init(void)
+{
+	int err, i;
+	struct button_set *bs =
+			__compatible_find(button_set, compatible, 0, "");
+
+	pr_info("%s: initializing ReadyNAS button set.\n", __func__);
+	button_work = &bs->button_work[0];
+
+	if ((err = __button_init(button_work, NULL)))
+		return err;
+
+	/* Delayed input_dev registration after all buttons added. */
+	for (i = 0; rn_input_devs[i].name; i++)
+		if (rn_input_devs[i].dev &&
+			(err = input_register_device(rn_input_devs[i].dev))) {
+			pr_err("%s: failed to install button input class device"
+				" %s.\n", __func__, rn_input_devs[i].name);
+			input_free_device(rn_input_devs[i].dev);
+			rn_input_devs[i].dev = NULL;
+			button_exit();
+			return err;
+		}
+
+	return 0;
+}
+
+/*
+ * PWR button status procfs handling
+ */
+#define	MK_ADDR_BIT_GPIO_NUM(a, b)	(((a)<<16)|(b))
+#define	BK_ADDR_GPIO_NUM(bw)		((bw)->gpio_num >>16)
+#define	BK_BIT_GPIO_NUM(bw)		BIT((bw)->gpio_num & 0xffff)
+
+static int locate_acpi_devs(struct button_work *bw,
+				struct platform_device **pdevp,
+				struct pci_dev **pci_devp)
+{
+	struct device *dev;
+	struct gpio_chip *gc = rn_gpiochip_find_by_label(bw->gpio_label);
+
+	if (!gc || !(dev = gc->parent)) {
+		pr_err("%s: failed to find GPIO %s.\n",
+			__func__, bw->gpio_label);
+		return -ENODEV;
+	}
+
+	if (pdevp)
+		*pdevp = container_of(dev, struct platform_device, dev);
+	if (pci_devp)
+		*pci_devp = container_of(dev->parent, struct pci_dev, dev);
+	return ((*pci_devp)->vendor && (*pci_devp)->device) ? 0 : -ENODEV;
+}
+
+static int pwr_button_depressed_mmio(struct button_work *bw)
+{
+	unsigned long offset = BK_ADDR_GPIO_NUM(bw);
+	unsigned long base = (unsigned long)bw->private + (offset & PAGE_MASK);
+	void __iomem *p = ioremap(base, PAGE_SIZE);
+	int pressed =
+		!!(*(u32 *)(p + (offset % PAGE_SIZE)) & BK_BIT_GPIO_NUM(bw));
+
+	iounmap(p);
+	return bw->gpio_active_low ? !pressed : pressed;
+}
+
+static int __init pwr_button_init_mmio_by_pci(struct button_work *bw)
+{
+	struct pci_dev *pci_dev;
+	u32 pm_base;
+	int err = locate_acpi_devs(bw, NULL, &pci_dev);
+
+	if (err)
+		return err;
+
+	/* Get PM base address */
+	pci_read_config_dword(pci_dev, (unsigned long)bw->private2, &pm_base);
+	pm_base &= PCI_BASE_ADDRESS_IO_MASK;
+	if (!pm_base) {
+		pr_err("%s: failed to get pm base.", __func__);
+		return -ENODEV;
+	}
+
+	bw->private = (void *)(unsigned long)pm_base;
+	return 0;
+}
+
+static int pwr_button_depressed_pci(struct button_work *bw)
+{
+	struct pci_dev *pci_dev = bw->private;
+	u32 pmcon;
+	int pressed;
+
+	pci_read_config_dword(pci_dev, BK_ADDR_GPIO_NUM(bw), &pmcon);
+	pressed = !!(pmcon & BK_BIT_GPIO_NUM(bw));
+	return bw->gpio_active_low ? !pressed : pressed;
+}
+
+static int __init pwr_button_init_pci(struct button_work *bw)
+{
+	struct pci_dev *pci_dev = NULL;
+	int err = -ENODEV;
+
+	if (bw->gpio_label)
+		err = locate_acpi_devs(bw, NULL, &pci_dev);
+	else if (bw->private2) {
+		pci_dev = pci_get_device(PCI_VENDOR_ID_INTEL,
+					(unsigned long)bw->private2, NULL);
+		if (pci_dev)
+			err = 0;
+	}
+
+	if (err)
+		return err;
+
+	bw->private = pci_dev;
+	return 0;
+}
+
+/* Here's the modified device information convention:
+ * gpio_label: if present, search for the PCI device for this GPIO.
+ * private: 1) MMIO base address set by GPIO search
+ *          2) preset MMIO base address if not for gpio_label or PCI ID
+ *          3) or PCI device pointer if register is in PCI space
+ * private2: 1) preset PCI device ID if not for gpio_label
+ *           2) or preset PCI config BAR offset if register is in PCI space
+ * gpio_num: combined PMC registger offset and bit number
+ */
+static struct button_work __refdata button_work_pwr[] = {
+	{
+#define	C2388_PMCON2		0x24
+#define	C2388_PWRBTN_LVL_BIT	9
+#define	C2388_PBASE_ADDR	0x44
+		.name		= "pwr",
+		.input_dev_name	= "rn313x",
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= MK_ADDR_BIT_GPIO_NUM(C2388_PMCON2,
+						C2388_PWRBTN_LVL_BIT),
+		.private2	= (void *)C2388_PBASE_ADDR,
+		.init		= pwr_button_init_mmio_by_pci,
+		.depressed	= pwr_button_depressed_mmio,
+		.gpio_active_low	= 1,
+	}, {
+		.name		= "pwr",
+		.input_dev_name	= "rrx312_60",
+		.gpio_label	= "gpio_it87",
+		.gpio_num	= 27,	/* a.k.a. GP43 */
+		.gpio_active_low	= 1,
+		.init		= setup_gpio_input,
+	}, {
+#define PCI_DEVICE_ID_DENVERTON	0x19de
+#define PCI_PMCON_A_DNV		0xa0
+#define PCI_PWRBTN_LVL_BIT_DNV	9
+		.name		= "pwr",
+		.input_dev_name	= "rn42x",
+		.gpio_num	= MK_ADDR_BIT_GPIO_NUM(PCI_PMCON_A_DNV,
+						PCI_PWRBTN_LVL_BIT_DNV),
+		.private2	= (void *)PCI_DEVICE_ID_DENVERTON,
+		.init		= pwr_button_init_pci,
+		.depressed	= pwr_button_depressed_pci,
+		.gpio_active_low	= 1,
+	}, {
+#define MMIO_PMCON2_APL		0x1024
+#define MMIO_PWRBTN_LVL_BIT_APL	9
+		.name		= "pwr",
+		.input_dev_name	= "rr2304",
+		.gpio_num	= MK_ADDR_BIT_GPIO_NUM(MMIO_PMCON2_APL,
+						MMIO_PWRBTN_LVL_BIT_APL),
+		.private	= (void *)0xfe042000,
+		.depressed	= pwr_button_depressed_mmio,
+		.gpio_active_low	= 1,
+	}, {/* Same Denverton as RN42x */
+		.name		= "pwr",
+		.input_dev_name	= "rr2312",
+		.gpio_num	= MK_ADDR_BIT_GPIO_NUM(PCI_PMCON_A_DNV,
+						PCI_PWRBTN_LVL_BIT_DNV),
+		.private2	= (void *)PCI_DEVICE_ID_DENVERTON,
+		.init		= pwr_button_init_pci,
+		.depressed	= pwr_button_depressed_pci,
+		.gpio_active_low	= 1,
+	}, {
+#define PCI_ICH_GEN_PMCON_1	0xa0
+#define ICH_PWRBTN_LVL_BIT	9
+		.name		= "pwr",
+		.input_dev_name	= "",	/* Wildcard for all others. */
+		.gpio_label	= "gpio_ich",
+		.gpio_num	= MK_ADDR_BIT_GPIO_NUM(PCI_ICH_GEN_PMCON_1,
+						ICH_PWRBTN_LVL_BIT),
+		.init		= pwr_button_init_pci,
+		.depressed	= pwr_button_depressed_pci,
+		.gpio_active_low	= 1,
+	}, {}
+}, *bw_pwr;
+
+static int __init pwr_button_state_init(void)
+{
+	int err = 0;
+	struct button_work *bw_pwr =
+		__compatible_find(button_work_pwr, input_dev_name, -ENODEV, "");
+
+	pr_info("%s: initializing ReadyNAS PWR button state handler %s%s.\n",
+		__func__, *bw_pwr->input_dev_name ? "for " : "",
+			bw_pwr->input_dev_name);
+
+	if (bw_pwr->init)
+		err = bw_pwr->init(bw_pwr);
+
+	if (err == -ENODEV) {
+		pr_warn("%s: No PWR button found.\n", __func__);
+		return 0;
+	} else if (err) {
+		pr_err("%s: failed for GPIO %s\n", __func__,
+			bw_pwr->gpio_label ? bw_pwr->gpio_label
+					: bw_pwr->input_dev_name);
+		return err;
+	}
+	return create_button_state_proc(bw_pwr);
+}
+
+static void pwr_button_state_exit(void)
+{
+	__button_exit_one(bw_pwr);
+}
+
+#include "sx8635.h"
+
+static int rn316_x16_local_init(void *d)
+{
+	struct i2c_adapter *adapter =
+			readynas_i2c_adapter_find((const char **)d);
+
+	if (IS_ERR_OR_NULL(adapter)) {
+		pr_err("%s: failed to find I2C adapter.\n", __func__);
+		return adapter ? PTR_ERR(adapter) : -ENODEV;
+	}
+	return sx8635_i2c_init(adapter);
+}
+
+static void rn316_x16_local_exit(void *d)
+{
+	sx8635_i2c_exit();
+}
+
+
+static struct local_init_exit {
+	const char *compatible;
+	int  (*init)(void *data);
+	void (*exit)(void *data);
+	void *data;
+}  local_init_exit_pre[] = {
+	{}
+}, local_init_exit_post[] = {
+	{	"rn316", rn316_x16_local_init, rn316_x16_local_exit,
+		rn_i2c_adapters_ipch
+	}, {	"rnx16", rn316_x16_local_init, rn316_x16_local_exit,
+		rn_i2c_adapters_ipch
+	}, {}
+};
+
+static int local_init(struct local_init_exit *lie)
+{
+	int rv = 0;
+
+	while (lie->compatible) {
+		if (readynas_io_compatible(lie->compatible) && lie->init)
+			rv |= lie->init(lie->data);
+		lie++;
+	}
+	return rv;
+}
+
+static void local_exit(struct local_init_exit *lie)
+{
+	while (lie->compatible) {
+		if (readynas_io_compatible(lie->compatible) && lie->exit)
+			lie->exit(lie->data);
+		lie++;
+	}
+}
+
+/*
+ * Common /proc/readynas entries
+ */
+static int bootmenu_show(struct seq_file *s, void *p)
+{
+	const char *key = s->private;
+	const struct dmi_device *dmi =
+		dmi_find_device(DMI_DEV_TYPE_OEM_STRING, NULL, NULL);
+
+	if (!dmi) {
+		pr_err("%s: cannot find DMI device\n", __func__);
+		return -EIO;
+	} else if (!strcmp(key, "enable"))
+		seq_printf(s, "%d\n", !memcmp(dmi->name, "Manual", 6));
+	else if (!strcmp(key, "option"))
+		seq_printf(s, "%s\n", dmi->name);
+	else {
+		pr_err("%s: invalid bootmenu key: %s", __func__, key);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int bootmenu_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, bootmenu_show, pde_data(inode));
+}
+
+static const struct proc_ops bootmenu_fop = {
+	.proc_open	= bootmenu_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int model_show(struct seq_file *s, void *p)
+{
+	const char *dmi[2];
+	int i;
+	bool printed = false;
+
+	dmi[0] = dmi_get_system_info(DMI_PRODUCT_NAME);
+	dmi[1] = dmi_get_system_info(DMI_PRODUCT_VERSION);
+
+	for (i = 0; i < ARRAY_SIZE(dmi); i++)
+		if (dmi[i] && dmi[i][0]) {
+			seq_printf(s, "%s\n", dmi[i]);
+			printed = true;
+		}
+	return printed ? 0 : -EIO;
+}
+
+static int model_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, model_show, NULL);
+}
+
+static const struct proc_ops model_fop = {
+	.proc_open	= model_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+#if 0	/* PCI register reading for debugging. */
+static int __pci_config_read(struct seq_file *s, void *p)
+{
+	int i = 0;
+	struct pci_dev *pci_dev = s->private;
+	static const char *__pci_reg[] = {
+		"Status:Command__Device ID:Vendor ID",
+		"BIST.Hdr Type.Lst Timer.Cache Line S__Class Code.Rev ID",
+		"BAR__BAR", "BAR__BAR", "BAR__BAR",
+		"Subsystem ID:Subsystem Vendor ID__Card bus CIS Ptr",
+		"Rsvd.Cap. Ptr__Expnsn ROM BAR",
+		"Max Lst.Min Gnt.Intrpt Pin.Intrpt Line__Rsvd",
+	};
+
+	seq_printf(s, "%02x.%02x:%x\n", pci_dev->bus->number,
+			PCI_SLOT(pci_dev->devfn), PCI_FUNC(pci_dev->devfn));
+	while (i < 256) {
+		u32 x, y;
+
+		pci_read_config_dword(pci_dev, i, &x);
+		pci_read_config_dword(pci_dev, i + 4, &y);
+		seq_printf(s, "[%02x]=%08x_%08x %s\n", i, y, x,
+			i/8 < ARRAY_SIZE(__pci_reg) ? __pci_reg[i/8] : "");
+		i += 8;
+	}
+	return 0;
+}
+
+static int __pci_config_read_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, __pci_config_read, pde_data(inode));
+}
+
+static const struct proc_ops __pci_config_read_fop = {
+	.proc_open	= __pci_config_read_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static struct proc_dir_entry **__pci_config_read_procs, *__pci_config_dir_proc;
+
+static void __pci_config_read_exit(void)
+{
+	int i = 0;
+
+	if (!__pci_config_read_procs)
+		return;
+	while (__pci_config_read_procs[i])
+		proc_remove(__pci_config_read_procs[i++]);
+	kfree(__pci_config_read_procs);
+	__pci_config_read_procs = NULL;
+	proc_remove(__pci_config_dir_proc);
+	__pci_config_dir_proc = NULL;
+}
+
+static int __pci_config_read_init(void)
+{
+	struct pci_dev *pci_dev = NULL;
+	int count = 0;
+
+        if (!proc_mkdir("pci", readynas_proc_root))
+		return -EIO;
+
+	for_each_pci_dev(pci_dev) {
+		char name[16];
+		struct proc_dir_entry *proc;
+
+		sprintf(name, "pci/%04x:%04x",
+				pci_dev->device, pci_dev->vendor);
+		if ((proc = readynas_proc_create(name, 0444,
+				&__pci_config_read_fop, (void *)pci_dev)))
+			if (!(__pci_config_read_procs =
+				krealloc(__pci_config_read_procs,
+		(++count + 1) * sizeof(*__pci_config_read_procs), GFP_KERNEL)))
+				return -ENOMEM;
+		__pci_config_read_procs[count - 1] = proc;
+		__pci_config_read_procs[count] = NULL;
+	}
+	return 0;
+}
+#else
+static void __pci_config_read_exit(void) {}
+static int __pci_config_read_init(void) {return 0;}
+#endif
+
+static struct proc_dir_entry
+	*proc_bootmenu_enable, *proc_bootmenu_option, *proc_model;
+
+static void procfs_exit(void)
+{
+	__pci_config_read_exit();
+	if (proc_model)
+		proc_remove(proc_model);
+	if (proc_bootmenu_option)
+		proc_remove(proc_bootmenu_option);
+	if (proc_bootmenu_enable)
+		proc_remove(proc_bootmenu_enable);
+	if (readynas_proc_root)
+		proc_remove(readynas_proc_root);
+	proc_model		= NULL;
+	proc_bootmenu_option	= NULL;
+	proc_bootmenu_enable	= NULL;
+	readynas_proc_root	= NULL;
+}
+
+static int __init procfs_init(void)
+{
+	int err = -EIO;
+	pr_info("%s: initializing ReadyNAS procfs.\n", __func__);
+
+	readynas_proc_root = proc_mkdir("readynas", NULL);
+	if (!readynas_proc_root) {
+		pr_err("%s: failed to create /proc/readynas\n", __func__);
+		return -EIO;
+	}
+	if (!(proc_bootmenu_enable =
+			readynas_proc_create("bootmenu-enable", 0444,
+				&bootmenu_fop, (void *)"enable")) ||
+		!(proc_bootmenu_option =
+			readynas_proc_create("bootmenu-option", 0444,
+				&bootmenu_fop, (void *)"option")) ||
+		!(proc_model = readynas_proc_create("model", 0444,
+				&model_fop, NULL)) ||
+		(err = __pci_config_read_init())) {
+		pr_err("%s: failed to install procfs.\n", __func__);
+		procfs_exit();
+		return err;
+	}
+	return 0;
+}
+
+static void readynas_io_exit(void)
+{
+	local_exit(local_init_exit_post);
+	button_exit();
+	pwr_button_state_exit();
+	rnx4_lcd_exit();
+	readynas_gpio_exit();
+	local_exit(local_init_exit_pre);
+	procfs_exit();
+}
+
+static int __init readynas_io_init(void)
+{
+	int ret;
+
+	pr_info("%s: initializing ReadyNAS I/O.\n", __func__);
+	mutex_init(&poller_lock);
+	if ((ret = procfs_init()))
+		return ret;
+	if ((ret = local_init(local_init_exit_pre)))
+		return ret;
+	if ((ret = readynas_gpio_init()))
+		goto fail;
+	ret |= rnx4_lcd_init();
+	ret |= pwr_button_state_init();
+	ret |= button_init();
+	ret |= local_init(local_init_exit_post);
+	pr_info("%s: initialization %s completed.\n", __func__,
+		ret ? "partially" : "successfully");
+	return 0;
+
+fail:
+	readynas_io_exit();
+	pr_err("%s: initialization failed (%d).\n", __func__, ret);
+	return ret;
+}
+
+/* This module must be loaded after GPIO and I2C. */
+device_initcall_sync(readynas_io_init);
+module_exit(readynas_io_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NETGEAR Intel I/O driver v3");
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
diff -ruN a/drivers/platform/readynas/readynas-io.h b/drivers/platform/readynas/readynas-io.h
--- a/drivers/platform/readynas/readynas-io.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-io.h	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,46 @@
+/*
+ * Common ReadyNAS IO driver definitions.
+ */
+#ifndef __READYNAS_IO_H__
+#define __READYNAS_IO_H__
+#include "../../gpio/gpiolib.h"
+#include "hd44780-lcd.h"
+
+extern struct gpio_chip *rn_gpiochip_find_by_label(const char *label);
+extern struct proc_dir_entry *readynas_proc_create(const char *name,
+				umode_t mode,
+				const struct proc_ops *fops,
+				void *data);
+
+extern int readynas_gpio_init(void);
+extern void readynas_gpio_exit(void);
+
+extern struct i2c_adapter *readynas_i2c_adapter_find(const char **name);
+
+extern const char *rn_i2c_adapters_nct677x[];
+extern const char *rn_i2c_adapters_ipch[];
+
+extern bool readynas_io_compatible(char const *nominal);
+/*
+ * Easy compatibility checking macro.
+ * @array - Array of compatible properties
+ * @member - Struct member of compatible name string
+ * @ptr - Comptible property element
+ * @rv - Return value if no compatible property element found
+ * @fmt - Error message fmt if no compatible found. Must be "" for null.
+ */
+#define	__compatible_find(array, member, rv, fmt, ...)	\
+	({	\
+		int __i;	\
+		for (__i = 0; (array)[__i].member; __i++)	\
+			if (!(array)[__i].member[0] ||		\
+				readynas_io_compatible((array)[__i].member)) \
+				break;		\
+		if (!(array)[__i].member) {	\
+			if ((rv) && *(fmt))	\
+				pr_err("%s: " fmt, __func__, ##__VA_ARGS__); \
+			return (rv);		\
+		}				\
+		&(array)[__i];			\
+	})
+#endif
diff -ruN a/drivers/platform/readynas/readynas-lcd.c b/drivers/platform/readynas/readynas-lcd.c
--- a/drivers/platform/readynas/readynas-lcd.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-lcd.c	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,507 @@
+/*
+ * readynas-lcd.c
+ *
+ * NETGEAR ReadyNAS LCD alpha numeric display driver using Hitach HD44780
+ *
+ * Copyright (c)2015-2016 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "hd44780-lcd.h"
+#ifdef CONFIG_READYNAS_LCD_PROC_INTERNAL
+#include <../fs/proc/internal.h>
+#endif
+#include <linux/ctype.h>
+#include <linux/kdebug.h>
+#include <linux/kallsyms.h>
+#include <asm/stacktrace.h>
+#include <linux/panic_notifier.h>
+
+/*#define DEBUG_LCD_PANIC_OOPS*/
+
+static struct hd44780_lcd *phys_lcd;
+
+static ssize_t LCD_proc_write(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	char buf[40], c;
+	const char *p, *pm;
+
+	if (!phys_lcd)
+		return -ENODEV;
+	if (!buffer || !count)
+		return 0;
+
+	memset(buf, 0, sizeof(buf));
+
+	if (copy_from_user(buf, buffer, min_t(size_t, count, sizeof buf) - 1))
+		return -EFAULT;
+
+	for (p = buf; *p && isspace(*p); p++)
+		;
+	if (!*p)
+		return count;
+	c = *p++;
+	if (*p && !isspace(*p))
+		return count;
+
+	mutex_lock(&phys_lcd->lcm_lock);
+	switch (c) {
+	case '0':
+		/* Clear LCD */
+		phys_lcd->clear_lcd(phys_lcd);
+		break;
+	case '1':
+	case '2': /* echo 1 \"test LCD\" */
+		/* collect strings bewteen 2 of '\"'  */
+		while (*p && *p != '"')
+			p++;
+		if (!*p)
+			break;
+		pm = ++p;
+		if (!*p)
+			break;
+
+		while (*p && *p != '"')
+			p++;
+
+		if (!*p)
+			break;
+		/* Set line; */
+		phys_lcd->set_cursor_pos(phys_lcd, c - '1', 0);
+
+		/* Put chars */
+		while (pm < p)
+			phys_lcd->data_write(phys_lcd, *pm++);
+		break;
+	case '3':
+		/* Turn on BL */
+		phys_lcd->entry_display_on(phys_lcd, 1);
+		phys_lcd->backlight_on(phys_lcd, 1);
+		break;
+	case '4':
+		/* Turn off BL */
+		phys_lcd->entry_display_on(phys_lcd, 0);
+		phys_lcd->backlight_on(phys_lcd, 0);
+		break;
+	case '7':
+		/* Set command. */
+		if (!p || !*p)
+			break;
+		while (*p && isspace(*p))
+			p++;
+		if (isxdigit(*p))
+			phys_lcd->command_write(phys_lcd,
+						simple_strtoul(p, NULL, 16));
+		break;
+	case '9':
+		phys_lcd->init(phys_lcd);
+		break;
+	default:
+		count = -EINVAL;
+		break;
+	}
+	mutex_unlock(&phys_lcd->lcm_lock);
+
+	return count;
+}
+
+static int LCDstatus_show(struct seq_file *s, void *p)
+{
+	if (!phys_lcd)
+		return -ENODEV;
+
+	seq_printf(s, "%d\n", phys_lcd->backlight_state ?
+					phys_lcd->backlight_state(phys_lcd) :
+					phys_lcd->backlight_status);
+	return 0;
+}
+
+static int LCDstatus_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, LCDstatus_show, NULL);
+}
+
+static int LCDinfo_show(struct seq_file *s, void *p)
+{
+	if (!phys_lcd)
+		return -ENODEV;
+
+	seq_printf(s, "%dx%d\n",
+			phys_lcd->lcm_num_cols, phys_lcd->lcm_num_rows);
+	return 0;
+}
+
+static int LCDinfo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, LCDinfo_show, NULL);
+}
+
+#ifdef DEBUG_LCD_PANIC_OOPS
+static ssize_t LCD_proc_panic(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	panic("%s:%d",__FILE__,__LINE__);
+	return 0;
+}
+
+static ssize_t LCD_proc_oops(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	*(int *)0 = 0;
+	return 0;
+}
+#endif
+
+static struct lcd_proc {
+	const char *name;
+	struct proc_dir_entry *proc;
+	const struct proc_ops fops;
+} lcd_procs[] = {
+	{
+		.name			= "LCD",
+		.fops.proc_write	= LCD_proc_write,
+	},
+	{
+		.name			= "LCDstatus",
+		.fops.proc_open		= LCDstatus_open,
+		.fops.proc_read		= seq_read,
+		.fops.proc_lseek	= seq_lseek,
+		.fops.proc_release	= single_release,
+	},
+	{
+		.name			= "LCDinfo",
+		.fops.proc_open		= LCDinfo_open,
+		.fops.proc_read		= seq_read,
+		.fops.proc_lseek	= seq_lseek,
+		.fops.proc_release	= single_release,
+	},
+#ifdef DEBUG_LCD_PANIC_OOPS
+	{
+		.name			= "LCDpanic",
+		.fops.proc_write	= LCD_proc_panic,
+	},
+	{
+		.name			= "LCDoops",
+		.fops.proc_write	= LCD_proc_oops,
+	},
+#endif
+	{}
+};
+
+static void __lcd_symbol_dump(unsigned long raddr)
+{
+	static char namebuf[KSYM_NAME_LEN];
+
+	unsigned long addr = (unsigned long)raddr;
+	int bufsiz = phys_lcd->lcm_num_rows * phys_lcd->lcm_num_cols;
+	char buf[bufsiz + 1];
+	const char *p = buf;
+	const char *pm = p + phys_lcd->lcm_num_cols;
+	int row;
+	unsigned long symbolsize, offset;
+	const char *symbol =
+		    kallsyms_lookup(addr, &symbolsize, &offset, NULL, namebuf);
+
+	snprintf(buf, bufsiz, "%s+%lx", symbol, offset);
+
+	phys_lcd->clear_lcd(phys_lcd);
+	phys_lcd->entry_display_on(phys_lcd, 1);
+	phys_lcd->backlight_on(phys_lcd, 1);
+
+	for (row = 0; row < phys_lcd->lcm_num_rows;
+				row++, pm += phys_lcd->lcm_num_cols) {
+		phys_lcd->set_cursor_pos(phys_lcd, row, 0);
+		while (p < pm && *p)
+			phys_lcd->data_write(phys_lcd, *p++);
+		if (!*p)
+			break;
+	}
+}
+
+static inline void lcd_symbol_dump(unsigned long addr)
+{
+#if 0
+	if (phys_lcd)
+		__lcd_symbol_dump(addr);
+#endif
+}
+
+static int lcd_panic_handler(struct notifier_block *this,
+			unsigned long event, void *data)
+{
+#if defined(CONFIG_ARM)
+	struct stackframe frame;
+	int urc;
+#elif defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	unsigned long raddrs[] = {
+		(unsigned long)__builtin_return_address(2),
+		(unsigned long)__builtin_return_address(3),
+		(unsigned long)__builtin_return_address(4),
+		(unsigned long)__builtin_return_address(5),
+		(unsigned long)__builtin_return_address(6),
+		(unsigned long)__builtin_return_address(7),
+		0UL
+	};
+	int i;
+#define ret_addr(x)	raddrs[(x)]
+#else
+#error "Unsupported architecture."
+#endif
+	unsigned long symbolsize, offset;
+	unsigned long p, p1 = (unsigned long)panic, p2 = 0;
+
+	if (test_taint(TAINT_DIE) || oops_in_progress > 1)
+		return NOTIFY_OK;
+
+	/*
+	 * Heuristically determine nesting level, i.e. depth from panic()
+	 * caller, to get the panic() caller's stack frame.
+	 */
+	/* First, obtain panic()'s text range. */
+	if (!kallsyms_lookup_size_offset(p1, &symbolsize, &offset) || offset)
+		return NOTIFY_OK;
+	for (p = p1 + 1; p < p1 + 10000; p++) {
+		if (!kallsyms_lookup_size_offset(p, &symbolsize, &offset))
+			return NOTIFY_OK;
+		/* Out of panic()'s text range (new symbol with zero offset)? */
+		if (!offset) {
+			p2 = p;
+			break;
+		}
+	}
+
+	if (!p2)
+		return NOTIFY_OK;
+	/* Next, look for level to panic(). */
+#if defined(CONFIG_ARM)
+	frame.fp = (unsigned long)__builtin_frame_address(0);
+	frame.sp = current_stack_pointer;
+	frame.lr = (unsigned long)__builtin_return_address(0);
+	frame.pc = (unsigned long)lcd_panic_handler;
+
+	while ((urc = unwind_frame(&frame)) >= 0 &&
+		(frame.pc < p1 || p2 <= frame.pc))
+			;
+
+	/* panic() caller is one level above. */
+	/* Adjust one insn size (4 bytes). */
+	if (urc >= 0 && unwind_frame(&frame) >= 0)
+		lcd_symbol_dump(frame.pc - 4);
+#elif defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	for (i = 0; ret_addr(i + 1); i++)
+		if (p1 <= ret_addr(i) && ret_addr(i) < p2)
+			break;
+
+	/* panic() caller is one level above. */
+	/* Adjust call/callq insn size (5 bytes). */
+	if (ret_addr(++i))
+		lcd_symbol_dump(ret_addr(i) - 5);
+#else
+#error "Unsupported architecture."
+#endif
+	return NOTIFY_OK;
+}
+
+static struct notifier_block lcd_panic_notifier = {
+	.notifier_call	= lcd_panic_handler,
+	.next		= NULL,
+	.priority	= 100,
+};
+
+#ifndef GET_IP
+#ifdef ARM_pc
+#define GET_IP(regs)	(regs)->ARM_pc
+#else
+#define GET_IP(regs) ((regs)->ip)
+#endif
+#endif
+
+static int lcd_die_handler(struct notifier_block *this,
+			unsigned long event, void *data)
+{
+	struct die_args *da	= data;
+
+#if defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	if (event == DIE_INT3 || event == DIE_DEBUG)
+		return NOTIFY_DONE;
+#endif
+	lcd_symbol_dump(GET_IP(da->regs));
+	return NOTIFY_OK;
+}
+
+static struct notifier_block lcd_die_notifier = {
+	.notifier_call	= lcd_die_handler,
+	.next		= NULL,
+	.priority	= 100,
+};
+
+#ifndef CONFIG_OF
+static int lcd_dev_match(struct device *dev, const void *data)
+{
+	struct hd44780_lcd *gl = dev_get_drvdata(dev);
+
+	return gl && !strncmp(gl->magic, (const char *)data, sizeof gl->magic);
+}
+#endif
+
+static int readynas_lcd_probe(struct platform_device *pdev)
+{
+	struct proc_dir_entry *parent = NULL;
+	int i;
+#ifdef CONFIG_OF
+	struct platform_device *lcd_pdev;
+	phandle phandle = 0;
+	struct device_node *np = pdev->dev.of_node, *np2;
+
+	if (!np || of_property_read_u32(np, "lcd-device", &phandle) ||
+		!(np2 = of_find_node_by_phandle(phandle)))
+		return -ENODEV;
+
+	lcd_pdev = of_find_device_by_node(np2);
+	if (IS_ERR(lcd_pdev))
+		return PTR_ERR(lcd_pdev);
+	else if (!lcd_pdev)
+		return -ENODEV;
+	phys_lcd = platform_get_drvdata(lcd_pdev);
+#else
+	struct device *phys_dev = bus_find_device(&platform_bus_type, NULL,
+					LCD_PLATFORM_MAGIC, lcd_dev_match);
+	if (!phys_dev) {
+		pr_debug("%s: platform device with \"%s\" magic not found.\n",
+			__func__, LCD_PLATFORM_MAGIC);
+		return -ENODEV;
+	}
+	phys_lcd = dev_get_drvdata(phys_dev);
+#endif
+	if (!phys_lcd)
+		return -ENODEV;
+
+	mutex_init(&phys_lcd->lcm_lock);
+
+#ifdef CONFG_READYNAS_LCD_PROC_INTERNAL
+	/* If procs internal is available, set LCD and LCDstatus under
+	 * /proc/readynas.
+	 */
+	{
+		mm_segment_t fs = get(fs);
+		struct file *f;
+
+		set_fs(get_ds());
+		f = filp_open((char __user *)"/proc/readynas", O_RDONLY, 0);
+		if (!IS_ERR(f)) {
+			parent = PDE(file_inode(f));
+			filp_close(f, NULL);
+		}
+		set_fs(fs);
+	}
+#endif
+
+	for (i = 0; lcd_procs[i].name; i++) {
+		umode_t mode = 0;
+
+		if (lcd_procs[i].fops.proc_read)
+			mode |= 0444;
+		if (lcd_procs[i].fops.proc_write)
+			mode |= 0200;
+		lcd_procs[i].proc =
+			proc_create(lcd_procs[i].name, mode, parent,
+					&lcd_procs[i].fops);
+		if (!lcd_procs[i].proc)
+			break;
+	}
+
+	if (lcd_procs[i].name) {
+		while (--i >= 0)
+			proc_remove(lcd_procs[i].proc);
+		return -EIO;
+	}
+
+	atomic_notifier_chain_register(&panic_notifier_list,
+					&lcd_panic_notifier);
+	register_die_notifier(&lcd_die_notifier);
+	return 0;
+}
+
+static int readynas_lcd_remove(struct platform_device *pdev)
+{
+	int i;
+
+	unregister_die_notifier(&lcd_die_notifier);
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					&lcd_panic_notifier);
+	for (i = 0; lcd_procs[i].name; i++)
+		proc_remove(lcd_procs[i].proc);
+	return 0;
+}
+
+static const struct of_device_id readynas_lcd_dt_ids[] = {
+	{
+		.compatible = "readynas-lcd",
+	}, {},
+};
+MODULE_DEVICE_TABLE(of, readynas_lcd_dt_ids);
+
+static struct platform_driver readynas_lcd_driver = {
+	.probe	= readynas_lcd_probe,
+	.remove	= readynas_lcd_remove,
+	.driver = {
+		.name = "readynas-lcd",
+		.of_match_table = readynas_lcd_dt_ids,
+	},
+};
+
+#ifdef CONFIG_OF
+module_platform_driver(readynas_lcd_driver);
+#else
+static struct platform_device *readynas_lcd_pdev;
+
+static int __init readynas_lcd_init(void)
+{
+	int err;
+
+	pr_info("%s: installing ReadyNAS LCD driver.\n", __func__);
+	if ((err  = platform_driver_register(&readynas_lcd_driver)))
+		return err;
+
+	readynas_lcd_pdev =
+		platform_device_register_simple(readynas_lcd_driver.driver.name,
+						-1, NULL, 0);
+	if (IS_ERR(readynas_lcd_pdev))
+		err = PTR_ERR(readynas_lcd_pdev);
+	else if (!readynas_lcd_pdev)
+		err = -ENODEV;
+	if (err) {
+		platform_driver_unregister(&readynas_lcd_driver);
+		return err;
+	} else if (!phys_lcd) {
+		platform_device_unregister(readynas_lcd_pdev);
+		platform_driver_unregister(&readynas_lcd_driver);
+		return -ENODEV;
+	} else {
+		const char str[] = "Booting..";
+		phys_lcd->set_cursor_pos(phys_lcd, 0, 0);
+		for (err = 0; err < sizeof(str)-1; err++)
+			phys_lcd->data_write(phys_lcd, str[err]);
+	}
+	return 0;
+}
+
+static void __exit readynas_lcd_exit(void)
+{
+	platform_device_unregister(readynas_lcd_pdev);
+	platform_driver_unregister(&readynas_lcd_driver);
+}
+
+/* This module must be loaded after readynas-io. */
+device_initcall_sync(readynas_lcd_init);
+module_exit(readynas_lcd_exit);
+#endif
+
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
+MODULE_DESCRIPTION("ReadyNAS LCD driver");
+MODULE_LICENSE("GPL");
diff -ruN a/drivers/platform/readynas/readynas-led.c b/drivers/platform/readynas/readynas-led.c
--- a/drivers/platform/readynas/readynas-led.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-led.c	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,977 @@
+/*
+ * LEDs driver for NETGEAR ReadyNAS x86_64 platforms
+ *
+ * Copyright (C) 2015 Justin Maggard <justin.maggard@netgear.com>
+ * Copyright (C) 2015-2017 Hiro.Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This driver provides all x86 platforms with a unified API using
+ * /sys/class/leds/readynas:color:led/func.
+ */
+
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
+#include <linux/kernel.h>
+#include <linux/dmi.h>
+#include <linux/leds.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/syscalls.h>
+#include <linux/spinlock.h>
+#include <linux/libata.h>
+#include <scsi/scsi_host.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/kthread.h>
+#include "readynas-io.h"
+
+struct rnled_proc;
+static struct rnled_info {
+	const	char *name;
+		u16  num;		/* GPIO port number */
+	const	struct rnled_proc *proc;
+	const	u8   active_low;	/* Bit#0: primary, Bit#1: secondary */
+	const	int  init_state;	/* -1 for off, 1 for on, 0 for as-is. */
+	const	char *trigger;
+	void	*desc;
+	void	*desc2;			/* Secondary GPIO for reading */
+	struct	led_classdev cdev;
+	bool	registered;
+	int	uid_busy;	/* Wait time in ms. */
+	struct timer_list timer;
+} *rnleds;
+
+struct rnled_proc {
+	const	char *label;	/* GPIO label */
+	void (*init)(struct rnled_info *, const char *);
+	void (*exit)(struct rnled_info *);
+	enum led_brightness (*get)(struct led_classdev *);
+	/* setter returns 0 for success, 1 for busy, -1 for error. */
+	int (*set)(struct rnled_info *, int);
+};
+
+static inline struct rnled_info *led_cdev_to_info(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct rnled_info, cdev);
+}
+
+static enum led_brightness led_get_gpio(struct led_classdev *led_cdev)
+{
+	struct rnled_info *led = led_cdev_to_info(led_cdev);
+
+	return gpiod_get_value_cansleep(led->desc);
+}
+
+/*
+ * Under led_servicer, all LED accesses (except UID) are serialized
+ * and no need for locking.
+ */
+static int led_set_gpio(struct rnled_info *led, int val)
+{
+	gpiod_set_value_cansleep(led->desc, val);
+	return 0;
+}
+
+static int gpio_match(struct gpio_chip *chip, void *data)
+{
+	return !strcmp(chip->label, (const char *)data);
+}
+
+static void led_init_gpio(struct rnled_info *led, const char *label)
+{
+	int state, err;
+	struct gpio_chip *chip = gpiochip_find((void *)label, gpio_match);
+
+	if (!chip) {
+		pr_err("%s GPIO chip %s not found\n", __func__, label);
+		led->desc = ERR_PTR(-ENODEV);
+		return;
+	}
+
+	led->desc = gpio_to_desc(led->num + chip->base);
+	if (IS_ERR_OR_NULL(led->desc))
+		return;
+
+	if (led->active_low & 0x1)
+		set_bit(FLAG_ACTIVE_LOW,
+			&((struct gpio_desc *)led->desc)->flags);
+
+	if (led->init_state < 0)
+		state = 0;
+	else if (led->init_state > 0)
+		state = 1;
+	else if (led->proc->get)
+		state = led->proc->get(&led->cdev);
+	else
+		state = 0;
+
+	if ((err = gpiod_direction_output(led->desc, state)) && err != -EIO) {
+		/* EIO is returned if no direction_output. */
+		led->desc = ERR_PTR(err);
+		return;
+	}
+
+	led->cdev.brightness = state;
+}
+
+static const struct rnled_proc led_gpio_ich = {
+	.label	= "gpio_ich",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+static const struct rnled_proc led_gpio_dnv = {
+	.label	= "gpio_dnv.0",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+static const struct rnled_proc led_gpio_apl = {
+	.label	= "gpio_apl",
+	.init	= led_init_gpio,
+	.get	= led_get_gpio,
+	.set	= led_set_gpio,
+};
+
+#define IBPI_PATTERN_NORMAL		0x00000000
+#define IBPI_PATTERN_DEGRADED		0x00200000
+#define IBPI_PATTERN_REBUILD		0x00480000
+#define IBPI_PATTERN_FAILED_DRIVE	0x00400000
+#define IBPI_PATTERN_LOCATE		0x00080000
+static int led_set_scsi(struct rnled_info *led, int val)
+{
+	struct Scsi_Host *shost;
+	struct ata_port *ap;
+	u32 message;
+
+	/* get disk index */
+	if (led->num < 0)
+		return -1;
+
+	shost = scsi_host_lookup(led->num);
+	if (!shost)
+		return -1;
+	ap = ata_shost_to_port(shost);
+	if (!ap || !ap->ops->transmit_led_message)
+		return -1;
+	message = val ? IBPI_PATTERN_FAILED_DRIVE : IBPI_PATTERN_NORMAL;
+	return ap->ops->transmit_led_message(ap, message, 4) > 0 ? 0 : -1;
+}
+
+static const struct rnled_proc led_scsi = {
+	.set	= led_set_scsi,
+};
+
+/* IT8732 SuperIO GPIO */
+
+static const struct rnled_proc led_gpio_it87 = {
+	.label	= "gpio_it87",
+	.init	= led_init_gpio,
+	.get	= led_get_gpio,
+	.set	= led_set_gpio,
+};
+
+static enum led_brightness led_get_gpio2(struct led_classdev *led_cdev)
+{
+	struct rnled_info *led = led_cdev_to_info(led_cdev);
+
+	/* Use desc2 only if it appears a valid gpiod (or it may be GPIO2#. */
+	return gpiod_get_value_cansleep((long)led->desc2 < 0
+					? led->desc2 : led->desc);
+}
+
+/*
+ * The LED class driver implements blinking and one-shot LED control
+ * using kernel timers. This causes a problem if the underlying LED
+ * driver (GPIO) could sleep in msleep or mutex_lock because a timer callback
+ * runs in a softirq context. A dedicated kernel thread isolates the
+ * sleeping LED driver from LED class driver's preference.
+ *
+ * UID LED is turned on and off with a long (200ms) pulse in a flip-flop
+ * manner. A timer delay releases the pulse after the delay, then another
+ * timer delay disables subsequent LED operation requests until a recovery
+ * period (another 200ms) gets elapsed.
+ */
+static struct led_service {
+	const char *name;
+	struct task_struct *kthread;
+	wait_queue_head_t wq;
+	spinlock_t lock;
+	int count;
+	struct led_set_request {
+		struct list_head list;
+		struct rnled_info *led;
+		int val;
+	} req;
+} led_service = {.name = "readynas-led", };
+
+/* UID LED is set with a flip-flop */
+/* This is a timer callback (a.k.a. softirq). */
+static void uid_delay(struct timer_list *t)
+{
+	struct rnled_info *led = from_timer(rnleds, t, timer);
+
+	if (gpiod_get_value_cansleep(led->desc)) {
+		/* Flip-flop pulse is active. Request servicer to deactivate
+		   it and wait for recovery time.
+		 */
+		struct led_service *service = &led_service;
+		struct led_set_request *req = kmalloc(sizeof *req, GFP_ATOMIC);
+
+		if (!req) {
+			pr_err("%s: kmalloc failed.\n", __func__);
+			return;
+		}
+
+		req->led = led;
+		req->val = -1;	/* UID pulse release */
+		spin_lock(&service->lock);
+		list_add_tail(&req->list, &service->req.list);
+		service->count++;
+		spin_unlock(&service->lock);
+		wake_up(&service->wq);
+	} else
+		led->uid_busy = 0;
+}
+
+#define UID_PULSE_MS		200
+#define UID_PULSE_WAIT_TICK	20
+static int led_set_gpio_uid(struct rnled_info *led, int val)
+{
+	if (val >= 0) {
+		if (val == (led->proc->get ? led->proc->get(&led->cdev)
+				    : gpiod_get_value_cansleep(led->desc2)))
+			return 0;	/* No change. */
+		if (led->uid_busy) {
+			/* Previous operation is pending - retry. */
+			msleep(UID_PULSE_WAIT_TICK);
+			/* Overkilling caution for timeout. */
+			led->uid_busy -= UID_PULSE_WAIT_TICK;
+			if (led->uid_busy < 0)
+				led->uid_busy = 0;
+			return 1;
+		}
+
+		/* Flip it -- initiate a pulse. */
+		gpiod_set_value_cansleep(led->desc, 1);
+		/* Prepare for timeout. */
+		led->uid_busy = UID_PULSE_MS * 10;
+	} else {
+		/* Release the pulse */
+		gpiod_set_value_cansleep(led->desc, 0);
+	}
+
+	/* Wait so long as HW debouncer requires. */
+	mod_timer(&led->timer, jiffies + msecs_to_jiffies(UID_PULSE_MS));
+	return 0;
+}
+
+static void led_init_gpio_uid(struct rnled_info *led, const char *label)
+{
+	int state, err;
+
+	led_init_gpio(led, label);
+	if (IS_ERR_OR_NULL(led->desc))
+		return;
+
+	/* desc2 has GPIO# for get. */
+	if (!led->desc2)
+		return;
+
+	led->desc2 = gpio_to_desc((unsigned long)led->desc2 +
+				((struct gpio_desc *)led->desc)->gdev->base);
+	if (IS_ERR_OR_NULL(led->desc2)) {
+		led->desc = ERR_PTR(-ENODEV);
+		return;
+	}
+
+	if (led->active_low & 0x2)
+		set_bit(FLAG_ACTIVE_LOW,
+			&((struct gpio_desc *)led->desc2)->flags);
+
+	if ((err = gpiod_direction_input(led->desc2)) && err != -EIO) {
+		led->desc = ERR_PTR(err);
+		return;
+	}
+	state = gpiod_get_value_cansleep(led->desc2);
+	led->cdev.brightness = state;
+	led->cdev.brightness_get = led_get_gpio2;
+	timer_setup(&led->timer, uid_delay, 0);
+}
+
+static void led_exit_gpio_uid(struct rnled_info *led)
+{
+	del_timer(&led->timer);
+	led->uid_busy = 0;
+}
+
+static const struct rnled_proc led_gpio_it87_uid_rn313x = {
+	.label	= "gpio_it87",
+	.init	= led_init_gpio_uid,
+	.exit	= led_exit_gpio_uid,
+	.set	= led_set_gpio_uid,
+};
+
+static struct rnled_info leds_ultra2[] = {
+	{ "readynas:blue:pwr",     28, &led_gpio_ich, 1, 0, "timer" },
+	{ "readynas:green:backup", 22, &led_gpio_ich, 1, },
+	{ "readynas:green:sata1",  6,  &led_gpio_ich, 1, },
+	{ "readynas:green:sata2",  7,  &led_gpio_ich, 1, },
+	{}
+};
+
+static struct rnled_info leds_pro6_ultra6[] = {
+	{ "readynas:green:backup", 20, &led_gpio_ich, 0, },
+	{},
+};
+
+static struct rnled_info leds_ultra4_rn312_rn314[] = {
+	{ "readynas:blue:pwr",     28, &led_gpio_ich, 1, 0, "timer" },
+	{ "readynas:green:backup", 22, &led_gpio_ich, 1, },
+	{ "readynas:green:sata1",  16, &led_gpio_ich, 1, },
+	{ "readynas:green:sata2",  20, &led_gpio_ich, 1, },
+	{ "readynas:green:sata3",  6,  &led_gpio_ich, 1, },
+	{ "readynas:green:sata4",  7,  &led_gpio_ich, 1, },
+	{}
+};
+
+static struct rnled_info leds_rn424[] = {
+	{ "readynas:red:sata1",  90, &led_gpio_dnv, },
+	{ "readynas:red:sata2",  91, &led_gpio_dnv, },
+	{ "readynas:red:sata3",  92, &led_gpio_dnv, },
+	{ "readynas:red:sata4",  93, &led_gpio_dnv, },
+	{}
+};
+
+static struct rnled_info leds_rn428[] = {
+	{ "readynas:red:sata1",  91, &led_gpio_dnv, },
+	{ "readynas:red:sata2",  90, &led_gpio_dnv, },
+	{ "readynas:red:sata3",  93, &led_gpio_dnv, },
+	{ "readynas:red:sata4",  92, &led_gpio_dnv, },
+	{ "readynas:red:sata5",  23, &led_gpio_dnv, },
+	{ "readynas:red:sata6",  22, &led_gpio_dnv, },
+	{ "readynas:red:sata7",  40, &led_gpio_dnv, },
+	{ "readynas:red:sata8",  39, &led_gpio_dnv, },
+	{}
+};
+
+static struct rnled_info leds_rnx16_rn316[] = {
+	{ "readynas:red:sata1",	 0, &led_scsi, },
+	{ "readynas:red:sata2",	 1, &led_scsi, },
+	{ "readynas:red:sata3",	 2, &led_scsi, },
+	{ "readynas:red:sata4",	 3, &led_scsi, },
+	{ "readynas:red:sata5",	 4, &led_scsi, },
+	{ "readynas:red:sata6",	 5, &led_scsi, },
+	{}
+};
+
+static struct rnled_info leds_rnx28[] = {
+	{ "readynas:red:sata1",	48, &led_gpio_ich, },
+	{ "readynas:red:sata2",	39, &led_gpio_ich, },
+	{ "readynas:red:sata3",	38, &led_gpio_ich, },
+	{ "readynas:red:sata4",	22, &led_gpio_ich, },
+	{ "readynas:red:sata5",	67, &led_gpio_ich, },
+	{ "readynas:red:sata6",	37, &led_gpio_ich, },
+	{ "readynas:red:sata7",	36, &led_gpio_ich, },
+	{ "readynas:red:sata8",	21, &led_gpio_ich, },
+	{}
+};
+
+static struct rnled_proc led_gpio_it87_uid_rr23xx = {
+	.label	= "gpio_it87",
+	.init	= led_init_gpio_uid,
+	.set	= led_set_gpio_uid,
+	.get	= led_get_gpio2,
+	.exit	= led_exit_gpio_uid,
+};
+
+static struct rnled_info leds_rr2304[] = {
+	{ "readynas:green:pwr",	 24, &led_gpio_it87, 1, 0, "timer" }, /* GP40*/
+	{ "readynas:red:err",	 28, &led_gpio_it87, 1, },	/* GP44 */
+	{ "readynas:blue:uid",	 27, &led_gpio_it87_uid_rr23xx, 1,
+				.desc2 = (void *)11, },	/* GP43, GP23 */
+
+	{ "readynas:red:sata1",  90, &led_gpio_apl, },	/* AVS_I2S3_WS_SYNC */
+	{ "readynas:red:sata2",  91, &led_gpio_apl, },	/* AVS_I2S3_SDI */
+	{ "readynas:red:sata3",  86, &led_gpio_apl, },	/* AVS_I2S2_WS_SYNC */
+	{ "readynas:red:sata4",  89, &led_gpio_apl, },	/* AVS_I2S3_BCLK */
+	{}
+};
+
+static struct rnled_info leds_rr2312[] = {
+	{ "readynas:green:pwr",	 24, &led_gpio_it87, 0, 0, "timer" }, /* GP40*/
+	{ "readynas:red:err",	 44, &led_gpio_it87, },	/* GP64 */
+	{ "readynas:blue:uid",	 10, &led_gpio_it87_uid_rr23xx, 1,
+				.desc2 = (void *)11, },	/* GP22, GP23 */
+
+	{ "readynas:red:sata1",  91, &led_gpio_dnv, },
+	{ "readynas:red:sata2",  90, &led_gpio_dnv, },
+	{ "readynas:red:sata3",  93, &led_gpio_dnv, },
+	{ "readynas:red:sata4",  92, &led_gpio_dnv, },
+	{ "readynas:red:sata5",  23, &led_gpio_dnv, },
+	{ "readynas:red:sata6",  22, &led_gpio_dnv, },
+	{ "readynas:red:sata7",  40, &led_gpio_dnv, },
+	{ "readynas:red:sata8",  39, &led_gpio_dnv, },
+	{ "readynas:red:sata9",  31, &led_gpio_dnv, },
+	{ "readynas:red:sata10", 28, &led_gpio_dnv, },
+	{ "readynas:red:sata11", 30, &led_gpio_dnv, },
+	{ "readynas:red:sata12", 36, &led_gpio_dnv, },
+	{}
+};
+
+#define	SUS(n)	((n)+32)
+static struct rnled_info leds_rn313x[] = {
+	{ "readynas:green:pwr",	 39,	&led_gpio_it87, 1, 0, "timer" },
+	{ "readynas:red:err",	 24,	&led_gpio_it87, 1, },
+	{ "readynas:blue:uid",	 53,	&led_gpio_it87_uid_rn313x, 1, 0,
+					NULL, NULL, (void*)55},
+	/* HDD power control (prototype HW only) */
+	{ ".readynas::sata1_pwr", 11,	&led_gpio_ich, 0, 1, },
+	{ ".readynas::sata2_pwr", 15,	&led_gpio_ich, 0, 1, },
+	{ ".readynas::sata3_pwr", SUS(17),	&led_gpio_ich, 0, 1, },
+	{ ".readynas::sata4_pwr", 18,	&led_gpio_ich, 0, 1, },
+
+	{ "readynas:green:sata1", 12,	&led_gpio_ich, },
+	{ "readynas:green:sata2", 20,	&led_gpio_ich, },
+	{ "readynas:green:sata3", 19,	&led_gpio_ich, },
+	{ "readynas:green:sata4", 17,	&led_gpio_ich, },
+	{ "readynas:red:sata1", SUS(21),	&led_gpio_ich, },
+	{ "readynas:red:sata2", SUS(19),	&led_gpio_ich, },
+	{ "readynas:red:sata3", SUS(22),	&led_gpio_ich, },
+	{ "readynas:red:sata4",   27,	&led_gpio_ich, },
+	{}
+};
+
+static const struct rnled_proc led_gpio_nct6775 = {
+	.label	= "gpio_nct6775",
+	.init	= led_init_gpio,
+	.get	= led_get_gpio,
+	.set	= led_set_gpio,
+};
+
+static const struct rnled_proc led_gpio_rnx220pic = {
+	.label	= "gpio_rnx220pic",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+static const struct rnled_proc led_gpio_nct6775_rnx220_uid = {
+	.label	= "gpio_nct6775",
+	.init	= led_init_gpio_uid,
+	.set	= led_set_gpio_uid,
+};
+
+static const struct rnled_proc led_gpio_rnx220marvell = {
+	.label	= "gpio_rnx220marvell",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+static struct rnled_info leds_rnx220[] = {
+	{ "readynas:green:pwr",	  72,	&led_gpio_nct6775, 0, 0, "timer" },
+	{ "readynas:red:err",	   5,	&led_gpio_ich, 1},
+	{ "readynas:blue:uid",	   8,	&led_gpio_nct6775_rnx220_uid, 3, 0,
+					NULL, NULL, (void*)9},
+	{ "readynas:green:sata1",  0,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata2",  1,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata3",  0,	&led_gpio_rnx220marvell, },
+	{ "readynas:green:sata4",  1,	&led_gpio_rnx220marvell, },
+	{ "readynas:green:sata5",  4,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata6",  5,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata7",  6,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata8",  7,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata9",  8,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata10", 9,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata11",10,	&led_gpio_rnx220pic, },
+	{ "readynas:green:sata12",11,	&led_gpio_rnx220pic, },
+	{}
+};
+
+/* PCA9505 I2C GPIO */
+static const struct rnled_proc led_gpio_pca9505 = {
+	.label	= "pca9505",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+/* Intel sunrisepoint PCH-H GPIO */
+static const struct rnled_proc led_gpio_spth = {
+	.label	= "INT345D:00",
+	.init	= led_init_gpio,
+	.set	= led_set_gpio,
+};
+
+static struct rnled_info leds_rrx312[] = {
+	{ "readynas:green:pwr",	 14,	&led_gpio_it87, 0, 1, "timer" },
+	{ "readynas:red:err",	 82,	&led_gpio_spth, 1, },
+	{ "readynas:blue:uid",	 24,	&led_gpio_it87, 0, },
+
+	{ ".readynas::sata1_pwr", 12,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata2_pwr", 13,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata3_pwr", 14,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata4_pwr", 15,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata5_pwr", 16,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata6_pwr", 17,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata7_pwr", 18,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata8_pwr", 19,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata9_pwr", 20,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata10_pwr",21,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata11_pwr",22,	&led_gpio_pca9505, 0, 1 },
+	{ ".readynas::sata12_pwr",23,	&led_gpio_pca9505, 0, 1 },
+
+	{ "readynas:red:sata1",   24,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata2",   25,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata3",   26,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata4",   27,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata5",   28,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata6",   29,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata7",   30,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata8",   31,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata9",   32,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata10",  33,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata11",  34,	&led_gpio_pca9505, 1 },
+	{ "readynas:red:sata12",  35,	&led_gpio_pca9505, 1 },
+	{}
+};
+
+/*
+ * RR4360 uses SAS SES to control disk LEDs.
+ *
+ * leds_rr4360[] is a template for front panel LEDs.
+ */
+static struct rnled_info leds_rr4360[] = {
+	{ "readynas:blue:pwr",	 14,	&led_gpio_it87, 0, 1, "timer" },
+	{ "readynas:red:err",	 82,	&led_gpio_spth, 1, },
+	{ "readynas:blue:uid",	 24,	&led_gpio_it87, 0, },
+	{}
+};
+
+#include <linux/enclosure.h>
+
+static enum led_brightness led_get_ses(struct led_classdev *led_cdev)
+{
+	struct rnled_info *led = led_cdev_to_info(led_cdev);
+	struct enclosure_component *ec = led->desc;
+	struct enclosure_device *edev;
+
+	if (!ec)
+		return 0;
+
+	edev = to_enclosure_device(ec->cdev.parent);
+	if (edev->cb && edev->cb->get_locate)
+		edev->cb->get_locate(edev, ec);
+	return ec->locate;
+}
+
+static int led_set_ses(struct rnled_info *led, int val)
+{
+	struct enclosure_component *ec = led->desc;
+	struct enclosure_device *edev;
+
+	if (!ec)
+		return -1;
+
+	edev = to_enclosure_device(ec->cdev.parent);
+	if (edev->cb && edev->cb->set_locate)
+		edev->cb->set_locate(edev, ec, val);
+	return 0;
+}
+
+struct rnled_proc led_ses = {
+	.get	= led_get_ses,
+	.set	= led_set_ses,
+};
+
+static const char *ses_led_name_temp = "readynas:red:sas%u";
+#define SES_LED_NAME_LEN	(strlen(ses_led_name_temp) + 4)
+
+/* We count only internal SAS drives excluding those on JBOD extenders. */
+static inline int is_internal_ses(struct enclosure_device *edev)
+{
+	/* TODO */
+	return (edev->components == 20);
+}
+
+static int num_ses_leds;
+static int ses_enclosure(struct enclosure_device *edev, void *p)
+{
+	if (is_internal_ses(edev))
+		num_ses_leds += edev->components;
+	return 0;
+}
+
+/* RR4360 houses 60 SAS HDDs. 3 SAS motherboards each of which accepts
+ * 20 HDDs. 20 SAS ports are divided into 4 5-port bunks in a staggering
+ * layout. "Slot numbers" should be uniquely assigned and corresponding to
+ * the physical slots, but the 20-port motherboards may not be unique or
+ * appropriately installed.
+ * First, try using the slot numbers, and, if it results bad, use
+ * hardcoded slot mapping.
+ */
+static int ses_enclosure2(struct enclosure_device *edev, void *p)
+{
+	struct rnled_info *sesleds = p;
+	int i;
+
+	if (!is_internal_ses(edev))
+		return 0;
+
+	for (i = 0; i < edev->components; i++) {
+		struct enclosure_component *ec = &edev->component[i];
+		/* Slot number is 1-based. */
+		struct rnled_info *led = &sesleds[ec->slot - 1];
+
+		if (ec->slot <= num_ses_leds &&
+			!memcmp(dev_name(&ec->cdev), "Disk", 4)) {
+			if (led->name[0])
+				return -EIO;
+			sprintf((char *)led->name, ses_led_name_temp, ec->slot);
+			led->desc = ec;
+		}
+	}
+	return 0;
+}
+
+/* Returns newly allocated rnled_info array with dynamically filled LEDs. */
+static struct rnled_info *leds_ses_init(struct rnled_info *temp)
+{
+	char *led_names;
+	struct rnled_info *leds;
+	int i, fixed, err;
+
+	num_ses_leds = 0;
+	enclosure_for_each_device(ses_enclosure, NULL);
+	if (num_ses_leds < 60) {
+		pr_debug("%s: Not enough SES LEDs yet, deferring\n", __func__);
+		return ERR_PTR(-EPROBE_DEFER);
+	}
+
+	/* Count fixed portion size. */
+	for (fixed = 0; temp[fixed].name; fixed++)
+		;
+
+	if (!(leds = kzalloc(sizeof(*temp) * (fixed + num_ses_leds + 1),
+					GFP_ATOMIC)))
+		return ERR_PTR(-ENOMEM);
+	if (!(led_names = kzalloc(SES_LED_NAME_LEN * num_ses_leds,
+					GFP_ATOMIC))) {
+		kfree(leds);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	memcpy(leds, temp, sizeof(*temp) * fixed);
+	for (i = 0; i < num_ses_leds; i++) {
+		struct rnled_info *led = &leds[fixed + i];
+
+		led->name = led_names + i * SES_LED_NAME_LEN;
+		led->proc = &led_ses;
+	}
+
+	if ((err = enclosure_for_each_device(ses_enclosure2, &leds[fixed]))) {
+		kfree(leds);
+		kfree(led_names);
+		pr_err("%s: failed to set up SES LEDs (%d).\n",
+			__func__, err);
+		return ERR_PTR(err);
+	}
+	return leds;
+}
+
+static void leds_ses_exit(struct rnled_info *leds)
+{
+	kfree(leds[0].name);
+	kfree(leds);
+}
+
+/*
+ * Compatibility table for all models
+ */
+static const struct model_info {
+	const char *compatible;
+	struct rnled_info *leds;
+	int	num_leds;
+	struct rnled_info *(*init)(struct rnled_info *);
+	void (*exit)(struct rnled_info *);
+} rnmodels[] = {
+	{ "pro6",	leds_pro6_ultra6},
+	{ "ultra2",	leds_ultra2},
+	{ "ultra4",	leds_ultra4_rn312_rn314},
+	{ "ultra6",	leds_pro6_ultra6},
+	{ "rn312",	leds_ultra4_rn312_rn314, 4},
+	{ "rn314",	leds_ultra4_rn312_rn314},
+	{ "rn316",	leds_rnx16_rn316},
+	{ "rn422",	leds_rn424, 2},
+	{ "rn424",	leds_rn424},
+	{ "rn426",	leds_rn428, 6},
+	{ "rn428",	leds_rn428},
+	{ "rnx16",	leds_rnx16_rn316},
+	{ "rnx24",	leds_rnx28, 4},
+	{ "rnx26",	leds_rnx16_rn316},
+	{ "rnx28",	leds_rnx28},
+	{ "rr2304",	leds_rr2304},
+	{ "rr2312",	leds_rr2312},
+	{ "rn313x",	leds_rn313x},
+	{ "rnx220",	leds_rnx220},
+	{ "rrx312",	leds_rrx312},
+	{ "rr4360",	leds_rr4360, 0, leds_ses_init, leds_ses_exit},
+	{}
+},
+*rnmodel;
+
+/* Kernel thread to serialize LED accesses in process context. */
+static void __led_servicer(struct led_service *service)
+{
+	struct led_set_request *req = NULL;
+
+	do {
+		struct led_set_request *q;
+		unsigned long flags;
+
+		spin_lock_irqsave(&service->lock, flags);
+		/* Release UID pulse ASAP to avoid busy waiters. */
+		list_for_each_entry_safe(req, q, &service->req.list, list) {
+			if (req->val < 0 ||
+				req->led->proc->set != led_set_gpio_uid)
+				break;
+		}
+		if (!req || req->val >= 0)
+			req = list_first_entry_or_null(&service->req.list,
+						struct led_set_request, list);
+		if (req) {
+			list_del(&req->list);
+			service->count--;
+		}
+		spin_unlock_irqrestore(&service->lock, flags);
+
+		if (req) {
+			/* If UID LED is busy. Retry after a short sleep. */
+			if (req->led->proc->set(req->led, req->val) > 0) {
+				spin_lock_irqsave(&service->lock, flags);
+				list_add(&req->list, &service->req.list);
+				service->count++;
+				spin_unlock_irqrestore(&service->lock, flags);
+				continue;
+			}
+
+			kfree(req);
+		}
+	} while (req);
+}
+
+static int led_servicer(void *data)
+{
+	struct led_service *service = data;
+
+	while (!kthread_should_stop()) {
+		wait_event_interruptible_timeout(service->wq,
+				!list_empty(&service->req.list), 2 * HZ);
+		__led_servicer(service);
+	}
+	return 0;
+}
+
+/* This common LED setter may be called in softirq (a.k.a. timer callback).
+ * So, do not sleep.
+ */
+static void led_set(struct led_classdev *led_cdev, enum led_brightness val)
+{
+	unsigned long flags;
+	struct rnled_info *led = led_cdev_to_info(led_cdev);
+	struct led_service *service = &led_service;
+	struct led_set_request *req = kmalloc(sizeof *req, GFP_ATOMIC);
+
+	if (!req) {
+		pr_err("%s: kmalloc failed (%lu bytes)\n",
+			__func__, sizeof *req);
+		return;
+	}
+	req->led = led;
+	req->val = !!val;
+
+	spin_lock_irqsave(&service->lock, flags);
+	if (service->count < 500) {
+		list_add_tail(&req->list, &service->req.list);
+		service->count++;
+	} else
+		pr_warn("%s: LED request queue full.\n", __func__);
+	spin_unlock_irqrestore(&service->lock, flags);
+	wake_up(&service->wq);
+}
+
+static int register_led(struct device *parent, struct rnled_info *led)
+{
+	pr_info("%s: registering LED \"%s\"\n", __func__, led->name);
+
+	led->cdev.name = led->name;
+	led->cdev.brightness_get = led->proc->get;
+	led->cdev.brightness_set = led_set;
+
+	if (led->proc->init) {
+		led->proc->init(led, led->proc->label);
+		/* Errors happen only after an explicit init. */
+		if (IS_ERR_OR_NULL(led->desc))
+			return led->desc ? PTR_ERR(led->desc) : -ENODEV;
+	}
+
+	led->cdev.flags |= LED_CORE_SUSPENDRESUME;
+	led->cdev.default_trigger = led->trigger;
+
+	return led_classdev_register(parent, &led->cdev);
+}
+
+static int readynas_led_probe(struct platform_device *pdev)
+{
+	struct model_info const *mp;
+	int i = 0, err = 0;
+
+	mp  = __compatible_find(rnmodels, compatible, -ENODEV,
+				"no compatible platform\n");
+	rnleds = mp->leds;
+
+	if (mp->init) {
+		rnleds = mp->init(mp->leds);
+		if (IS_ERR(rnleds))
+			return PTR_ERR(rnleds);
+		if (!rnleds)
+			return -ENODEV;
+	}
+
+	init_waitqueue_head(&led_service.wq);
+	spin_lock_init(&led_service.lock);
+	INIT_LIST_HEAD(&led_service.req.list);
+	led_service.kthread = kthread_run(led_servicer, &led_service,
+						led_service.name);
+
+	if (IS_ERR(led_service.kthread)) {
+		led_service.kthread = NULL;
+		rnleds = NULL;
+		pr_err("%s: failed to start %s service kthread.\n",
+			__func__, led_service.name);
+		err = -ENOMEM;
+		goto fail;
+	}
+
+	for (i = 0; (!mp->num_leds || i < mp->num_leds) && rnleds[i].name; i++)
+		if (rnleds[i].name[0]) {/* Or skip unavailable drive. */
+			if ((err = register_led(&pdev->dev, &rnleds[i])))
+				pr_err("%s: %s registration failed.\n",
+					__func__, rnleds[i].name);
+			else
+				rnleds[i].registered = true;
+		}
+
+	rnmodel = mp;
+	return 0;
+
+fail:
+	if (mp->exit)
+		mp->exit(rnleds);
+	return err;
+}
+
+static int readynas_led_remove(struct platform_device *pdev)
+{
+	int i;
+	struct model_info const *mp = rnmodel;
+
+	if (led_service.kthread) {
+		kthread_stop(led_service.kthread);
+		led_service.kthread = NULL;
+	}
+
+	for (i = 0; (!mp->num_leds || i < mp->num_leds) && rnleds[i].name; i++)
+		if (rnleds[i].registered) {
+			if (rnleds[i].proc->exit)
+				rnleds[i].proc->exit(&rnleds[i]);
+			led_classdev_unregister(&rnleds[i].cdev);
+			rnleds[i].registered = false;
+		}
+
+	if (mp->exit)
+		mp->exit(rnleds);
+	rnleds = NULL;
+	return 0;
+}
+
+static struct platform_driver readynas_led_driver = {
+	.probe		= readynas_led_probe,
+	.remove		= readynas_led_remove,
+	.driver		= {
+		.name	= "readynas-led",
+	},
+};
+
+static struct platform_device *readynas_led_pdev;
+
+static int __init readynas_led_init(void)
+{
+	int err = platform_driver_register(&readynas_led_driver);
+
+	pr_info("%s: installing ReadyNAS LED driver.\n", __func__);
+	if (err)
+		return err;
+
+	readynas_led_pdev =
+		platform_device_register_simple(readynas_led_driver.driver.name,
+						 -1, NULL, 0);
+	if (IS_ERR(readynas_led_pdev))
+		err = PTR_ERR(readynas_led_pdev);
+	else if (!readynas_led_pdev)
+		err = -ENODEV;
+	else if (!rnleds) {
+		platform_device_unregister(readynas_led_pdev);
+		err = -ENODEV;
+	}
+	if (err)
+		platform_driver_unregister(&readynas_led_driver);
+	return err;
+}
+
+static void __exit readynas_led_exit(void)
+{
+	platform_device_unregister(readynas_led_pdev);
+	platform_driver_unregister(&readynas_led_driver);
+}
+
+/* This module must be loaded after readynas-io. */
+device_initcall_sync(readynas_led_init);
+module_exit(readynas_led_exit);
+
+/*
+ * For software UID button/switch toggling simulation
+ */
+struct rnled_info *rnled_get_info(const char *name)
+{
+	int i;
+
+	if (!rnmodel)
+		return NULL;
+	for (i = 0; (!rnmodel->num_leds || i < rnmodel->num_leds) &&
+			rnleds[i].name; i++) {
+		if (!strcmp(rnleds[i].name, name))
+			return &rnleds[i];
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(rnled_get_info);
+
+int rnled_toggle(struct rnled_info *led)
+{
+	int state;
+
+	if (!led->proc->get)
+		return -1;
+	state = led->proc->get(&led->cdev);
+	state = !state;
+	led->proc->set(led, state);
+	return state;
+}
+EXPORT_SYMBOL_GPL(rnled_toggle);
+
+MODULE_AUTHOR("Justin Maggard <justin.maggard@netgear.com>");
+MODULE_DESCRIPTION("NETGEAR ReadyNAS LED driver");
+MODULE_LICENSE("GPL");
diff -ruN a/drivers/platform/readynas/readynas-oled.c b/drivers/platform/readynas/readynas-oled.c
--- a/drivers/platform/readynas/readynas-oled.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-oled.c	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,573 @@
+/*
+ * readynas-oled.c - NETGEAR ReadyNAS OLED bitmap display driver
+ *
+ * Copyright (c) 2015,2016 NETGEAR, Inc.
+ *
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ */
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/file.h>
+#include "readynas-io.h"
+
+#define FONT_OVERRIDE 0
+
+/*
+ * Hitach HD44780 similation for OLED bitmap display
+ */
+static struct oled_gpio {
+	const char *compatible;
+	const char *gpio_label;
+	unsigned int oled_sdin, oled_sclk, oled_dc,
+			oled_cs, oled_ctrl, oled_reset;
+	struct gpio_desc *oled_sdind, *oled_sclkd, *oled_dcd,
+			*oled_csd, *oled_ctrld, *oled_resetd;
+	struct hd44780_lcd lcd;
+} oled_gpios[] = {{
+	.compatible	= "rn316",
+	.gpio_label	= "gpio_ich",
+	.oled_sdin	= 21,
+	.oled_sclk	= 19,
+	.oled_dc	= 16,
+	.oled_cs	= 7,
+	.oled_ctrl	= 32,
+	.oled_reset	= 24,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rn422_4",
+	.gpio_label	= "gpio_dnv.0",
+	.oled_sdin	= 34,
+	.oled_sclk	= 35,
+	.oled_dc	= 0,
+	.oled_cs	= 122,
+	.oled_ctrl	= 17,
+	.oled_reset	= 31,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rn426_8",
+	.gpio_label	= "gpio_dnv.0",
+	.oled_sdin	= 30,
+	.oled_sclk	= 28,
+	.oled_dc	= 7,
+	.oled_cs	= 8,
+	.oled_ctrl	= 17,
+	.oled_reset	= 31,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rnx16",
+	.gpio_label	= "gpio_ich",
+	.oled_sdin	= 54,
+	.oled_sclk	= 52,
+	.oled_dc	= 32,
+	.oled_cs	= 50,
+	.oled_ctrl	= 6,
+	.oled_reset	= 7,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rnx24",
+	.gpio_label	= "gpio_ich",
+	.oled_sdin	= 54,
+	.oled_sclk	= 1,
+	.oled_dc	= 32,
+	.oled_cs	= 50,
+	.oled_ctrl	= 6,
+	.oled_reset	= 7,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rnx26",
+	.gpio_label	= "gpio_ich",
+	.oled_sdin	= 54,
+	.oled_sclk	= 1,
+	.oled_dc	= 32,
+	.oled_cs	= 50,
+	.oled_ctrl	= 6,
+	.oled_reset	= 7,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+},{
+	.compatible	= "rnx28",
+	.gpio_label	= "gpio_ich",
+	.oled_sdin	= 54,
+	.oled_sclk	= 1,
+	.oled_dc	= 32,
+	.oled_cs	= 50,
+	.oled_ctrl	= 6,
+	.oled_reset	= 7,
+	.lcd = {
+		.magic	= LCD_PLATFORM_MAGIC,
+	},
+}, {}}, *oled_gpio;
+
+#define OLED_COLS	16
+#define OLED_ROWS	2
+#define OLED_GPIOD_SET(name, val)	\
+	gpiod_set_value(gp->oled_##name##d, (val))
+
+static void spi_send(struct oled_gpio *gp, unsigned char c, bool cmd)
+{
+	unsigned char mask = 0x80;
+
+	OLED_GPIOD_SET(cs, 0);
+	OLED_GPIOD_SET(dc, !cmd);
+
+	/* transfer data */
+	while (mask) {
+		OLED_GPIOD_SET(sclk, 0);
+		OLED_GPIOD_SET(sdin, !!(mask & c));
+		OLED_GPIOD_SET(sclk, 1);
+		mask >>= 1;
+	}
+	OLED_GPIOD_SET(dc, 1);
+	OLED_GPIOD_SET(cs, 1);
+}
+
+static void inline spi_send_data(struct oled_gpio *gp, unsigned char d)
+{
+	spi_send(gp, d, false);
+}
+
+static void inline spi_send_cmd(struct oled_gpio *gp, unsigned char c)
+{
+	spi_send(gp, c, true);
+}
+
+static unsigned char oled_row, oled_col;
+static void oled_set_cursor_pos(struct hd44780_lcd *gl,
+				unsigned char row, unsigned char col)
+{
+	oled_row = min(row, (unsigned char)1);
+	oled_col = min(col, (unsigned char)(OLED_COLS - 1));
+}
+
+static void oled_return_home(struct hd44780_lcd *gl)
+{
+	oled_set_cursor_pos(gl, 0, 0);
+}
+
+static void oled_shift_cursor(struct hd44780_lcd *gl, bool right)
+{
+	if (right) {
+		if (oled_col < OLED_COLS && oled_row < OLED_ROWS) {
+			oled_col++;
+			oled_row += oled_col / OLED_COLS;
+			oled_col %= OLED_COLS;
+		}
+	} else {
+		if (oled_col > 0)
+			oled_col--;
+		else if (oled_row > 0) {
+			oled_col = OLED_COLS - 1;
+			oled_row = 0;
+		}
+	}
+}
+
+static void oled_backlight_on(struct hd44780_lcd *gl, bool on)
+{
+	struct oled_gpio *gp = container_of(gl, struct oled_gpio, lcd);
+
+	spi_send_cmd(gp, on ? 0xaf : 0xae);
+	gl->backlight_status = on;
+}
+
+#define	OLED_X_OFFSET	4
+
+static void clear_oled(struct hd44780_lcd *gl)
+{
+	struct oled_gpio *gp = container_of(gl, struct oled_gpio, lcd);
+	int page, col;
+
+	spi_send_cmd(gp, 0x40);	/* Start position */
+
+	for (page = 0; page < 4; page++) {
+		OLED_GPIOD_SET(cs, 0);
+		OLED_GPIOD_SET(dc, 0);
+		spi_send_cmd(gp, 0xb0 + page);
+		spi_send_cmd(gp, 0x10);
+		spi_send_cmd(gp, OLED_X_OFFSET);
+		OLED_GPIOD_SET(dc, 1);
+
+		for(col = 0; col < 128; col++)
+			spi_send_data(gp, 0x0);
+	}
+	oled_return_home(gl);
+}
+
+static int init_oled(struct hd44780_lcd *gl)
+{
+	int i;
+	struct oled_gpio *gp =
+		container_of(gl, struct oled_gpio, lcd);
+	static const unsigned char oled_init_cmd[] = {
+		0xae,	/* Turn off display. */
+
+		0xd5,	/* Display ClocDivide Ratio/Oscillator Frequency */
+		0x71,	/* to 105Hz. */
+
+		0xa8,	/* Multiplex Ratio */
+		0x1f,	/* to 32mux. */
+
+		0xd9,	/* Precharge period. */
+		0x22,
+
+		0x20,	/* Memory addressing mode. */
+		0x02,
+
+		0xa1,	/* Seg re-map 127->0. */
+		0xc8,	/* COM scan direction COM(N-1)-->COM0. */
+
+		0xda,	/* COM pins hardware configuration. */
+		0x12,
+
+		0xd8,	/* Color_mode_set */
+		0x00,	/* to monochrome mode & normal power mode. */
+
+		0x81,	/* Contrast control. */
+		0xcf,
+
+		0xb0,	/* Page start address for page Addressing mode. */
+
+		0xd3,	/* Display offset. */
+		0x00,
+
+		0x21,	/* Column address. */
+		OLED_X_OFFSET,		/* Colum address start. */
+		0x7f+OLED_X_OFFSET,	/* Colum address end. */
+
+		0x22,	/* Page address. */
+		0x00,	/* Page address start. */
+		0x03,	/* Page address end. */
+
+		0x10,	/* Higher column start addr for page addressing mode. */
+		0x00,	/* Lower column start addr for page addressing mode. */
+		0x40,	/* Display start line */
+		0xa6,	/* Normal (non-inverted). */
+
+		0xa4,	/* Entire display Off. */
+
+		0xdb,	/* VCOMH Level */
+		0x18,	/* to 0.83*VCC 0x3c, change from 0x20 to 0x18 avoid power peek issue. */
+	};
+
+	OLED_GPIOD_SET(reset, 0);
+	udelay(5);	/* L pulse > 3us */
+	OLED_GPIOD_SET(reset, 1);
+	udelay(5);
+
+	for (i = 0; i < ARRAY_SIZE(oled_init_cmd); i++)
+		spi_send_cmd(gp, oled_init_cmd[i]);
+
+	clear_oled(gl);
+
+	OLED_GPIOD_SET(ctrl, 1);
+
+	oled_backlight_on(gl, true);
+	return 0;
+}
+
+/* RNx16 128x32 OLED display 8x16 font */
+#define _FONT(c,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_a,_b,_c,_d,_e,_f)	\
+	[(c)] = { 0x##_0, 0x##_1,0x##_2, 0x##_3,0x##_4, 0x##_5,0x##_6, 0x##_7, \
+		  0x##_8, 0x##_9,0x##_a, 0x##_b,0x##_c, 0x##_d,0x##_e, 0x##_f }
+static const unsigned char ascii[128][16] = {
+	_FONT(' ', 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00),
+	_FONT('!', 00,00,00,f8,00,00,00,00,00,00,00,33,30,00,00,00),
+	_FONT('"', 00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00),
+	_FONT('#', 40,c0,78,40,c0,78,40,00,04,3f,04,04,3f,04,04,00),
+	_FONT('$', 00,70,88,fc,08,30,00,00,00,18,20,ff,21,1e,00,00),
+	_FONT('%', f0,08,f0,00,e0,18,00,00,00,21,1c,03,1e,21,1e,00),
+	_FONT('&', 00,f0,08,88,70,00,00,00,1e,21,23,24,19,27,21,10),
+	_FONT('\'',10,16,0e,00,00,00,00,00,00,00,00,00,00,00,00,00),
+	_FONT('(', 00,00,00,e0,18,04,02,00,00,00,00,07,18,20,40,00),
+	_FONT(')', 00,02,04,18,e0,00,00,00,00,40,20,18,07,00,00,00),
+	_FONT('*', 40,40,80,f0,80,40,40,00,02,02,01,0f,01,02,02,00),
+	_FONT('+', 00,00,00,f0,00,00,00,00,01,01,01,1f,01,01,01,00),
+	_FONT(',', 00,00,00,00,00,00,00,00,00,00,00,00,00,10,16,0e),
+	_FONT('-', 00,00,00,00,00,00,00,00,00,01,01,01,01,01,00,00),
+	_FONT('.', 00,00,00,00,00,00,00,00,00,30,30,00,00,00,00,00),
+	_FONT('/', 00,00,00,00,80,60,18,04,00,60,18,06,01,00,00,00),
+
+	_FONT('0', e0,18,04,04,04,18,e0,00,07,18,20,20,20,18,07,00),
+	_FONT('1', 00,10,08,fc,00,00,00,00,00,00,00,3f,00,00,00,00),
+	_FONT('2', 00,08,04,04,88,70,00,00,00,30,28,26,21,20,00,00),
+	_FONT('3', 00,08,84,84,48,38,00,00,00,10,20,20,11,0e,00,00),
+	_FONT('4', 00,80,60,18,fc,00,00,00,06,05,04,04,3f,04,00,00),
+	_FONT('5', 00,fc,84,84,04,00,00,00,00,10,20,20,11,0e,00,00),
+	_FONT('6', 00,e0,98,44,44,84,08,00,00,07,19,20,20,10,0f,00),
+	_FONT('7', 00,04,04,04,c4,3c,00,00,00,00,30,0e,01,00,00,00),
+	_FONT('8', 30,48,84,84,84,48,30,00,0e,11,20,20,20,11,0e,00),
+	_FONT('9', f0,08,04,04,98,e0,00,00,10,21,22,22,19,07,00,00),
+	_FONT(':', 00,00,00,c0,c0,00,00,00,00,00,00,30,30,00,00,00),
+	_FONT(';', 00,00,00,80,00,00,00,00,00,00,80,60,00,00,00,00),
+	_FONT('<', 00,00,80,40,20,10,08,00,00,01,02,04,08,10,20,00),
+	_FONT('=', 40,40,40,40,40,40,40,00,04,04,04,04,04,04,04,00),
+	_FONT('>', 00,08,10,20,40,80,00,00,00,20,10,08,04,02,01,00),
+	_FONT('?', 00,70,48,08,08,08,f0,00,00,00,00,30,36,01,00,00),
+
+	_FONT('@', c0,30,c8,28,e8,10,e0,00,07,18,27,24,23,14,0b,00),
+	_FONT('A', 00,00,f0,0c,f0,00,00,00,30,0f,04,04,04,0f,30,00),
+	_FONT('B', 00,fc,04,04,d8,20,00,00,00,3f,21,21,12,0e,00,00),
+	_FONT('C', e0,10,08,04,04,04,08,00,07,08,10,20,20,20,10,00),
+	_FONT('D', fc,04,04,04,08,10,e0,00,3f,20,20,20,10,08,07,00),
+	_FONT('E', fc,84,84,84,04,00,00,00,3f,20,20,20,20,00,00,00),
+	_FONT('F', fc,84,84,84,84,04,00,00,3f,00,00,00,00,00,00,00),
+	_FONT('G', e0,18,04,04,04,08,00,00,07,18,20,20,21,1f,00,00),
+	_FONT('H', fc,80,80,80,80,80,fc,00,3f,00,00,00,00,00,3f,00),
+	_FONT('I', 00,00,00,fc,00,00,00,00,00,00,00,3f,00,00,00,00),
+	_FONT('J', 00,00,00,00,fc,00,00,00,00,20,20,20,1f,00,00,00),
+	_FONT('K', fc,80,40,20,10,08,04,00,3f,01,02,04,08,10,20,00),
+	_FONT('L', fc,00,00,00,00,00,00,00,3f,20,20,20,20,20,00,00),
+	_FONT('M', fc,78,80,00,c0,38,fc,00,3f,00,07,38,07,00,3f,00),
+	_FONT('N', fc,18,e0,00,00,fc,00,00,3f,00,00,07,18,3f,00,00),
+	_FONT('O', e0,18,04,04,04,18,e0,00,07,18,20,20,20,18,07,00),
+
+	_FONT('P', 00,fc,04,04,88,70,00,00,00,3f,01,01,00,00,00,00),
+	_FONT('Q', e0,18,04,04,04,18,e0,00,03,0c,10,30,50,4c,43,00),
+	_FONT('R', 00,fc,04,04,88,70,00,00,00,3f,01,01,06,18,20,00),
+	_FONT('S', 00,38,44,84,04,08,00,00,00,10,20,20,11,0e,00,00),
+	_FONT('T', 04,04,fc,04,04,04,00,00,00,00,3f,00,00,00,00,00),
+	_FONT('U', fc,00,00,00,00,00,fc,00,0f,10,20,20,20,10,0f,00),
+	_FONT('V', 0c,f0,00,00,00,e0,1c,00,00,00,0f,30,1e,01,00,00),
+	_FONT('W', fc,00,f0,3c,c0,00,fc,00,03,3c,07,00,0f,3f,00,00),
+	_FONT('X', 00,1c,60,c0,30,0c,00,00,20,18,07,01,06,38,00,00),
+	_FONT('Y', 04,18,e0,00,e0,18,04,00,00,00,00,3f,00,00,00,00),
+	_FONT('Z', 00,04,04,c4,34,0c,00,00,00,38,26,21,20,20,00,00),
+	_FONT('[', 00,00,00,fe,02,02,02,00,00,00,00,7f,40,40,40,00),
+	_FONT('\\',00,0c,30,c0,00,00,00,00,00,00,00,01,06,38,c0,00),
+	_FONT(']', 00,02,02,02,fe,00,00,00,00,40,40,40,7f,00,00,00),
+	_FONT('^', 00,00,04,02,02,02,04,00,00,00,00,00,00,00,00,00),
+	_FONT('_', 00,00,00,00,00,00,00,00,80,80,80,80,80,80,80,80),
+
+	_FONT('`', 00,02,02,04,00,00,00,00,00,00,00,00,00,00,00,00),
+	_FONT('a', 00,00,40,40,40,80,00,00,00,1c,24,22,22,3f,00,00),
+	_FONT('b', 00,fc,40,40,80,00,00,00,00,1f,20,20,10,0f,00,00),
+	_FONT('c', 00,80,40,40,40,80,00,00,0f,10,20,20,20,10,00,00),
+	_FONT('d', 00,80,40,40,40,fc,00,00,0f,10,20,20,20,3f,00,00),
+	_FONT('e', 00,80,40,40,80,00,00,00,0f,12,22,22,22,13,00,00),
+	_FONT('f', 00,40,f8,44,44,04,00,00,00,00,3f,00,00,00,00,00),
+	_FONT('g', 00,c0,20,10,10,e0,00,00,00,13,24,24,24,1f,00,00),
+	_FONT('h', fc,80,40,40,40,80,00,00,3f,00,00,00,00,3f,00,00),
+	_FONT('i', 00,00,00,c8,00,00,00,00,00,00,00,3f,00,00,00,00),
+	_FONT('j', 00,00,00,d0,00,00,00,00,00,00,80,7f,00,00,00,00),
+	_FONT('k', fc,00,00,80,40,00,00,00,3f,02,0d,10,20,00,00,00),
+	_FONT('l', 00,00,00,fc,00,00,00,00,00,00,00,3f,00,00,00,00),
+	_FONT('m', c0,40,40,80,40,40,80,00,3f,00,00,3f,00,00,3f,00),
+	_FONT('n', 00,c0,40,40,40,80,00,00,00,3f,00,00,00,3f,00,00),
+	_FONT('o', 00,80,40,40,80,00,00,00,0f,10,20,20,10,0f,00,00),
+
+	_FONT('p', c0,40,40,40,80,00,00,00,ff,10,10,10,08,07,00,00),
+	_FONT('q', 00,80,40,40,40,80,00,00,07,08,10,10,10,ff,00,00),
+	_FONT('r', 00,c0,80,40,40,40,00,00,00,3f,00,00,00,00,00,00),
+	_FONT('s', c0,20,20,20,40,00,00,00,10,21,22,22,1c,00,00,00),
+	_FONT('t', 00,40,f0,40,40,40,00,00,00,00,1f,20,20,20,00,00),
+	_FONT('u', c0,00,00,00,00,00,c0,00,0f,10,20,20,20,10,3f,00),
+	_FONT('v', c0,00,00,00,80,40,00,00,00,0f,30,1c,03,00,00,00),
+	_FONT('w', c0,00,00,c0,80,00,c0,00,00,1f,3e,01,0f,30,0f,00),
+	_FONT('x', 00,c0,00,00,80,40,00,00,20,10,0d,06,19,20,00,00),
+	_FONT('y', c0,00,00,00,00,c0,40,00,80,87,68,18,07,00,00,00),
+	_FONT('z', 00,40,40,40,40,c0,00,00,00,30,28,26,21,20,00,00),
+	_FONT('{', 00,00,00,00,80,7c,02,02,00,00,00,00,00,3f,40,40),
+	_FONT('|', 00,00,00,00,ff,00,00,00,00,00,00,00,ff,00,00,00),
+	_FONT('}', 00,02,02,7c,80,00,00,00,00,40,40,3f,00,00,00,00),
+	_FONT('~', 00,06,01,01,02,02,04,04,00,00,00,00,00,00,00,00),
+
+	_FONT(1, 00,00,00,00,00,00,00,00,00,ff,ff,ff,ff,ff,ff,ff),
+	_FONT(127, 00,ff,ff,ff,ff,ff,ff,ff,00,ff,ff,ff,ff,ff,ff,ff),
+};
+
+static void oled_data_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	struct oled_gpio *gp = container_of(gl, struct oled_gpio, lcd);
+	const unsigned char *cg = ascii[c & 0x7f];
+	unsigned int xpix = oled_col * 8 + OLED_X_OFFSET;
+	int page;
+#if FONT_OVERRIDE
+	struct file *f;
+	mm_segment_t fs;
+	char buf[18];
+
+	fs = get_fs();
+	set_fs(get_ds());
+	sprintf(buf, "/root/font/%c", c);
+	f = filp_open(buf, O_RDONLY, 0);
+	if (!IS_ERR(f)) {
+		loff_t off = 0;
+		ssize_t ret;
+		memset(&buf, '\0', sizeof(buf));
+		ret = vfs_read(f, buf, 16, &off);
+		if (ret > 0) {
+			pr_info("Loaded font %c (%s)\n", c, buf);
+			cg = buf;
+		}
+		else
+			pr_info("Failed to load font %c: %ld\n", c, ret);
+		filp_close(f, NULL);
+	}
+	set_fs(fs);
+#endif
+
+	if (oled_row >= OLED_ROWS || oled_col >= OLED_COLS)
+		return;
+
+	spi_send_cmd(gp, 0xa6);
+	spi_send_cmd(gp, 0x40);	/* Start line. */
+
+	/* line1: page 0,1  line2: page 2,3  */
+	/* one char takes 2 page 16 pbits height; */
+	for (page = 0; page < 2; page++) {
+		int i;
+
+		OLED_GPIOD_SET(cs, 0);
+		OLED_GPIOD_SET(dc, 0);
+
+		spi_send_cmd(gp, 0xb0 + oled_row * 2 + page);
+		spi_send_cmd(gp, (xpix >> 4) | 0x10);
+		spi_send_cmd(gp, xpix & 0xf);
+
+		OLED_GPIOD_SET(dc, 1);
+
+		for (i = 0; i < 8; i++) {
+			unsigned int raster = cg[page * 8 + i];
+			if (c != 0xff && (c & 0x80))
+				raster ^= ~0;
+			spi_send_data(gp, raster);
+		}
+	}
+
+	oled_shift_cursor(gl, true);
+}
+
+static int oled_probe(struct platform_device *pdev)
+{
+	int err = 0;
+	struct gpio_chip *gc = rn_gpiochip_find_by_label(oled_gpio->gpio_label);
+
+	if (IS_ERR(gc))
+		err = PTR_ERR(gc);
+	else if (!gc)
+		err = -ENODEV;
+	if (err) {
+		pr_err("%s: cannot find OLED GPIO %s.\n", __func__,
+			oled_gpio->gpio_label);
+		return err;
+	}
+
+#define	GET_GPIOD(name)	\
+	do {	\
+		struct gpio_desc *_gd = 	\
+			gpiochip_get_desc(gc, oled_gpio->oled_##name); \
+		if (IS_ERR(_gd)) {	\
+			err = PTR_ERR(_gd);	\
+			goto out;	\
+		} else if (!_gd) {	\
+			err = -ENODEV;	\
+			goto out;	\
+		} else if ((err = gpiod_direction_output(_gd, 0)))	\
+			goto out;	\
+		oled_gpio->oled_##name##d = _gd;	\
+	} while (0)
+
+	GET_GPIOD(sdin);
+	GET_GPIOD(sclk);
+	GET_GPIOD(dc);
+	GET_GPIOD(cs);
+	GET_GPIOD(ctrl);
+	GET_GPIOD(reset);
+
+	oled_gpio->lcd.init	= init_oled;
+	oled_gpio->lcd.clear_lcd		= clear_oled;
+	oled_gpio->lcd.return_home	= oled_return_home;
+	oled_gpio->lcd.shift_cursor	= oled_shift_cursor;
+	oled_gpio->lcd.set_cursor_pos	= oled_set_cursor_pos;
+	oled_gpio->lcd.backlight_on	= oled_backlight_on;
+	oled_gpio->lcd.entry_display_on	= oled_backlight_on;
+	oled_gpio->lcd.data_write		= oled_data_write;
+
+	oled_gpio->lcd.lcm_num_cols	= OLED_COLS;
+	oled_gpio->lcd.lcm_num_rows	= OLED_ROWS;
+
+	mutex_init(&oled_gpio->lcd.lcm_lock);
+
+	err = init_oled(&oled_gpio->lcd);
+out:
+	if (err)
+		pr_err("%s: failed to install OLED driver.\n", __func__);
+	else
+		platform_set_drvdata(pdev, &oled_gpio->lcd);
+	return err;
+}
+
+static int oled_remove(struct platform_device *pdev)
+{
+	return 0;
+}
+
+static struct platform_driver oled_driver = {
+	.probe	= oled_probe,
+	.remove	= oled_remove,
+	.driver = { .name	= "rnx16-oled", },
+};
+
+static struct platform_device *oled_pdev;
+static int __init rn_oled_init(void)
+{
+	int err;
+
+	for (oled_gpio = &oled_gpios[0];
+		oled_gpio->compatible; oled_gpio++)
+		if (readynas_io_compatible(oled_gpio->compatible))
+			break;
+	if (!oled_gpio->compatible)
+		return 0;
+
+	pr_info("%s: initializing %s OLED front display.\n", __func__,
+			oled_gpio->compatible);
+	if ((err = platform_driver_register(&oled_driver))) {
+		pr_err("%s: failed to install OELD driver.\n",
+			__func__);
+		return err;
+	}
+
+	oled_pdev = platform_device_register_simple(oled_driver.driver.name,
+							-1, NULL, 0);
+	if (IS_ERR(oled_pdev))
+		err = PTR_ERR(oled_pdev);
+	else if (!oled_pdev)
+		err = -ENODEV;
+
+	if (err) {
+		pr_err("%s: failed to install OELD device.\n", __func__);
+		platform_driver_unregister(&oled_driver);
+		oled_pdev = NULL;
+	}
+	return err;
+}
+
+static void rn_oled_exit(void)
+{
+	if (oled_pdev) {
+		platform_device_unregister(oled_pdev);
+		platform_driver_unregister(&oled_driver);
+		oled_pdev = NULL;
+	}
+}
+
+/* This module must be loaded after readynas-io. */
+device_initcall_sync(rn_oled_init);
+module_exit(rn_oled_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NETGEAR OLED bitmapped character display driver");
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
diff -ruN a/drivers/platform/readynas/readynas-pmbus.c b/drivers/platform/readynas/readynas-pmbus.c
--- a/drivers/platform/readynas/readynas-pmbus.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/readynas-pmbus.c	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,596 @@
+/**
+ * Redundant PSU - lm_sensors compatible PMBus support for ReadyNAS X86
+ *
+ * Copyright 2016 Hiro Sugawara <hiro.sugawara@netgear.com>
+ */
+
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/proc_fs.h>
+#include <linux/i2c.h>
+#include <linux/kthread.h>
+
+#include "../../hwmon/pmbus/pmbus.h"
+#include "readynas-io.h"
+
+int num_pmbus_clients = 2;
+
+extern void __i2c_nct6775_reset(struct i2c_adapter *);
+extern void __pmbus_set_id_table(const struct i2c_device_id *id_table);
+extern const u8 *__pmbus_set_supported_regs(const u8 *regs);
+
+/* DELTA PSU supports only one page. Trying to set to page other than #0,
+ * like other invalid parameter values, results in Unsupported Value and
+ * PEC (incorrect) errors in STATUS_CML, which cannot be cleared by
+ * CLEAR_FAULTS until the system is restarted from poweroff.
+ * Letting PMBus driver know there's only one page works around this.
+ */
+static const struct i2c_device_id pmbus_delt_id_table[] = {
+	{"pmbus", 1},
+	{}
+};
+
+/* DELTA PSU sets Unsupported Command error in STATUS_CML, which cannot be
+ * cleared by CLEAR_FAULTS until the system is restarted from poweroff.
+ * Filtering commands with a known good command list works around this.
+ */
+static const u8 pmbus_delt_supported_regs[] = {
+	PMBUS_VOUT_MODE,
+	PMBUS_FAN_CONFIG_12,
+
+	PMBUS_IOUT_OC_FAULT_LIMIT,
+	PMBUS_IOUT_OC_WARN_LIMIT,
+	PMBUS_OT_WARN_LIMIT,
+
+	PMBUS_IIN_OC_FAULT_LIMIT,
+	PMBUS_IIN_OC_WARN_LIMIT,
+	PMBUS_POUT_OP_WARN_LIMIT,
+
+	PMBUS_READ_VIN,
+	PMBUS_READ_IIN,
+	PMBUS_READ_VOUT,
+	PMBUS_READ_IOUT,
+	PMBUS_READ_TEMPERATURE_1,
+	PMBUS_READ_TEMPERATURE_2,
+	PMBUS_READ_FAN_SPEED_1,
+	PMBUS_READ_POUT,
+	PMBUS_READ_PIN,
+	0
+};
+
+static void pmbus_delt_init(void)
+{
+	__pmbus_set_id_table(pmbus_delt_id_table);
+}
+
+/* ZIPPY PSU for RR4360 replies bogus values for unsupported registers.
+ */
+static const u8 pmbus_zippy_supported_regs[] = {
+	PMBUS_VOUT_MODE,
+	PMBUS_FAN_CONFIG_12,
+
+	PMBUS_READ_VIN,
+	PMBUS_READ_VOUT,
+	PMBUS_READ_IOUT,
+	PMBUS_READ_TEMPERATURE_1,
+	PMBUS_READ_POUT,
+	PMBUS_READ_PIN,
+	0
+};
+
+static u8 pmbus_min_supported_regs[] = {
+	PMBUS_VOUT_MODE,
+	PMBUS_FAN_CONFIG_12,
+
+	PMBUS_READ_VIN,
+	PMBUS_READ_VOUT,
+	PMBUS_READ_IOUT,
+	PMBUS_READ_TEMPERATURE_1,
+	PMBUS_READ_POUT,
+	PMBUS_READ_PIN,
+	0
+};
+
+/* Supported PSU type search list.
+ * More specific (i.e. w/ mfr_model, mfr_revision) entries must be listed
+ * earlier.
+ */
+static struct pmbus_psu {
+	const char *mfr_id, *mfr_model, *mfr_revision;
+	unsigned short flags;	/* To be copied to client and adapter. */
+	void (*init)(void);
+	const u8 *supported_regs;
+} pmbus_psu[] = {
+	{
+		.mfr_id	= "ZIPPY",
+		.supported_regs	= pmbus_zippy_supported_regs,
+	}, {
+		.mfr_id	= "DELT",
+		.init	= pmbus_delt_init,
+		.flags	= I2C_CLIENT_PEC_PMBUS_WRITE_ONLY,
+		.supported_regs	= pmbus_delt_supported_regs,
+	}, {
+		.mfr_id	= "ACBE",
+		.flags	= I2C_CLIENT_PEC_PMBUS_WRITE_ONLY,
+	}, {	.mfr_id = "",
+		.supported_regs	= pmbus_min_supported_regs,
+	}, {}
+};
+
+static struct pmbus_adapter_priv {
+	const char *compatible;
+	const char **adapter_names;
+	struct i2c_adapter *adapter;
+	void (*adapter_reset)(struct i2c_adapter *);
+	int num_psus;	/* Default: 2 */
+	struct pmbus_psu *psu;
+} pmbus_adapter_priv[] = {
+	{
+		.compatible	= "rnx220",
+		.adapter_names	= rn_i2c_adapters_nct677x,
+		.adapter_reset	= __i2c_nct6775_reset,
+	}, {
+		.compatible	= "rrx312",
+		.adapter_names	= rn_i2c_adapters_ipch,
+	}, {
+		.compatible	= "rr4360",
+		.adapter_names	= rn_i2c_adapters_ipch,
+		.num_psus	= 4,
+	}, {}
+};
+
+/* NCT SMBus is multiplexed with GPIO. Determine if we want to use SMBus. */
+int rn_use_i2c_nct6775(void)
+{
+	return readynas_io_compatible("rnx220");
+}
+
+static char pmbus_mfr_id[32], pmbus_mfr_model[32], pmbus_mfr_revision[32];
+
+static struct pmbus_client_priv {
+	int index;
+	struct i2c_adapter *adapter;
+	struct i2c_board_info *i2c_info;
+	struct i2c_client *client;
+	struct proc_dir_entry	*clear_proc,
+				*voltage_proc;
+} *pmbus_client_priv;
+
+static int pmbus_adapter_reset_show(struct seq_file *s, void *v)
+{
+        seq_printf(s, "write any to reset PMBus adapter\n");
+        return 0;
+}
+
+static ssize_t pmbus_adapter_reset_write(struct file *file,
+					const char __user *buffer,
+					size_t count, loff_t *off)
+{
+	struct pmbus_adapter_priv *apriv = pde_data(file_inode(file));
+
+	apriv->adapter_reset(apriv->adapter);
+        return count;
+}
+
+static int pmbus_adapter_reset_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmbus_adapter_reset_show, pde_data(inode));
+}
+
+static const struct proc_ops pmbus_adapter_reset_fop = {
+	.proc_open	= pmbus_adapter_reset_open,
+	.proc_read	= seq_read,
+	.proc_write	= pmbus_adapter_reset_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int pmbus_clear_show(struct seq_file *s, void *v)
+{
+        seq_printf(s, "write any to clear PMBus faults\n");
+        return 0;
+}
+
+static ssize_t pmbus_clear_write(struct file *file,
+					const char __user *buffer,
+					size_t count, loff_t *off)
+{
+	struct pmbus_client_priv *cpriv = pde_data(file_inode(file));
+
+	i2c_smbus_xfer(cpriv->adapter, cpriv->i2c_info->addr, 0,
+			I2C_SMBUS_WRITE, PMBUS_CLEAR_FAULTS,
+			I2C_SMBUS_BYTE, NULL);
+        return count;
+}
+
+static int pmbus_clear_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmbus_clear_show, pde_data(inode));
+}
+
+static const struct proc_ops pmbus_clear_fop = {
+	.proc_open	= pmbus_clear_open,
+	.proc_read	= seq_read,
+	.proc_write	= pmbus_clear_write,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int pmbus_voltage_show(struct seq_file *s, void *v)
+{
+	struct pmbus_client_priv *cpriv = s->private;
+	union i2c_smbus_data i2c_data;
+	int err = i2c_smbus_xfer(cpriv->adapter,
+				cpriv->i2c_info->addr, 0,
+				I2C_SMBUS_READ, 0x88,
+				I2C_SMBUS_WORD_DATA, &i2c_data);
+	if (err)
+		return err;
+	seq_printf(s, "%u\n", i2c_data.word);
+        return 0;
+}
+
+static int pmbus_voltage_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmbus_voltage_show, pde_data(inode));
+}
+
+static const struct proc_ops pmbus_voltage_fop = {
+	.proc_open	= pmbus_voltage_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int pmbus_mfr_show(struct seq_file *s, void *v)
+{
+	seq_printf(s, "%s\n%s\n%s\n", pmbus_mfr_id,
+				pmbus_mfr_model,
+				pmbus_mfr_revision);
+        return 0;
+}
+
+static int pmbus_mfr_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pmbus_mfr_show, pde_data(inode));
+}
+
+static const struct proc_ops pmbus_mfr_fop = {
+	.proc_open	= pmbus_mfr_open,
+	.proc_read	= seq_read,
+	.proc_lseek	= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static struct proc_dir_entry
+	*pmbus_adapter_reset_proc,
+	*pmbus_mfr_proc;
+
+static void pmbus_adapter_reset_procfs_init(struct pmbus_adapter_priv *apriv)
+{
+	pmbus_adapter_reset_proc =
+			readynas_proc_create("pmbus_reset", 0644,
+					&pmbus_adapter_reset_fop, apriv);
+}
+
+static void pmbus_client_procfs_init(struct pmbus_client_priv *cpriv)
+{
+	char name[20];
+
+	sprintf(name, "psu%d_clear", cpriv->index + 1);
+	cpriv->clear_proc = readynas_proc_create(name, 0644,
+					&pmbus_clear_fop, cpriv);
+
+	sprintf(name, "psu%d_vin", cpriv->index + 1);
+	cpriv->voltage_proc = readynas_proc_create(name, 0644,
+					&pmbus_voltage_fop, cpriv);
+}
+
+static void __pmbus_mfr(struct pmbus_adapter_priv *apriv, u8 idx,
+			struct i2c_board_info *info, char *buf)
+{
+	union i2c_smbus_data i2c_data;
+	int i, err = -ENODEV;
+
+	for (i = 0; i < num_pmbus_clients; i++)
+		if (!(err = i2c_smbus_xfer(apriv->adapter, info[i].addr, 0,
+			I2C_SMBUS_READ, idx,
+			I2C_SMBUS_BLOCK_DATA, &i2c_data))) {
+			unsigned int len = i2c_data.block[0];
+
+			if (0 < len && len < I2C_SMBUS_BLOCK_MAX) {
+				memcpy(buf, &i2c_data.block[1], len - 1);
+				buf[len - 1] = '\0';
+				break;
+			}
+		}
+}
+
+static void pmbus_mfr_procfs_init(struct pmbus_adapter_priv *apriv,
+					struct i2c_board_info *info)
+{
+	__pmbus_mfr(apriv, PMBUS_MFR_ID, info, pmbus_mfr_id);
+	__pmbus_mfr(apriv, PMBUS_MFR_MODEL, info, pmbus_mfr_model);
+	__pmbus_mfr(apriv, PMBUS_MFR_REVISION, info, pmbus_mfr_revision);
+
+	pmbus_mfr_proc = readynas_proc_create("pmbus_mfr", 0644,
+						&pmbus_mfr_fop, apriv);
+}
+
+static void pmbus_procfs_exit(void)
+{
+	int i;
+
+	for (i = 0; i < num_pmbus_clients; i++) {
+		if (pmbus_client_priv[i].voltage_proc) {
+			proc_remove(pmbus_client_priv[i].voltage_proc);
+			pmbus_client_priv[i].voltage_proc = NULL;
+		}
+		if (pmbus_client_priv[i].clear_proc) {
+			proc_remove(pmbus_client_priv[i].clear_proc);
+			pmbus_client_priv[i].clear_proc = NULL;
+		}
+	}
+
+	if (pmbus_mfr_proc) {
+		proc_remove(pmbus_mfr_proc);
+		pmbus_mfr_proc = NULL;
+	}
+	if (pmbus_adapter_reset_proc) {
+		proc_remove(pmbus_adapter_reset_proc);
+		pmbus_adapter_reset_proc = NULL;
+	}
+}
+
+extern int pmbus_num_attributes(struct i2c_client *);
+static int pmbus_client_probe(struct pmbus_client_priv *cpriv)
+{
+	union i2c_smbus_data i2c_data;
+	int err;
+
+	/* Send CLEAR_FAULTS command. */
+	if ((err = i2c_smbus_xfer(cpriv->adapter,
+			cpriv->i2c_info->addr,
+			(cpriv->i2c_info->flags &
+					I2C_CLIENT_PEC_PMBUS_WRITE_ONLY) ?
+				I2C_CLIENT_PEC : 0,
+			I2C_SMBUS_WRITE, PMBUS_CLEAR_FAULTS,
+			I2C_SMBUS_BYTE, NULL)))
+		return err;
+	msleep(10);
+	/* Dummy read-data for preventing receive-byte. */
+	if ((err = i2c_smbus_xfer(cpriv->adapter,
+			cpriv->i2c_info->addr, 0,
+			I2C_SMBUS_READ, PMBUS_STATUS_BYTE,
+			I2C_SMBUS_BYTE_DATA, &i2c_data)))
+		return err;
+
+	cpriv->client = i2c_new_client_device(cpriv->adapter, cpriv->i2c_info);
+
+	/**
+	 * i2c_new_client_device() eventually calls bus_probe_device(),
+	 * which does not return status.
+	 * Check the  etected number of PMBus attributes for
+	 * determining the PMBus device registration failure.
+	 */
+	if (cpriv->client && !pmbus_num_attributes(cpriv->client)) {
+		i2c_unregister_device(cpriv->client);
+		cpriv->client = NULL;
+		err = -EIO;
+	}
+	return err;
+}
+
+/* A background thread for probing initially undetected PSUs.
+ * This thread runs only if any PSU is missing at initialization time
+ * and will exit when all PSUs are detected.
+ */
+static struct task_struct *pmbus_probe_kthread;
+static int pmbus_client_probe_loop(void *data)
+{
+	while (!kthread_should_stop()) {
+		int i, missing = 0;
+
+		msleep_interruptible(30 * HZ);
+
+		for (i = 0; i < num_pmbus_clients; i++) {
+			struct pmbus_client_priv *cpriv = &pmbus_client_priv[i];
+
+			if (!cpriv->client && pmbus_client_probe(cpriv))
+				missing++;
+		}
+		if (!missing)
+			break;
+	}
+	return 0;
+}
+
+static int rn_pmbus_probe(struct platform_device *pdev)
+{
+	struct pmbus_adapter_priv *apriv = dev_get_platdata(&pdev->dev);
+	struct i2c_adapter *adapter = apriv->adapter;
+	int i, err;
+	static struct i2c_board_info psu_i2c_info[] = {
+		{ I2C_BOARD_INFO("pmbus", 0x58), },
+		{ I2C_BOARD_INFO("pmbus", 0x59), },
+		{ I2C_BOARD_INFO("pmbus", 0x5a), },
+		{ I2C_BOARD_INFO("pmbus", 0x5b), },
+		{}
+	};
+
+	pr_info("%s: probing PMBus devices on %s.\n",
+		__func__, adapter->name);
+
+	apriv->psu = NULL;
+	if (apriv->adapter_reset) {
+		pmbus_adapter_reset_procfs_init(apriv);
+		apriv->adapter_reset(adapter);
+	}
+	pmbus_mfr_procfs_init(apriv, psu_i2c_info);
+	pr_info("%s: PSU model: %s %s %s\n", __func__,
+			pmbus_mfr_id, pmbus_mfr_model, pmbus_mfr_revision);
+
+	/* Look for best-match PSU profile */
+	for (i = 0; pmbus_psu[i].mfr_id; i++) {
+		if (strcasecmp(pmbus_psu[i].mfr_id, pmbus_mfr_id))
+			continue;
+		if (!pmbus_psu[i].mfr_model) {
+			apriv->psu = &pmbus_psu[i];
+			break;
+		} else if (strcasecmp(pmbus_psu[i].mfr_model, pmbus_mfr_model))
+			continue;
+		else if (!pmbus_psu[i].mfr_revision) {
+			apriv->psu = &pmbus_psu[i];
+			break;
+		} else if (!strcasecmp(pmbus_psu[i].mfr_revision,
+						pmbus_mfr_revision)) {
+			apriv->psu = &pmbus_psu[i];
+			break;
+		}
+	}
+
+	if (!apriv->psu) {
+		pr_warn("%s: PSU not found in support list"
+			" - using minimal config\n", __func__);
+		apriv->psu = &pmbus_psu[i - 1];
+	}
+	if (apriv->psu->init)
+		apriv->psu->init();
+	if (apriv->psu->supported_regs)
+		__pmbus_set_supported_regs(apriv->psu->supported_regs);
+
+	for (i = 0; i < num_pmbus_clients; i++) {
+		struct pmbus_client_priv *cpriv = &pmbus_client_priv[i];
+
+		if (apriv->psu)
+			psu_i2c_info[i].flags = apriv->psu->flags;
+		cpriv->index = i;
+		cpriv->adapter = adapter;
+		cpriv->i2c_info = &psu_i2c_info[i];
+
+		pmbus_client_procfs_init(cpriv);
+
+		if (pmbus_client_probe(cpriv))
+			pr_err("%s: PMBus failed to detect PSU at 0x%x.\n",
+				__func__, psu_i2c_info[i].addr);
+	}
+
+	/* Successful if any address is responsive. */
+	err = -EIO;
+	for (i = 0; i < num_pmbus_clients; i++)
+		if (pmbus_client_priv[i].client)
+			err = 0;
+		else if (!pmbus_probe_kthread) {
+			pmbus_probe_kthread =
+				kthread_run(pmbus_client_probe_loop, 0,
+						"pmbus_probe");
+			if (IS_ERR(pmbus_probe_kthread)) {
+				pr_err("%s: Failed to start PMBus client "
+					"prober thread.\n", __func__);
+				err = PTR_ERR(pmbus_probe_kthread);
+			}
+		}
+	if (err == -EIO)
+		pr_err("%s: No PMBus devices found.\n", __func__);
+	return err;
+}
+
+static int rn_pmbus_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < num_pmbus_clients; i++) {
+		if (pmbus_client_priv[i].client)
+			i2c_unregister_device(pmbus_client_priv[i].client);
+		pmbus_client_priv[i].client = NULL;
+	}
+	return 0;
+}
+
+
+struct platform_driver rn_pmbus_driver = {
+	.probe	= rn_pmbus_probe,
+	.remove	= rn_pmbus_remove,
+	.driver = { .name	= "rn-pmbus", },
+};
+
+static struct platform_device *pmbus_pdev;
+
+static int rn_pmbus_init(void)
+{
+	struct i2c_adapter *adapter;
+	int err, i;
+	struct pmbus_adapter_priv *apriv =
+		__compatible_find(pmbus_adapter_priv, compatible, 0, "");
+
+	if (!apriv->adapter_names || !*apriv->adapter_names)
+		return 0;
+
+	pr_info("%s: initializing PMBus for %s...\n",
+			__func__, *apriv->adapter_names);
+
+	adapter = readynas_i2c_adapter_find(apriv->adapter_names);
+	if (IS_ERR_OR_NULL(adapter)) {
+		pr_err("%s: failed to find PMBus adapter %s\n",
+			__func__, *apriv->adapter_names);
+		return adapter ? PTR_ERR(adapter) : -ENODEV;
+	}
+
+	apriv->adapter = adapter;
+	if (apriv->num_psus)
+		num_pmbus_clients = apriv->num_psus;
+
+	if (!(pmbus_client_priv =
+		kzalloc(sizeof(*pmbus_client_priv) * num_pmbus_clients,
+			GFP_KERNEL))) {
+		pr_err( "%s: failed to allocate cpriv memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	if ((err = platform_driver_register(&rn_pmbus_driver))) {
+		pr_err( "%s: failed to register ReadyNAS PMBus driver.\n",
+			__func__);
+		return err;
+	}
+
+	pmbus_pdev = platform_device_register_data(NULL,
+					rn_pmbus_driver.driver.name, -1,
+					apriv, sizeof *apriv);
+	if (IS_ERR_OR_NULL(pmbus_pdev)) {
+		err = pmbus_pdev ? PTR_ERR(pmbus_pdev) : -EIO;
+
+		platform_driver_unregister(&rn_pmbus_driver);
+		pmbus_pdev = NULL;
+		return err;
+	}
+
+	for (i = 0; i < num_pmbus_clients; i++)
+		if (pmbus_client_priv[i].client)
+			return 0;
+	platform_driver_unregister(&rn_pmbus_driver);
+	pmbus_pdev = NULL;
+	return -ENODEV;
+}
+
+static void rn_pmbus_exit(void)
+{
+	if (pmbus_pdev) {
+		platform_device_unregister(pmbus_pdev);
+		platform_driver_unregister(&rn_pmbus_driver);
+		pmbus_pdev = NULL;
+	}
+	if (pmbus_client_priv)
+		pmbus_procfs_exit();
+	kfree(pmbus_client_priv);
+	pmbus_client_priv = NULL;
+}
+
+/* This module must be loaded after GPIO and I2C. */
+device_initcall_sync(rn_pmbus_init);
+module_exit(rn_pmbus_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("NETGEAR PMBus driver");
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
diff -ruN a/drivers/platform/readynas/sx8635.h b/drivers/platform/readynas/sx8635.h
--- a/drivers/platform/readynas/sx8635.h	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/platform/readynas/sx8635.h	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,1049 @@
+/*
+ * SX8635 specifics.
+ * NOTE: the includes listed below are required for the development
+ * board this was written on using the OMAP processor. These defines
+ * may be different depending on the functions the specific processor
+ * uses.
+ *
+ * Copyright 2012 Semtech Corp.
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/mfd/twl.h>
+#include <linux/regulator/machine.h>
+#include <linux/gpio.h>
+
+#include <linux/input/smtc/misc/sx8635_platform_data.h>
+#include <linux/input/smtc/misc/sx8635_i2c_reg.h>
+#include <linux/input/smtc/misc/sx8635_spm_cfg.h>
+#include <linux/input/smtc/misc/sx8635_platform_data.h>
+#include <linux/input/smtc/misc/sx8635_i2c_reg.h>
+#include <linux/input/smtc/misc/sx8635_spm_cfg.h>
+
+static int sx8635_gpio = -1;
+
+static int sx8635_get_nirq_state(void)
+{
+	return (sx8635_gpio >= 0) && !gpio_get_value(sx8635_gpio);
+}
+
+/* Define Registers that need to be initialized to values different than
+ * the default
+ *************************************
+ * Add registers to this by writing
+ * {
+ *   .reg = REG_ADDRESS,
+ *   .val = REG_VALUE,
+ * },
+ ************************
+ * defines and values of register address can be found in
+ * sx863x_i2c_reg.h and sx8635_i2c_reg.h
+ *************************************
+ */
+static struct smtc_reg_data sx8635_i2c_reg_setup[] = {
+  {
+    .reg = SX863X_COMPOPMODE_REG,
+    .val = SX863X_COMPOPMODE_OPERATINGMODE_ACTIVE,
+  }
+};
+/* Define SPM configuration map to be intialized to values different than
+ * default. NOTE: Programming is done in 8 blocks.
+ * However, the driver is setup to perform needed reads and adjustments so
+ * that it is not required to add in extra default values.
+ * When final SPM values are obtained it may be advantageous to set them in
+ * NVM so that the driver does not need to initialize them.
+ *************************************
+ * Add spm registers to this by writing
+ * {
+ *   .reg = SPM_ADDRESS,
+ *   .val = SPM_VALUE,
+ * },
+ ************************
+ * defines and values of spm register address can be found in
+ * sx863x_spm_reg.h and sx8635_spm_reg.h
+ *************************************
+*/
+static struct smtc_reg_data sx8635_spm_cfg_setup[] = {
+  {
+    .reg = 0x00,
+    .val = 0x2F,
+  },
+  {
+    .reg =  0x01,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x02,
+    .val =  0x19,
+  },
+  {
+    .reg =  0x03,
+    .val =  0x0E,
+  },
+  {
+    .reg =  SX863X_I2CADDRESS_SPM,
+    .val =  0x2B,
+  },
+  {
+    .reg =  SX863X_ACTIVESCANPERIOD_SPM,
+    //.val =  0x01,
+    .val =  0x02,
+  },
+  {
+    .reg =  SX863X_DOZESCANPERIOD_SPM,
+    .val =  0x0D,
+  },
+  {
+    .reg = SX863X_PASSIVETIMER_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x08,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_CAPEMODEMISC_SPM,
+    .val =  0x04,
+  },
+  {
+    .reg =  SX863X_CAPMODE11_8_SPM,
+    .val =  0x0F,
+  },
+  {
+    .reg =  SX863X_CAPMODE7_4_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_CAPMODE3_0_SPM,
+    .val =  0xF5,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY0_1_SPM,
+    .val =  0x75,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY2_3_SPM,
+    //.val =  0x44,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY4_5_SPM,
+    //.val =  0x44,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY6_7_SPM,
+    //.val =  0x44,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY8_9_SPM,
+    //.val =  0x44,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_CAPSENSITIVITY10_11_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH0_SPM,
+    //.val =  0x70,
+    .val =  0x80,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH1_SPM,
+    .val =  0xB0,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH2_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH3_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH4_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH5_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH6_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH7_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH8_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH9_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH10_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPTHRESH11_SPM,
+    .val =  0x98,
+  },
+  {
+    .reg =  SX863X_CAPPERCOMP_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x20,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_BTNCFG_SPM,
+    //.val =  0x38,
+    .val =  0x30,
+  },
+  {
+    .reg =  SX863X_BTNAVGTHRESH_SPM,
+    .val =  0x48,
+  },
+  {
+    .reg =  SX863X_BTNCOMPNEGTHRESH_SPM,
+    //.val =  0x60,
+    .val =  0x48,
+  },
+  {
+    .reg =  SX863X_BTNCOMPNEGCNTMAX_SPM,
+    .val =  0x01,
+  },
+  {
+    .reg =  SX863X_BTNHYSTERESIS_SPM,
+    .val =  0x05,
+  },
+  {
+    .reg =  SX863X_BTNSTUCKATTIMEOUT_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_WHLCFG_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_WHLSTUCKATTIMEOUT_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_WHLHYSTERESIS_SPM,
+    .val =  0x05,
+  },
+  {
+    .reg =  0x2A,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_WHLNORMMSB_SPM,
+    .val =  0x01,
+  },
+  {
+    .reg =  SX863X_WHLNORMLSB_SPM,
+    .val =  0x40,
+  },
+  {
+    .reg =  SX863X_WHLAVGTHRESH_SPM,
+    .val =  0x50,
+  },
+  {
+    .reg =  SX863X_WHLCOMPNEGTHRESH_SPM,
+    //.val =  0x60,
+    .val =  0x50,
+  },
+  {
+    .reg =  SX863X_WHLCOMPNEGCNTMAX_SPM,
+    .val =  0x03,
+  },
+  {
+    .reg =  SX863X_WHLROTATETHRESH_SPM,
+    .val =  0x0A,
+  },
+  {
+    .reg =  SX863X_WHLOFFSET_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x32,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPWAKEUPSIZE_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPWAKEUPVALUE0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPWAKEUPVALUE1_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPWAKEUPVALUE2_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHT0_SPM,
+    .val =  0xBB,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHT1_SPM,
+    .val =  0xBB,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHT2_SPM,
+    .val =  0xBB,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHT3_SPM,
+    .val =  0xBB,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHTGRP0MSB_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHTGRP0LSB_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHTGRP1MSB_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_MAPAUTOLIGHTGRP1LSB_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x3F,
+    .val =  0x02,
+  },
+  {
+    .reg =  SX863X_GPIOMODE7_4_SPM,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_GPIOMODE3_0_SPM,
+    .val =  0x55,
+  },
+  {
+    .reg =  SX863X_GPIOOUTPWRUP_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOAUTOLIGHT_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOPOLARITY_SPM,
+    .val =  0x3F,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON0_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON1_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON2_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON3_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON4_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON5_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON6_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYON7_SPM,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF1_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF2_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF3_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF4_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF5_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF6_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTENSITYOFF7_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x55,
+    .val =  0xFF,
+  },
+  {
+    .reg =  SX863X_GPIOFUNCTION_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINCFACTOR_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIODECFACTOR_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINCTIME7_6_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINCTIME5_4_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINCTIME3_2_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINCTIME1_0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIODECTIME7_6_SPM,
+    .val =  0x44,
+  },
+  {
+    .reg =  SX863X_GPIODECTIME5_4_SPM,
+    .val =  0x44,
+  },
+  {
+    .reg =  SX863X_GPIODECTIME3_2_SPM,
+    .val =  0x44,
+  },
+  {
+    .reg =  SX863X_GPIODECTIME1_0_SPM,
+    .val =  0x44,
+  },
+  {
+    .reg =  SX863X_GPIOOFFDELAY7_6_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOOFFDELAY5_4_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOOFFDELAY3_2_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOOFFDELAY1_0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOPULLUPDOWN7_4_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOPULLUPDOWN3_0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTERRUPT7_4_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIOINTERRUPT3_0_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  SX863X_GPIODEBOUNCE_SPM,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6A,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6B,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6C,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6D,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6E,
+    .val =  0x00,
+  },
+  {
+    .reg =  0x6F,
+    .val =  0x50,
+  },
+  {
+    .reg =  SX863X_CAPPROXENABLE_SPM,
+    .val =  0x74,
+  },
+  {
+    .reg =  0x71,
+    .val =  0x10,
+  },
+  {
+    .reg =  0x72,
+    .val =  0x45,
+  },
+  {
+    .reg =  0x73,
+    .val =  0x02,
+  },
+  {
+    .reg =  0x74,
+    .val =  0xFF,
+  },
+  {
+    .reg =  0x75,
+    .val =  0xFF,
+  },
+  {
+    .reg =  0x76,
+    .val =  0xFF,
+  },
+  {
+    .reg =  0x77,
+    .val =  0xD5,
+  },
+  {
+    .reg =  0x78,
+    .val =  0x55,
+  },
+  {
+    .reg =  0x79,
+    .val =  0x55,
+  },
+  {
+    .reg =  0x7A,
+    .val =  0x7F,
+  },
+  {
+    .reg =  0x7B,
+    .val =  0x23,
+  },
+  {
+    .reg =  0x7C,
+    .val =  0x22,
+  },
+  {
+    .reg =  0x7D,
+    .val =  0x41,
+  },
+  {
+    .reg =  0x7E,
+    .val =  0xFF,
+  },
+};
+/***********************************************************/
+/***********************************************************/
+/* Define the intensities for each action. The name of the
+ * variable corresponds to what action the intensities are
+ * for.
+ *************************************
+ * Adding or removing different LEDs from being set can be
+ * done by adding or removing the io section.
+ * IO sections are defined by
+ * {
+ *   .io = IO_CHANGING,
+ *   .intensity = INTENSITY_TO_PROGRAM_TO_DEVICE,
+ * },
+ ************************
+ * defines of the currently used intensities and leds can be found in
+ * sx8635_platform_data.h
+ *************************************
+ */
+static struct _ledInfo wheelUpIntensities[] = {
+  {
+    .io = WHEEL_UP_LED,
+    .intensity = SMTC_ON_INTENSITY,
+  },
+  {
+    .io = WHEEL_RIGHT_LED,
+    .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+    .io = WHEEL_DOWN_LED,
+    .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+    .io = WHEEL_LEFT_LED,
+    .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+    .io = MIDDLE_BUTTON_LED,
+    .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+    .io = LOGO_LED,
+    .intensity = SMTC_ON_INTENSITY,
+  },
+};
+static struct _ledInfo wheelRightIntensities[] = {
+    {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_ON_INTENSITY,
+    },
+    {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = LOGO_LED,
+      .intensity = SMTC_ON_INTENSITY,
+    },
+};
+
+static struct _ledInfo wheelDownIntensities[] = {
+    {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_ON_INTENSITY,
+    },
+    {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+    },
+    {
+      .io = LOGO_LED,
+      .intensity = SMTC_ON_INTENSITY,
+    },
+};
+static struct _ledInfo wheelLeftIntensities[] = {
+  {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_ON_INTENSITY,
+  },
+  {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = LOGO_LED,
+      .intensity = SMTC_ON_INTENSITY,
+  },
+};
+
+
+static struct _ledInfo offIntensities[] = {
+  {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+  {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+  {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+  {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+  {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+  {
+      .io = LOGO_LED,
+      .intensity = SMTC_OFF_INTENSITY,
+  },
+};
+
+static struct _ledInfo buttonMiddleIntensities[] = {
+  {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_ON_INTENSITY,
+  },
+  {
+      .io = LOGO_LED,
+      .intensity = SMTC_ON_INTENSITY,
+  },
+};
+
+static struct _ledInfo buttonProxIntensities[] = {
+  {
+      .io = WHEEL_UP_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_RIGHT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_DOWN_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = WHEEL_LEFT_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = MIDDLE_BUTTON_LED,
+      .intensity = SMTC_PROX_INTENSITY,
+  },
+  {
+      .io = LOGO_LED,
+      .intensity = SMTC_ON_INTENSITY,
+  },
+};
+/***********************************************************/
+/***********************************************************/
+
+
+
+
+/***********************************************************/
+/***********************************************************/
+/* Define the input key to be used for each section (or action).
+ * The driver defines the action to be a touch and release when
+ * sending the action.
+ *************************************
+ * To change this, simply change the following.
+ *   .key = CORRESPONDING_KEY_CODE,
+ ************************
+ * defines of the inputs can be found in
+ * input.h
+ *************************************
+ */
+static inputEvent_t buttonMiddleInput = {
+  .key = KEY_OK,
+};
+
+static inputEvent_t wheelDownInput = {
+  .key = KEY_DOWN,
+};
+
+static inputEvent_t wheelRightInput = {
+  .key = KEY_FORWARD,
+};
+
+static inputEvent_t wheelUpInput = {
+  .key = KEY_UP,
+};
+
+static inputEvent_t wheelLeftInput = {
+  .key = KEY_BACK,
+};
+
+static inputEvent_t wheelMoveCWiseInput = {
+  .key = KEY_SCROLLDOWN,
+};
+
+static inputEvent_t wheelMoveCCWiseInput = {
+  .key = KEY_SCROLLUP,
+};
+/***********************************************************/
+/***********************************************************/
+
+/*************************************
+ * The following structs and arrays normally should not be changed as they
+ * group the above settings in their correct sections and actions.
+ * If items such as sending a specific input is needed when proximity
+ * occurs, it can be done here..
+ * Below is a description of the variables
+ *  .sectionID = SECTION_ID_FOR_DRIVER_IDENTIFYING,
+ *  .pLEDState = POINTER_TO_INTENSITY_TO_SEND,
+ *  .nLEDStateSize = SIZE_OF_LED_POINTER_AS_A_VARIABLE_LED_AMOUNT_CAN_BE_USED,
+ *  .pInputState = POINTER_TO_INPUT_STATE_TO_SEND,
+ ************************
+ * The pointers are defined above
+ *************************************
+*/
+/***********************************************************/
+/***********************************************************/
+/* Define some specific sections such as the off and proximity.
+ * Generally only the LED part will be used but this allows a
+ * more generic way to handle it in case later requirements
+ * change.
+  */
+static struct _touchSection allOffSection = {
+  .sectionID = ALL_OFF,
+  .pLEDState = offIntensities,
+  .nLEDStateSize = ARRAY_SIZE(offIntensities),
+  .pInputState = NULL,
+};
+static struct _touchSection proxSection = {
+    .sectionID = BUTTON_PROX,
+    .pLEDState = buttonProxIntensities,
+    .nLEDStateSize = ARRAY_SIZE(buttonProxIntensities),
+    .pInputState = NULL,
+};
+/* Define array of the sections specific to button sensors.
+ * This is the proximity and middle.
+ */
+static struct _touchSection buttonSectionArray[] = {
+  {
+    .sectionID = BUTTON_PROX,
+    .pLEDState = buttonProxIntensities,
+    .nLEDStateSize = ARRAY_SIZE(buttonProxIntensities),
+    .pInputState = NULL,
+  },
+  {
+    .sectionID = BUTTON_MIDDLE,
+    .pLEDState = buttonMiddleIntensities,
+    .nLEDStateSize = ARRAY_SIZE(buttonMiddleIntensities),
+    .pInputState = &buttonMiddleInput,
+  },
+
+};
+/* Define array of the sections specific to wheel sensors.
+ * This is WHEEL UP, DOWN, LEFT, RIGHT
+ */
+static struct _touchSection wheelSectionArray[] = {
+  {
+    .sectionID = WHEEL_DOWN,
+    .pLEDState = wheelDownIntensities,
+    .nLEDStateSize = ARRAY_SIZE(wheelDownIntensities),
+    .pInputState = &wheelDownInput,
+  },
+  {
+    .sectionID = WHEEL_RIGHT,
+    .pLEDState = wheelRightIntensities,
+    .nLEDStateSize = ARRAY_SIZE(wheelRightIntensities),
+    .pInputState = &wheelRightInput,
+  },
+  {
+    .sectionID = WHEEL_UP,
+    .pLEDState = wheelUpIntensities,
+    .nLEDStateSize = ARRAY_SIZE(wheelUpIntensities),
+    .pInputState = &wheelUpInput,
+  },
+  {
+    .sectionID = WHEEL_LEFT,
+    .pLEDState =   wheelLeftIntensities,
+     .nLEDStateSize = ARRAY_SIZE(wheelLeftIntensities),
+    .pInputState = &wheelLeftInput,
+  },
+};
+/***********************************************************/
+/***********************************************************/
+
+
+/***********************************************************/
+/***********************************************************/
+/* This is the main struct for keeping track of wheel and button information.
+ * .nSensors should be defined as the number of wheel sensors
+ * .move_threshold_factor This is a shift amount from the max value to define
+ *                         how far the wheel position must be changed to be
+ *                         seen as a move (rotate)
+ * .wheelSectionGroup This is the array defined above for the wheel sections
+ * .nWheelSectionGroupSize This is how many sections are in the wheel array
+ * .moveCWISE_InputState This is what input key should be used for a CWISE move
+ * .moveCCWISE_InputState This is the input key for a CCWISE movement
+ * .offSection This is what should be used when nothing is touching
+ * .proxSection This is what should be used when running on the proximity timer
+ * .buttonSectionGroup This is the array for button sections (middle/prox)
+ * .nButtonSectionGroupSize This is the size of the button section array
+ * .nLEDIncrementSteps The amount of steps to use when fade out/in
+ * .nLEDDelayBetweenSteps The delay between each fade out/in step
+ * .nLEDTimeoutOffDelay This is the delay for when using the proximity timer
+ */
+static struct _touchInformation touchInformation = {
+  .nSensors   = 8, /* must coincide with SPM settings */
+  .move_threshold_factor = 4,
+  .wheelSectionGroup = wheelSectionArray,
+  .nWheelSectionGroupSize = ARRAY_SIZE(wheelSectionArray),
+  .moveCWISE_InputState = &wheelMoveCWiseInput,
+  .moveCCWISE_InputState = &wheelMoveCCWiseInput,
+  .offSection = &allOffSection,
+  .proxSection = &proxSection,
+  .buttonSectionGroup = buttonSectionArray,
+  .nButtonSectionGroupSize = ARRAY_SIZE(buttonSectionArray),
+  .nLEDIncrementSteps = 40,
+  .nLEDDelayBetweenSteps = 1,
+  .nLEDTimeoutOffDelay = 30000,
+  .bLEDFadeInEnable = 0,
+  .bLEDFadeOutEnable = 1,
+};
+
+/***********************************************************/
+/* Main struct */
+static sx8635_platform_data_t sx8635_config = {
+  /* Function pointer to get the NIRQ state (1->NIRQ-low, 0->NIRQ-high) */
+  .get_is_nirq_low = sx8635_get_nirq_state,
+  /*  pointer to an initializer function. Here in case needed in the future */
+  .init_platform_hw = NULL,
+  /*  pointer to an exit function. Here in case needed in the future */
+  .exit_platform_hw = NULL,
+  /* number of i2c registers to initialize */
+  .i2c_reg_num = ARRAY_SIZE(sx8635_i2c_reg_setup),
+  /* number of spm registers to initialize */
+  .spm_cfg_num = ARRAY_SIZE(sx8635_spm_cfg_setup),
+  /* The i2c register array for initializing */
+  .i2c_reg = sx8635_i2c_reg_setup,
+  /* The spm register array for initializing */
+  .spm_cfg = sx8635_spm_cfg_setup,
+  /* Pointer to struct defined above */
+  .touchInformation = &touchInformation,
+};
+
+static const struct sx8635_touch_int_gpio {
+	const char *compatible;
+	const char *gpio_label;
+	const u16 gpio_num;
+	const u16 irq;
+} sx8635_touch_int_gpio[] = {
+	{"rn316",	"gpio_ich", 	2,	9},
+	{"rnx16"},	/* RN516/716 don't need and get killed by GPIO init. */
+	{},
+};
+
+static struct i2c_client *i2c_client;
+static struct i2c_board_info smtc_i2c_boardinfo = {
+	I2C_BOARD_INFO("sx8635", 0x2b),
+	.flags         = I2C_CLIENT_WAKE,
+	.irq           = 9,
+	.platform_data = &sx8635_config,
+};
+
+bool readynas_ignore_i801_acpi_conflict(struct i2c_adapter *adap)
+{
+	return i2c_client && i2c_client->adapter == adap;
+}
+
+static int sx8635_i2c_init(struct i2c_adapter *adapter)
+{
+	int err;
+	const struct sx8635_touch_int_gpio *gpio =
+		__compatible_find(sx8635_touch_int_gpio, compatible, 0, "");
+	struct gpio_chip *chip;
+
+	if (gpio && gpio->gpio_label &&
+			(chip = rn_gpiochip_find_by_label(gpio->gpio_label))) {
+		sx8635_gpio = chip->base + gpio->gpio_num;
+		pr_info("%s: TOUCH_INT %s:%u (%u)\n", __func__,
+			gpio->gpio_label, gpio->gpio_num, sx8635_gpio);
+		if ((err = gpio_request(sx8635_gpio, "SX8635_NIRQ")) ||
+			(err = gpio_direction_input(sx8635_gpio))) {
+			pr_err("%s: gpio_request() or gpio_direction_input() "
+				"failed (%d).\n", __func__, err);
+			return err;
+		}
+		gpiod_export(gpio_to_desc(sx8635_gpio), 0);
+		smtc_i2c_boardinfo.irq = gpio->irq;
+	}
+
+	pr_info("sx8635 i2c_new_client_device()\n");
+	err = 0;
+	i2c_client = i2c_new_client_device(adapter, &smtc_i2c_boardinfo);
+	if (!i2c_client)
+		err = -ENODEV;
+	if (err)
+		pr_err("%s: i2c_new_client_device() failed (%d)\n", __func__, err);
+	return err;
+}
+
+static void sx8635_i2c_exit(void)
+{
+	i2c_unregister_device(i2c_client);
+}
diff -ruN a/drivers/rtc/class.c b/drivers/rtc/class.c
--- a/drivers/rtc/class.c	2024-05-07 14:48:30.296473212 +0800
+++ b/drivers/rtc/class.c	2024-05-07 15:46:53.875848932 +0800
@@ -42,6 +42,8 @@
 }
 
 #ifdef CONFIG_RTC_HCTOSYS_DEVICE
+#include <linux/delay.h>
+
 /* Result of the last RTC to system clock attempt. */
 int rtc_hctosys_ret = -ENODEV;
 
@@ -58,13 +60,18 @@
 
 static void rtc_hctosys(struct rtc_device *rtc)
 {
-	int err;
+	int err, i;
 	struct rtc_time tm;
 	struct timespec64 tv64 = {
 		.tv_nsec = NSEC_PER_SEC >> 1,
 	};
 
-	err = rtc_read_time(rtc, &tm);
+	for (i = 0; i < 5; i++) {
+		err = rtc_read_time(rtc, &tm);
+		if (!err)
+			break;
+		mdelay(1000);
+	}
 	if (err) {
 		dev_err(rtc->dev.parent,
 			"hctosys: unable to read the hardware clock\n");
diff -ruN a/drivers/scsi/Kconfig b/drivers/scsi/Kconfig
--- a/drivers/scsi/Kconfig	2024-05-07 14:48:30.706475650 +0800
+++ b/drivers/scsi/Kconfig	2024-05-07 15:46:53.875848932 +0800
@@ -232,6 +232,15 @@
 	  Note that this setting also affects whether resuming from
 	  system suspend will be performed asynchronously.
 
+config MV_STAGGERED_SPINUP
+	bool "Stagger disk spinup"
+	default n
+	help
+	  Prevent too many disks from spinning up at the same time.  This
+	  is sometimes needed on systems with inadequate power supplies.
+
+	  If in doubt, say N.
+
 menu "SCSI Transports"
 	depends on SCSI
 
diff -ruN a/drivers/scsi/Makefile b/drivers/scsi/Makefile
--- a/drivers/scsi/Makefile	2024-05-07 14:48:30.426473985 +0800
+++ b/drivers/scsi/Makefile	2024-05-07 15:46:53.875848932 +0800
@@ -160,6 +160,7 @@
 scsi_mod-$(CONFIG_SCSI_DMA)	+= scsi_lib_dma.o
 scsi_mod-y			+= scsi_scan.o scsi_sysfs.o scsi_devinfo.o
 scsi_mod-$(CONFIG_SCSI_NETLINK)	+= scsi_netlink.o
+scsi_mod-$(CONFIG_MV_STAGGERED_SPINUP)	+= scsi_spinup.o
 scsi_mod-$(CONFIG_SYSCTL)	+= scsi_sysctl.o
 scsi_mod-$(CONFIG_SCSI_PROC_FS)	+= scsi_proc.o
 scsi_mod-$(CONFIG_BLK_DEBUG_FS)	+= scsi_debugfs.o
diff -ruN a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
--- a/drivers/scsi/scsi.c	2024-05-07 14:48:30.706475650 +0800
+++ b/drivers/scsi/scsi.c	2024-05-07 15:46:53.875848932 +0800
@@ -66,6 +66,10 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+#include <scsi/scsi_spinup.h>
+#endif
+
 #include "scsi_priv.h"
 #include "scsi_logging.h"
 
@@ -982,6 +986,13 @@
 {
 	int error;
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+	/* init will parse the kernel line for the spinup param */
+	error = scsi_spinup_init();
+	if (error)
+		return error;
+#endif
+
 	error = scsi_init_procfs();
 	if (error)
 		goto cleanup_queue;
diff -ruN a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
--- a/drivers/scsi/scsi_lib.c	2024-05-07 14:48:30.706475650 +0800
+++ b/drivers/scsi/scsi_lib.c	2024-05-07 15:46:53.875848932 +0800
@@ -41,6 +41,10 @@
 #include "scsi_priv.h"
 #include "scsi_logging.h"
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+#include <scsi/scsi_spinup.h>
+#endif
+
 /*
  * Size of integrity metadata is usually small, 1 inline sg should
  * cover normal cases.
@@ -57,6 +61,7 @@
 static DEFINE_MUTEX(scsi_sense_cache_mutex);
 
 static void scsi_mq_uninit_cmd(struct scsi_cmnd *cmd);
+static void scsi_device_block(struct scsi_device *sdev, void *data);
 
 int scsi_init_sense_cache(struct Scsi_Host *shost)
 {
@@ -1626,12 +1631,168 @@
 		return;
 	trace_scsi_dispatch_cmd_done(cmd);
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+	/*
+	 * TODO: add support to verify failed commands that didn't woke up the drive.
+	 */
+	if (scsi_spinup_enabled() &&
+	    memcmp(cmd->device->host->hostt->name, "ahci", 4) == 0) {
+		unsigned long flags;
+
+		spin_lock_irqsave(cmd->device->host->host_lock, flags);
+		if (cmd->device->sdev_power_state == SDEV_PW_SPINNING_UP) {
+			if (cmd->device->standby_timeout_secs > 0) {
+				/* had a timer before spinup, restarting the timer again */
+				cmd->device->sdev_power_state = SDEV_PW_STANDBY_TIMEOUT_WAIT;
+				standby_add_timer(cmd->device, cmd->device->standby_timeout_secs, standby_times_out);
+			}
+			else
+				cmd->device->sdev_power_state = SDEV_PW_ON;
+		}
+		spin_unlock_irqrestore(cmd->device->host->host_lock, flags);
+	}
+#endif
+
 	if (complete_directly)
 		blk_mq_complete_request_direct(req, scsi_complete);
 	else
 		blk_mq_complete_request(req);
 }
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+/* function to convert timeout value got from the user to jiffies */
+static int timeout_to_jiffies(int timeout)
+{
+	unsigned int secs=0;
+
+	switch(timeout) {
+		case 0:		//printf("off");
+			break;
+		case 252:	//printf("21 minutes");
+			secs = 21 * 60;
+			break;
+		case 253:	//printf("vendor-specific");
+			break;
+		case 254:	//printf("?reserved");
+			break;
+		case 255:	//printf("21 minutes + 15 seconds");
+			secs = 21 * 60 + 15;
+			break;
+		default:
+			if (timeout <= 240) {
+				secs = timeout * 5;
+			} else if (timeout <= 251) {
+				secs = ((timeout - 240) * 30) * 60;
+			} else
+				printk("illegal value\n");
+			break;
+	}
+	return msecs_to_jiffies ((secs-1) * 1000);
+}
+
+static int mv_staggered_spinup(struct scsi_cmnd *cmd)
+{
+	if (scsi_spinup_enabled() &&
+	    memcmp(cmd->device->host->hostt->name, "ahci",4) == 0) {
+		switch (cmd->cmnd[0]) {
+		case START_STOP:
+			switch (cmd->cmnd[4] & START_STOP_BIT) {
+			case 0x0: /* STOP command */
+				/* drive is going to sleep */
+				pr_debug("START_STOP Disk [%d] going to standby...\n", cmd->device->id);
+				cmd->device->sdev_power_state = SDEV_PW_STANDBY;
+				break;
+			case 0x1: /* START command */
+				/* drive is going to spin up, checking if possible */
+				if (scsi_spinup_device(cmd) == 1) {
+					/* not possible: drive queued for spinup in side scsi_spinup_device(),
+					   device queue is blocked and the current command is requeued */
+					scsi_device_block(cmd->device, NULL);
+					return 1;
+				}
+				/* drive was able to get the semaphore, will spinup now */
+				break;
+			default:
+				break;
+			}
+			break;
+		case READ_6:
+		case WRITE_6:
+		case READ_10:
+		case WRITE_10:
+		case SEEK_10:
+		case VERIFY_10:
+		case VERIFY:
+		case READ_16:
+		case WRITE_16:
+		case VERIFY_16:
+		case SYNCHRONIZE_CACHE:
+			/* drive is going to spin up, checking if possible */
+			if (scsi_spinup_device(cmd) == 1) {
+				/* not possible: drive queued for spinup in side scsi_spinup_device(),
+				   device queue is blocked and the current command is requeued */
+				//scsi_device_block(cmd->device, NULL);
+				//return 1;
+				mdelay(1000 * scsi_spinup_get_timeout());
+			}
+			/* drive was able to get the semaphore, will spinup now */
+			break;
+		case ATA_16:
+			switch (cmd->cmnd[14]) {
+			case STANDBY_IMMEDIATE:
+				/* drive is going to sleep */
+				pr_debug("ATA_16 Disk [%d] going to standby...\n", cmd->device->id);
+				cmd->device->sdev_power_state = SDEV_PW_STANDBY;
+				break;
+			case STANDBY_TIMEOUT:
+				if (cmd->cmnd[6] == 0) {
+					/* resetting the timeout standby value of 0 means remove standby timeout */
+					cmd->device->sdev_power_state = SDEV_PW_ON;
+					cmd->device->standby_timeout_secs = 0;
+				} else {
+					/*setting the timeout standby and starting the timer*/
+					pr_debug("ATA_16 Disk [%d] going to timeout standby with value [%d]...\n", cmd->device->id, (int) cmd->cmnd[6]);
+					cmd->device->sdev_power_state = SDEV_PW_STANDBY_TIMEOUT_WAIT;
+					standby_add_timer(cmd->device, timeout_to_jiffies((int) cmd->cmnd[6]), standby_times_out);
+				}
+				break;
+			default:
+				break;
+			}
+			break;
+		case ATA_12:
+			switch (cmd->cmnd[9]) {
+			case STANDBY_IMMEDIATE:
+				/* drive is going to sleep */
+				pr_debug("ATA_12 Disk [%d] going to standby...\n", cmd->device->id);
+				cmd->device->sdev_power_state = SDEV_PW_STANDBY;
+				break;
+			case STANDBY_TIMEOUT:
+				if (cmd->cmnd[4] == 0) {
+					/* resetting the timeout standby value of 0 means remove standby timeout */
+					cmd->device->sdev_power_state = SDEV_PW_ON;
+					cmd->device->standby_timeout_secs = 0;
+				} else {
+					/*setting the timeout standby and starting the timer*/
+					pr_debug("ATA_12 Disk [%d] going to timeout standby with value [%d]...\n", cmd->device->id, (int) cmd->cmnd[4]);
+					cmd->device->sdev_power_state = SDEV_PW_STANDBY_TIMEOUT_WAIT;
+					standby_add_timer(cmd->device, timeout_to_jiffies((int) cmd->cmnd[4]), standby_times_out);
+				}
+				break;
+			default:
+				break;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+	return 0;
+}
+#else
+static inline int mv_staggered_spinup(struct scsi_cmnd *cmd) { return 0; }
+#endif
+
 void scsi_done(struct scsi_cmnd *cmd)
 {
 	scsi_done_internal(cmd, false);
@@ -1751,6 +1912,8 @@
 		cmd->flags |= SCMD_TAGGED;
 	if (bd->last)
 		cmd->flags |= SCMD_LAST;
+	if (mv_staggered_spinup(cmd))
+		goto out_dec_target_busy;
 
 	scsi_set_resid(cmd, 0);
 	memset(cmd->sense_buffer, 0, SCSI_SENSE_BUFFERSIZE);
diff -ruN a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
--- a/drivers/scsi/scsi_priv.h	2024-05-07 14:48:30.706475650 +0800
+++ b/drivers/scsi/scsi_priv.h	2024-05-07 15:46:53.875848932 +0800
@@ -169,6 +169,31 @@
 static inline void scsi_netlink_exit(void) {}
 #endif
 
+/* scsi_spinup.c */
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+extern void standby_add_timer(struct scsi_device *, int,
+		void (*)(struct scsi_device *));
+extern int standby_delete_timer(struct scsi_device *);
+extern void standby_times_out(struct scsi_device *);
+extern int spinup_delete_timer(struct scsi_device *);
+extern int scsi_spinup_complete(void);
+extern int scsi_spinup_enabled(void);
+extern int scsi_spinup_get_timeout(void);
+extern int __init scsi_spinup_init(void);
+extern int scsi_spinup_device(struct scsi_cmnd *);
+#else
+/* only factive declerations for the compiler */
+static inline int scsi_spinup_init(void) {return 0;}
+static inline void standby_add_timer(void) {}
+static inline void standby_delete_timer(void) {}
+static inline void standby_times_out(void) {}
+static inline void spinup_delete_timer(void) {}
+static inline int scsi_spinup_complete(void) {return 0;}
+static inline int scsi_spinup_enabled(void) {return 0;}
+static inline int scsi_spinup_get_timeout(void) {return 0;}
+static inline void scsi_spinup_device(struct scsi_cmnd *) {}
+#endif
+
 /* scsi_pm.c */
 #ifdef CONFIG_PM
 extern const struct dev_pm_ops scsi_bus_pm_ops;
diff -ruN a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
--- a/drivers/scsi/scsi_scan.c	2024-05-07 14:48:30.706475650 +0800
+++ b/drivers/scsi/scsi_scan.c	2024-05-07 15:46:53.875848932 +0800
@@ -299,6 +299,19 @@
 	sdev->channel = starget->channel;
 	mutex_init(&sdev->state_mutex);
 	sdev->sdev_state = SDEV_CREATED;
+	/*
+	 * next section is for staggered spinup support.
+	 */
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+#ifdef CONFIG_MV_DISKS_POWERUP_TO_STANDBY
+	sdev->sdev_power_state = SDEV_PW_STANDBY;
+#else
+	sdev->sdev_power_state = SDEV_PW_ON;
+#endif
+	timer_setup(&sdev->standby_timeout, NULL, 0);
+	timer_setup(&sdev->spinup_timeout, NULL, 0);
+	sdev->standby_timeout_secs = 0;
+#endif
 	INIT_LIST_HEAD(&sdev->siblings);
 	INIT_LIST_HEAD(&sdev->same_target_siblings);
 	INIT_LIST_HEAD(&sdev->starved_entry);
diff -ruN a/drivers/scsi/scsi_spinup.c b/drivers/scsi/scsi_spinup.c
--- a/drivers/scsi/scsi_spinup.c	1970-01-01 08:00:00.000000000 +0800
+++ b/drivers/scsi/scsi_spinup.c	2024-05-07 15:46:53.875848932 +0800
@@ -0,0 +1,316 @@
+/*
+ *  SCSI Spinup specific structures and functions.
+ *
+ *  Copyright (c) 2009 Marvell,  All rights reserved.
+ *  Copyright (c) 2014 NETGEAR   All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/sched.h>
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/list.h>
+#include <linux/dmi.h>
+#include <linux/moduleparam.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_spinup.h>
+
+#include "scsi_priv.h"
+#include "scsi_logging.h"
+
+/* structure: spinup_config=<spinup_max>,<spinup_timout>
+   example: spinup_config=2,6 (max two disks spinning up, 6 seconds apart) */
+static char *cmdline = NULL;
+
+#ifdef DEBUG_SPIN_UP_QUEUE
+#define __DPRINTK(...)	printk(__VA_ARGS__)
+#else
+#define __DPRINTK(...)	do {} while(0)
+#endif
+
+/* Required to get the configuration string from the Kernel Command Line */
+int spinup_cmdline_config(char *s);
+__setup("spinup_config=", spinup_cmdline_config);
+
+int spinup_cmdline_config(char *s)
+{
+	cmdline = s;
+	return 1;
+}
+
+static unsigned int spinup_enabled = 0;
+static unsigned int spinup_max = 2;
+static unsigned int spinup_timeout = 6;
+static spinlock_t spinup_lock;
+static int scsi_spinup_ok(void);
+
+module_param_named(staggered_spinup, spinup_enabled, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(staggered_spinup, "0=disable, 1=enable staggered spin up");
+
+static atomic_t spinup_now;
+struct spinup_node {
+	struct list_head list;
+	struct scsi_device *sdev;
+};
+static struct list_head spinup_list;
+
+static int param_set_spinup_max(const char *val, const struct kernel_param *kp)
+{
+	int new_max = param_set_int(val, kp);
+
+	if (new_max <= 0)
+		return -EINVAL;
+
+	atomic_add(new_max - spinup_max, &spinup_now);
+	spinup_max = new_max;
+	return 0;
+}
+
+static struct kernel_param_ops params_ops_spinup_max = {
+	.set = param_set_spinup_max,
+	.get = param_get_uint,
+};
+module_param_cb(spinup_max, &params_ops_spinup_max, &spinup_max,
+		S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(spinup_max, "maximum number of spin-ups");
+module_param_named(spinup_timeout, spinup_timeout, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(spinup_timeout, "delay in staggered spin-ups in seconds");
+
+static void spinup_times_out(struct scsi_device *sdev);
+
+void standby_add_timer(struct scsi_device *sdev, int timeout,
+		    void (*complete)(struct scsi_device *))
+{
+	/*
+	 * If the clock was already running for this device, then
+	 * first delete the timer.  The timer handling code gets rather
+	 * confused if we don't do this.
+	 */
+	if (sdev->standby_timeout.function)
+		del_timer(&sdev->standby_timeout);
+
+	sdev->standby_timeout_secs = timeout;
+	sdev->standby_timeout.expires = timeout + jiffies ;
+	sdev->standby_timeout.function = (void (*)(struct timer_list *)) complete;
+
+	SCSI_LOG_ERROR_RECOVERY(5, printk("%s: scmd: %p, time:"
+					  " %d, (%p)\n", __FUNCTION__,
+					  sdev, timeout, complete));
+
+	add_timer(&sdev->standby_timeout);
+}
+
+int standby_delete_timer(struct scsi_device *sdev)
+{
+	int rtn = del_timer(&sdev->standby_timeout);
+
+	SCSI_LOG_ERROR_RECOVERY(5, printk("%s: scmd: %p,"
+					 " rtn: %d\n", __FUNCTION__,
+					 sdev, rtn));
+
+	sdev->standby_timeout.function = NULL;
+
+	return rtn;
+}
+
+
+void standby_times_out(struct scsi_device *sdev)
+{
+	unsigned long flags = 0;
+
+	__DPRINTK("\nDisk [%d] timeout done, going to sleep...\n",sdev->id);
+	spin_unlock_irqrestore(sdev->host->host_lock, flags);
+	sdev->sdev_power_state = SDEV_PW_STANDBY_TIMEOUT_PASSED;
+	spin_lock_irqsave(sdev->host->host_lock, flags);
+	standby_delete_timer(sdev);
+}
+
+static void spinup_add_timer(struct scsi_device *sdev, int timeout,
+		    void (*complete)(struct scsi_device *))
+{
+	/*
+	 * If the clock was already running for this device, then
+	 * first delete the timer.  The timer handling code gets rather
+	 * confused if we don't do this.
+	 */
+	if (sdev->spinup_timeout.function)
+		del_timer(&sdev->spinup_timeout);
+
+
+	sdev->spinup_timeout.expires = jiffies + msecs_to_jiffies (timeout * 1000);
+	sdev->spinup_timeout.function = (void (*)(struct timer_list *)) complete;
+
+	SCSI_LOG_ERROR_RECOVERY(5, printk("%s: scmd: %p, time:"
+					  " %d, (%p)\n", __FUNCTION__,
+					  sdev, timeout, complete));
+	add_timer(&sdev->spinup_timeout);
+}
+
+int spinup_delete_timer(struct scsi_device *sdev)
+{
+	int rtn;
+
+	rtn = del_timer(&sdev->spinup_timeout);
+
+	SCSI_LOG_ERROR_RECOVERY(5, printk("%s: scmd: %p,"
+					 " rtn: %d\n", __FUNCTION__,
+					 sdev, rtn));
+
+	sdev->spinup_timeout.function = NULL;
+
+	return rtn;
+}
+
+static void scsi_spinup_device_dequeue_next(void)
+{
+	struct list_head *ptr;
+	struct spinup_node *entry;
+
+	spin_lock(&spinup_lock);
+	if (!list_empty(&spinup_list)) {
+		ptr = spinup_list.next;
+		entry = list_entry(ptr, struct spinup_node, list);
+		__DPRINTK("\nNext Disk is entry: [%d] power state [%d]\n",
+				entry->sdev->id, entry->sdev->sdev_power_state);
+
+		if (scsi_spinup_ok()) {
+			entry->sdev->sdev_power_state = SDEV_PW_SPINNING_UP;
+			spinup_add_timer(entry->sdev,
+				scsi_spinup_get_timeout(), spinup_times_out);
+			scsi_internal_device_unblock_nowait(entry->sdev, SDEV_RUNNING);
+			pr_debug("Timeout - Disk [%d] spinning up...\n",
+				entry->sdev->id);
+			list_del(ptr);
+			kfree(entry);
+		}
+	}
+#ifdef DEBUG_SPIN_UP_QUEUE
+	printk("\n");
+	list_for_each(ptr, &spinup_list) {
+		entry = list_entry(ptr, struct spinup_node, list);
+		printk("[%d] ->", entry->sdev->id);
+	}
+	printk("[EOD]\n");
+#endif
+	spin_unlock(&spinup_lock);
+}
+
+static void spinup_times_out(struct scsi_device *sdev)
+{
+	scsi_spinup_complete();
+	spinup_delete_timer(sdev);
+	scsi_spinup_device_dequeue_next();
+}
+
+int scsi_spinup_enabled(void)
+{
+	return spinup_enabled;
+}
+
+int scsi_spinup_get_timeout(void)
+{
+	return spinup_timeout;
+}
+
+/* __setup kernel line parsing and setting up the spinup feature */
+int __init scsi_spinup_init(void)
+{
+	spin_lock_init(&spinup_lock);
+	atomic_set(&spinup_now, spinup_max);
+	INIT_LIST_HEAD(&spinup_list);
+	return 0;
+}
+
+static int scsi_spinup_device_queue(struct scsi_device *sdev)
+{
+	struct spinup_node *new;
+	unsigned long flags;
+
+	new = kmalloc(sizeof(struct spinup_node), GFP_NOWAIT);
+	if (!new)
+		return 1;
+	new->sdev = sdev;
+	spin_lock_irqsave(&spinup_lock, flags);
+	list_add_tail(&new->list, &spinup_list);
+
+#ifdef DEBUG_SPIN_UP_QUEUE
+	struct list_head *ptr;
+	struct spinup_node *entry;
+
+	printk("\n");
+	list_for_each(ptr, &spinup_list) {
+		entry = list_entry(ptr, struct spinup_node, list);
+		printk("[%d] ->",entry->sdev->id);
+	}
+	printk("[EOD]\n");
+#endif
+	spin_unlock_irqrestore(&spinup_lock, flags);
+
+	return 0;
+}
+
+int scsi_spinup_device(struct scsi_cmnd *cmd)
+{
+	struct scsi_device *sdev = cmd->device;
+
+	__DPRINTK("\nDisk [%d] scsi_spinup_device...\n", sdev->id);
+	switch (sdev->sdev_power_state) {
+	case SDEV_PW_STANDBY:
+	case SDEV_PW_STANDBY_TIMEOUT_PASSED:
+		/* disk will wait here to his turn to spinup */
+		__DPRINTK("\nDisk [%d] waiting to spinup...\n", sdev->id);
+		if (!scsi_spinup_ok()) {
+			if (scsi_spinup_device_queue(sdev) == 0) {
+				pr_debug("Disk [%d] queued up for spinup!\n", sdev->id);
+				sdev->sdev_power_state = SDEV_PW_WAIT_FOR_SPIN_UP;
+			}
+			return 1;
+		}
+		sdev->sdev_power_state = SDEV_PW_SPINNING_UP;
+		/* starting timer for the spinup process */
+		pr_debug("Disk [%d] spinning up...\n", sdev->id);
+		spinup_add_timer(sdev, scsi_spinup_get_timeout(), spinup_times_out);
+		break;
+	case SDEV_PW_STANDBY_TIMEOUT_WAIT:
+		standby_add_timer(sdev, sdev->standby_timeout_secs, standby_times_out);
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+static int scsi_spinup_ok(void)
+{
+	if (atomic_dec_if_positive(&spinup_now) >= 0) {
+		pr_debug("Down we go! [%d]\n", atomic_read(&spinup_now));
+		return 1;
+	}
+	return 0;
+}
+
+int scsi_spinup_complete(void)
+{
+	atomic_inc(&spinup_now);
+	__DPRINTK("\nUP we go!! [%d] \n",(int) atomic_read(&spinup_now) );
+	return 0;
+}
diff -ruN a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
--- a/drivers/scsi/scsi_sysfs.c	2024-05-07 14:48:30.676475471 +0800
+++ b/drivers/scsi/scsi_sysfs.c	2024-05-07 15:46:53.875848932 +0800
@@ -1460,6 +1460,20 @@
 	if (sdev->sdev_state == SDEV_DEL)
 		return;
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+	if (scsi_spinup_enabled()) {
+		if (sdev->standby_timeout_secs > 0) {
+			/* if the device had any standby timer */
+			standby_delete_timer(sdev);
+		}
+		if (sdev->spinup_timeout.function) {
+			/* deleting any spinup timer thats may be still there and freeing the semaphore */
+			spinup_delete_timer(sdev);
+			scsi_spinup_complete();
+		}
+	}
+#endif
+
 	if (sdev->is_visible) {
 		/*
 		 * If scsi_internal_target_block() is running concurrently,
diff -ruN a/drivers/target/iscsi/iscsi_target_auth.c b/drivers/target/iscsi/iscsi_target_auth.c
--- a/drivers/target/iscsi/iscsi_target_auth.c	2024-05-07 14:48:31.546480645 +0800
+++ b/drivers/target/iscsi/iscsi_target_auth.c	2024-05-07 15:46:53.885848990 +0800
@@ -34,13 +34,34 @@
 	}
 }
 
+static int chap_string_to_hex(unsigned char *dst, unsigned char *src, int len)
+{
+	int j = DIV_ROUND_UP(len, 2), rc;
+
+	rc = hex2bin(dst, src, j);
+	if (rc < 0)
+		pr_debug("CHAP string contains non hex digit symbols\n");
+
+	dst[j] = '\0';
+	return j;
+}
+
+static void chap_binaryhex_to_asciihex(char *dst, char *src, int src_len)
+{
+	int i;
+
+	for (i = 0; i < src_len; i++) {
+		sprintf(&dst[i*2], "%02x", (int) src[i] & 0xff);
+	}
+}
+
 static int chap_gen_challenge(
 	struct iscsit_conn *conn,
 	int caller,
 	char *c_str,
 	unsigned int *c_len)
 {
-	int ret;
+	int ret, i;
 	unsigned char *challenge_asciihex;
 	struct iscsi_chap *chap = conn->auth_protocol;
 
@@ -54,7 +75,12 @@
 	if (unlikely(ret))
 		goto out;
 
-	bin2hex(challenge_asciihex, chap->challenge,
+	/* Fix the challenge string - JASON QIAN, NETGEAR */
+	for (i = 0; i < chap->challenge_len; i++)
+		if (chap->challenge[i] == 0)
+			chap->challenge[i] = 'X';
+
+	chap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,
 				chap->challenge_len);
 	/*
 	 * Set CHAP_C, and copy the generated challenge into c_str.
@@ -330,11 +356,13 @@
 
 	switch (type) {
 	case HEX:
+#if 0
 		if (strlen(chap_r) != chap->digest_size * 2) {
 			pr_err("Malformed CHAP_R\n");
 			goto out;
 		}
-		if (hex2bin(client_digest, chap_r, chap->digest_size) < 0) {
+#endif
+		if (chap_string_to_hex(client_digest, chap_r, strlen(chap_r)) < 0) {
 			pr_err("Malformed CHAP_R: invalid HEX\n");
 			goto out;
 		}
@@ -394,7 +422,7 @@
 		goto out;
 	}
 
-	bin2hex(response, server_digest, chap->digest_size);
+	chap_binaryhex_to_asciihex(response, server_digest, chap->digest_size);
 	pr_debug("[server] %s Server Digest: %s\n",
 		chap->digest_name, response);
 
@@ -464,12 +492,13 @@
 			pr_err("CHAP_C exceeds maximum binary size of 1024 bytes\n");
 			goto out;
 		}
-
+#if 0
 		if (hex2bin(initiatorchg_binhex, initiatorchg,
 			    initiatorchg_len) < 0) {
 			pr_err("Malformed CHAP_C: invalid HEX\n");
 			goto out;
 		}
+#endif
 		break;
 	case BASE64:
 		initiatorchg_len = chap_base64_decode(initiatorchg_binhex,
@@ -549,7 +578,7 @@
 	/*
 	 * Convert response from binary hex to ascii hext.
 	 */
-	bin2hex(response, digest, chap->digest_size);
+	chap_binaryhex_to_asciihex(response, digest, chap->digest_size);
 	*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x%s",
 			response);
 	*nr_out_len += 1;
diff -ruN a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c
--- a/drivers/target/iscsi/iscsi_target_login.c	2024-05-07 14:48:31.546480645 +0800
+++ b/drivers/target/iscsi/iscsi_target_login.c	2024-05-07 15:46:53.885848990 +0800
@@ -758,6 +758,11 @@
 	}
 
 	iscsi_set_session_parameters(sess->sess_ops, conn->param_list, 1);
+
+	/* JASON QIAN @ NETGEAR */
+	if(sess->sess_ops && strstr(sess->sess_ops->InitiatorName, "novell"))
+		conn->stat_sn = 1;
+
 	iscsi_release_param_list(conn->param_list);
 	conn->param_list = NULL;
 
diff -ruN a/drivers/target/iscsi/iscsi_target_parameters.c b/drivers/target/iscsi/iscsi_target_parameters.c
--- a/drivers/target/iscsi/iscsi_target_parameters.c	2024-05-07 14:48:31.546480645 +0800
+++ b/drivers/target/iscsi/iscsi_target_parameters.c	2024-05-07 15:46:53.885848990 +0800
@@ -811,6 +811,11 @@
 	char *tmpptr;
 	int value = 0;
 
+	if( !param || !param->name || !value_ptr) {
+		printk(KERN_ERR "Bad parameter in iscsi_check_numerical_value.\n");
+		return -1;
+	}
+
 	value = simple_strtoul(value_ptr, &tmpptr, 0);
 
 	if (IS_TYPERANGE_0_TO_2(param)) {
diff -ruN a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c
--- a/drivers/target/target_core_file.c	2024-05-07 14:48:31.566480764 +0800
+++ b/drivers/target/target_core_file.c	2024-05-07 15:46:53.885848990 +0800
@@ -23,12 +23,67 @@
 #include <linux/scatterlist.h>
 #include <scsi/scsi_proto.h>
 #include <asm/unaligned.h>
+#include <net/netlink.h>
+#include <net/net_namespace.h>
 
 #include <target/target_core_base.h>
 #include <target/target_core_backend.h>
 
 #include "target_core_file.h"
 
+#define NETLINK_READYNAS 31
+#define NETLINK_CASTGROUP 1
+
+static struct sock *nls;
+
+static void netlink_null_input(struct sk_buff *skb)
+{
+	return;
+}
+
+static int fd_netlink_event(struct sock *nls, char *device)
+{
+	const u32 group = NETLINK_CASTGROUP;
+	struct nlmsghdr *nlh;
+	struct sk_buff *skb;
+	int ret = 0;
+
+	/* our backstore path lenth
+	 * /volume-name/lun-name/..., 256 should be enough
+	 */
+	int size = 256;
+
+	if (!nls)
+		return -EINVAL;
+
+	if (!netlink_has_listeners(nls, group)) {
+		pr_err("No listener?\n");
+		return -EAGAIN;
+	}
+
+	if (!(skb = nlmsg_new(size, GFP_KERNEL))) {
+		pr_err("%s: alloc_skb failed.\n", __func__);
+		return -ENOMEM;
+	}
+
+	nlh = nlmsg_put(skb, 0, 0, NLMSG_DONE, size, 0);
+	if (!nlh) {
+		kfree_skb(skb);
+		return -ENOMEM;
+	}
+
+	snprintf((char*)nlmsg_data(nlh), size, "%s", device);
+
+	NETLINK_CB(skb).dst_group = group;
+	ret = netlink_broadcast(nls, skb, 0, group, GFP_KERNEL);
+	if (ret) {
+		pr_err("%s: netlink broadcast failed.\n", __func__);
+		return -EAGAIN;
+	}
+
+	return 0;
+}
+
 static inline struct fd_dev *FD_DEV(struct se_device *dev)
 {
 	return container_of(dev, struct fd_dev, dev);
@@ -183,7 +238,9 @@
 			goto fail;
 		}
 
-		fd_dev->fd_block_size = FD_BLOCKSIZE;
+		if (!(fd_dev->fbd_flags & FBDF_HAS_BLOCK_SIZE)
+		    || !fd_dev->fd_block_size)
+			fd_dev->fd_block_size = FD_BLOCKSIZE;
 
 		/*
 		 * Limit WRITE_SAME w/ UNMAP=0 emulation to 8k Number of LBAs (NoLB)
@@ -309,6 +366,41 @@
 	return 0;
 }
 
+/*
+ * Check thin LUN soft threshold
+ * Here use emulate_tpu to check if this is thin LUN
+ * return true if threshold hit
+ */
+static bool tp_exceeded_soft_threshold(struct se_device *dev)
+{
+	struct fd_dev *fd_dev = FD_DEV(dev);
+	struct file *file = fd_dev->fd_file;
+
+	if (unlikely(!fd_dev || !file))
+		return false;
+
+	if ((fd_dev->fbd_flags & FBDF_HAS_THRESHOLD) && dev->dev_attrib.emulate_tpu) {
+		blkcnt_t used_blocks = file->f_inode ? file->f_inode->i_blocks : 0;
+
+		if (used_blocks >= fd_dev->fd_dev_thresh) {
+			if (!(fd_dev->fbd_flags & FDBD_THRESH_REPORTED)) {
+				fd_dev->fbd_flags |= FDBD_THRESH_REPORTED;
+				pr_warn("FILEIO: Thin LUN %s used blocks exceeded [%llu]\n",
+						fd_dev->fd_dev_name, fd_dev->fd_dev_thresh);
+				if (fd_netlink_event(nls, fd_dev->fd_dev_name))
+					 pr_err("FILEIO: LUN %s sent event fail.\n",
+							fd_dev->fd_dev_name);
+				return true;
+			}
+		} else if (fd_dev->fbd_flags & FDBD_THRESH_REPORTED) {
+			/* if space freed, reset reported=0 */
+			fd_dev->fbd_flags &= ~FDBD_THRESH_REPORTED;
+		}
+	}
+
+	return false;
+}
+
 static int fd_do_rw(struct se_cmd *cmd, struct file *fd,
 		    u32 block_size, struct scatterlist *sgl,
 		    u32 sgl_nents, u32 data_length, int is_write)
@@ -632,6 +724,9 @@
 				return rc;
 		}
 
+		if (tp_exceeded_soft_threshold(dev))
+			return TCM_TP_SOFT_THRESHOLD_EXCEEDED;
+
 		ret = fd_do_rw(cmd, file, dev->dev_attrib.block_size,
 			       sgl, sgl_nents, cmd->data_length, 1);
 		/*
@@ -693,7 +788,7 @@
 
 enum {
 	Opt_fd_dev_name, Opt_fd_dev_size, Opt_fd_buffered_io,
-	Opt_fd_async_io, Opt_err
+	Opt_fd_async_io, Opt_fd_dev_thresh, Opt_fd_block_size, Opt_err
 };
 
 static match_table_t tokens = {
@@ -701,6 +796,8 @@
 	{Opt_fd_dev_size, "fd_dev_size=%s"},
 	{Opt_fd_buffered_io, "fd_buffered_io=%d"},
 	{Opt_fd_async_io, "fd_async_io=%d"},
+	{Opt_fd_dev_thresh, "fd_dev_thresh=%s"},
+	{Opt_fd_block_size, "fd_block_size=%d"},
 	{Opt_err, NULL}
 };
 
@@ -716,6 +813,7 @@
 	if (!opts)
 		return -ENOMEM;
 
+	fd_dev->fbd_flags |= FDBD_HAS_BUFFERED_IO_WCE;
 	orig = opts;
 
 	while ((ptr = strsep(&opts, ",\n")) != NULL) {
@@ -755,6 +853,10 @@
 			ret = match_int(args, &arg);
 			if (ret)
 				goto out;
+			if (arg == 0) {
+				fd_dev->fbd_flags &= ~FDBD_HAS_BUFFERED_IO_WCE;
+				break;
+			}
 			if (arg != 1) {
 				pr_err("bogus fd_buffered_io=%d value\n", arg);
 				ret = -EINVAL;
@@ -781,6 +883,62 @@
 
 			fd_dev->fbd_flags |= FDBD_HAS_ASYNC_IO;
 			break;
+		case Opt_fd_dev_thresh:
+			arg_p = match_strdup(&args[0]);
+			if (!arg_p) {
+				ret = -ENOMEM;
+				break;
+			}
+			ptr = strchr(arg_p, '%');
+			if (ptr)
+			{
+				u64 blocks = div_u64(fd_dev->fd_dev_size, 512);
+				u8 pct;
+				*ptr = '\0';
+				ret = kstrtou8(arg_p, 10, &pct);
+				kfree(arg_p);
+				if (ret < 0 || pct > 100)
+				{
+					pr_err("invalid percentage for"
+							" fd_dev_thresh=\n");
+					goto out;
+				}
+				fd_dev->fd_dev_thresh = div_u64(blocks * pct, 100);
+			}
+			else
+			{
+				ret = kstrtoull(arg_p, 0, &fd_dev->fd_dev_thresh);
+				kfree(arg_p);
+				if (ret < 0) {
+					pr_err("kstrtoull() failed for"
+							" fd_dev_thresh=\n");
+					goto out;
+				}
+			}
+			pr_debug("FILEIO: Threshold Size: %llu"
+					" blocks\n", fd_dev->fd_dev_thresh);
+			if (fd_dev->fd_dev_thresh)
+				fd_dev->fbd_flags |= FBDF_HAS_THRESHOLD;
+			else
+				fd_dev->fbd_flags &= ~FBDF_HAS_THRESHOLD;
+			break;
+		case Opt_fd_block_size:
+			arg_p = match_strdup(&args[0]);
+			if (!arg_p) {
+				ret = -ENOMEM;
+				break;
+			}
+			ret = kstrtou32(arg_p, 0, &fd_dev->fd_block_size);
+			kfree(arg_p);
+			if (ret < 0) {
+				pr_err("kstrtou32() failed for"
+						" fd_block_size\n");
+				goto out;
+			}
+			pr_debug("FILEIO: Referencing Block Size: %u bytes\n",
+				 fd_dev->fd_block_size);
+			fd_dev->fbd_flags |= FBDF_HAS_BLOCK_SIZE;
+			break;
 		default:
 			break;
 		}
@@ -795,10 +953,11 @@
 {
 	struct fd_dev *fd_dev = FD_DEV(dev);
 	ssize_t bl = 0;
+	unsigned long long blocks = fd_dev->fd_file ? (fd_dev->fd_file->f_inode ? fd_dev->fd_file->f_inode->i_blocks : 0): 0;
 
 	bl = sprintf(b + bl, "TCM FILEIO ID: %u", fd_dev->fd_dev_id);
-	bl += sprintf(b + bl, "        File: %s  Size: %llu  Mode: %s Async: %d\n",
-		fd_dev->fd_dev_name, fd_dev->fd_dev_size,
+	bl += sprintf(b + bl, "        File: %s  Size: %llu  Blocks: %llu/%llu  Mode: %s Async: %d\n",
+		fd_dev->fd_dev_name, fd_dev->fd_dev_size, blocks, fd_dev->fd_dev_thresh,
 		(fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE) ?
 		"Buffered-WCE" : "O_DSYNC",
 		!!(fd_dev->fbd_flags & FDBD_HAS_ASYNC_IO));
@@ -938,11 +1097,21 @@
 
 static int __init fileio_module_init(void)
 {
+	struct netlink_kernel_cfg cfg = {
+		.input	= netlink_null_input,
+	};
+	nls = netlink_kernel_create(&init_net, NETLINK_READYNAS, &cfg);
+	if (!nls)
+		pr_err("FILEIO: Error create netlink!\n");
+
 	return transport_backend_register(&fileio_ops);
 }
 
 static void __exit fileio_module_exit(void)
 {
+	if (nls)
+		netlink_kernel_release(nls);
+
 	target_backend_unregister(&fileio_ops);
 }
 
diff -ruN a/drivers/target/target_core_file.h b/drivers/target/target_core_file.h
--- a/drivers/target/target_core_file.h	2024-05-07 14:48:31.556480707 +0800
+++ b/drivers/target/target_core_file.h	2024-05-07 15:46:53.885848990 +0800
@@ -23,6 +23,9 @@
 #define FBDF_HAS_SIZE		0x02
 #define FDBD_HAS_BUFFERED_IO_WCE 0x04
 #define FDBD_HAS_ASYNC_IO	 0x08
+#define FBDF_HAS_THRESHOLD	0x10
+#define FDBD_THRESH_REPORTED	0x100
+#define FBDF_HAS_BLOCK_SIZE	0x200
 #define FDBD_FORMAT_UNIT_SIZE	2048
 
 struct fd_dev {
@@ -37,6 +40,7 @@
 	u32		fd_queue_depth;
 	u32		fd_block_size;
 	unsigned long long fd_dev_size;
+	unsigned long long fd_dev_thresh;
 	struct file	*fd_file;
 	struct file	*fd_prot_file;
 	/* FILEIO HBA device is connected to */
diff -ruN a/drivers/target/target_core_pr.c b/drivers/target/target_core_pr.c
--- a/drivers/target/target_core_pr.c	2024-05-07 14:48:31.556480707 +0800
+++ b/drivers/target/target_core_pr.c	2024-05-07 15:46:53.885848990 +0800
@@ -3768,6 +3768,8 @@
 		 * LENGTH field are not altered based on the allocation length
 		 */
 		add_len += 8;
+		if (add_len > (cmd->data_length - 8))
+			break;
 	}
 	spin_unlock(&dev->t10_pr.registration_lock);
 
diff -ruN a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c
--- a/drivers/target/target_core_sbc.c	2024-05-07 14:48:31.566480764 +0800
+++ b/drivers/target/target_core_sbc.c	2024-05-07 15:46:53.885848990 +0800
@@ -754,10 +754,10 @@
 	}
 	if (cdb[1] & 0x8) {
 		if (!target_check_fua(dev)) {
-			pr_err("Got CDB: 0x%02x with FUA bit set, but device"
+			pr_err_once("Got CDB: 0x%02x with FUA bit set, but device"
 			       " does not advertise support for FUA write\n",
 			       cdb[0]);
-			return -EINVAL;
+			return 0;
 		}
 		cmd->se_cmd_flags |= SCF_FUA;
 	}
diff -ruN a/drivers/target/target_core_spc.c b/drivers/target/target_core_spc.c
--- a/drivers/target/target_core_spc.c	2024-05-07 14:48:31.566480764 +0800
+++ b/drivers/target/target_core_spc.c	2024-05-07 15:46:53.885848990 +0800
@@ -148,6 +148,10 @@
 
 	buf[4] = 91; /* Set additional length to 91 */
 
+	/* These next two are necessary for MS initiators */
+	buf[58] = 0x09;
+	buf[59] = 0x60;
+
 	return 0;
 }
 EXPORT_SYMBOL(spc_emulate_inquiry_std);
@@ -1083,7 +1087,7 @@
 			length += 1;
 	}
 
-	if (page == 0x3f) {
+	if (page == 0x3f || page == 0x00) {
 		if (subpage != 0x00 && subpage != 0xff) {
 			pr_warn("MODE_SENSE: Invalid subpage code: 0x%02x\n", subpage);
 			return TCM_INVALID_CDB_FIELD;
@@ -2341,6 +2345,10 @@
 		break;
 	case INQUIRY:
 		*size = get_unaligned_be16(&cdb[3]);
+		/* Correct the wrong data length from VMWare ESXi 5.0
+		   - JASON QIAN @ NETGEAR */
+		if (cmd->data_length > *size)
+			cmd->data_length = *size;
 
 		/*
 		 * Do implicit HEAD_OF_QUEUE processing for INQUIRY.
diff -ruN a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c
--- a/drivers/target/target_core_transport.c	2024-05-07 14:48:31.566480764 +0800
+++ b/drivers/target/target_core_transport.c	2024-05-07 15:46:53.885848990 +0800
@@ -2075,6 +2075,7 @@
 	case TCM_ALUA_TG_PT_UNAVAILABLE:
 	case TCM_ALUA_STATE_TRANSITION:
 	case TCM_ALUA_OFFLINE:
+	case TCM_TP_SOFT_THRESHOLD_EXCEEDED:
 		break;
 	case TCM_OUT_OF_RESOURCES:
 		cmd->scsi_status = SAM_STAT_TASK_SET_FULL;
@@ -3477,6 +3478,12 @@
 		.asc = 0x04,
 		.ascq = ASCQ_04H_ALUA_OFFLINE,
 	},
+	[TCM_TP_SOFT_THRESHOLD_EXCEEDED] = {
+		/* Thin Provisioning LUN soft threshold exceeded */
+		.key = UNIT_ATTENTION,
+		.asc = 0x38,
+		.ascq = 0x07,
+	},
 };
 
 /**
diff -ruN a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c
--- a/drivers/usb/storage/usb.c	2024-05-07 14:48:31.976483201 +0800
+++ b/drivers/usb/storage/usb.c	2024-05-07 15:46:53.885848990 +0800
@@ -67,7 +67,7 @@
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
 MODULE_LICENSE("GPL");
 
-static unsigned int delay_use = 1;
+static unsigned int delay_use = 5;
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
diff -ruN a/fs/btrfs/check-integrity.c b/fs/btrfs/check-integrity.c
--- a/fs/btrfs/check-integrity.c	2024-05-07 14:48:32.396485699 +0800
+++ b/fs/btrfs/check-integrity.c	2024-05-07 15:46:53.885848990 +0800
@@ -94,6 +94,7 @@
 #include "rcu-string.h"
 #include "compression.h"
 #include "accessors.h"
+#include "cslink.h"
 
 #define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000
 #define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000
@@ -1678,6 +1679,13 @@
 		crypto_shash_update(shash, data, sublen);
 	}
 	crypto_shash_final(shash, csum);
+
+	__MDCS(h->csum, csum, state->csum_size,
+		num_pages * PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE,
+		state->latest_superblock->dev_bytenr + BTRS_CSUM_SIZE,
+		state->dev_state->bdev ?
+		state->dev_state->bdev->dev : 0, 0);
+
 	if (memcmp(csum, h->csum, fs_info->csum_size))
 		return 1;
 
diff -ruN a/fs/btrfs/cslink.c b/fs/btrfs/cslink.c
--- a/fs/btrfs/cslink.c	1970-01-01 08:00:00.000000000 +0800
+++ b/fs/btrfs/cslink.c	2024-05-07 15:46:53.885848990 +0800
@@ -0,0 +1,335 @@
+/*
+ * Copyright (C) 2014,2015 NETGEAR, Inc.  All rights reserved.
+ * Copyright (C) 2014,2015 Hiro Sugawara  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <net/netlink.h>
+#include <net/genetlink.h>
+#include "ctree.h"
+#include "disk-io.h"
+#include "cslink.h"
+
+void btrfs_csum_data(void) {}
+
+void btrfs_csum_final(void) {}
+
+char *__btrfs_proc_mdcsrepair_debug;
+
+static struct {
+	void *func;
+	u8 inverted;	/* Keep this u8 or results are unpredictable. */
+	char *name;
+} csfunc2algo[] = {
+	{(void *)btrfs_csum_final, ~0, "crc32c_le"},
+	{(void *)btrfs_csum_data, 0, "crc32c_le"},
+	{NULL, 0, NULL},
+};
+
+/* Current actual message length ~ 300 (5/28/2014) */
+#define MAX_XML	(512 - sizeof(struct list_head))
+
+static struct mdcs_msg {
+	struct list_head list;
+	char buffer[];
+} mdcs_msg_q;
+static spinlock_t mdcs_lock;
+static DECLARE_WAIT_QUEUE_HEAD(mdcs_waiter);
+static atomic_t mdcs_q_len = ATOMIC_INIT(0);
+#define MDCS_Q_MAX	200
+
+static struct mdcs_msg *retrieve_q(void)
+{
+	struct mdcs_msg *m = NULL;
+
+	spin_lock(&mdcs_lock);
+	if (!list_empty(&mdcs_msg_q.list)) {
+		m = list_first_entry(&mdcs_msg_q.list, struct mdcs_msg, list);
+		list_del(&m->list);
+	}
+	spin_unlock(&mdcs_lock);
+	if (m)
+		atomic_dec(&mdcs_q_len);
+
+	return m;
+}
+
+static void append_q(struct mdcs_msg *msg)
+{
+	spin_lock(&mdcs_lock);
+	list_add_tail(&msg->list, &mdcs_msg_q.list);
+	spin_unlock(&mdcs_lock);
+	atomic_inc(&mdcs_q_len);
+	wake_up(&mdcs_waiter);
+}
+
+/*
+ * Do not change this function name as it is used to validate the XML
+ * message by the user land code.
+ */
+void mdcsrepair_procfs(const char *filesystem, const char *place,
+		u64 inum,
+		const u8 *expected, const u8 *computed, size_t cslen,
+		const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, dev_t adev, u64 fpos, u64 flags)
+{
+	char expbuf[cslen * 2 + 1], compbuf[cslen * 2 + 1];
+	char *p, *name = NULL;
+	int i, remainder;
+	unsigned int inverted = 0;
+	struct mdcs_msg *msg;
+
+	if (dpos == (u64)~0) {
+		pr_err("%s: Invalid dpos (-1)\n", __func__);
+		return;
+	}
+
+	if ((i = atomic_read(&mdcs_q_len)) > MDCS_Q_MAX) {
+		pr_warn("%s: Too many (%d) checksum failures in queue.",
+			__func__, i);
+		return;
+	}
+
+	if (!dev)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(csfunc2algo); i++)
+		if (csfunc2algo[i].func == csfunc) {
+			name = csfunc2algo[i].name;
+			inverted = csfunc2algo[i].inverted;
+			break;
+		}
+
+	if (!name) {
+		pr_err("%s: checksum algorithm not found for %p\n",
+			__func__, csfunc);
+		return;
+	}
+
+	for (i = 0, p = expbuf; i < cslen; i++) {
+		sprintf(p, "%02x", expected[i] ^ inverted);
+		p +=2;
+	}
+	*p = '\0';
+	for (i = 0, p = compbuf; i < cslen; i++) {
+		sprintf(p, "%02x", computed[i] ^ inverted);
+		p +=2;
+	}
+	*p = '\0';
+
+	if (!(msg = kmalloc(MAX_XML + sizeof(*msg), GFP_ATOMIC))) {
+		pr_err("%s: get_free_page failed.", __func__);
+		return;
+	}
+
+	remainder = MAX_XML - (strlen("/></>") + strlen(__func__));
+	if (snprintf(msg->buffer, remainder,
+		"<?xml version=\"1.0\" encoding=\"UTF-8\"?><%s>"
+		"<data offset=\"%llu\" length=\"%lu\" position=\"%s\"/>"
+		"<checksum expected=\"%s\" computed=\"%s\" "
+			"length=\"%lu\" algorithm=\"%s\"/>"
+		"<device major=\"%u\" minor=\"%u\" filesystem=\"%s\"/>"
+		"<place function=\"%s\"/>"
+		"<file inode=\"%llu\"",
+		__func__,
+		dpos, (unsigned long)len,
+		(flags & CSL_INTRAFILEPOS) ? "file" : "disk",
+		expbuf, compbuf, (unsigned long)cslen, name,
+		MAJOR(dev), MINOR(dev),
+		filesystem,
+		place ? place : "UNKOWN",
+		inum
+		) >= remainder) {
+		pr_err("%s: Buffer overflowed\n", __func__);
+		goto nlmsg_failure2;
+	}
+	remainder -= strlen(msg->buffer);
+
+	if (fpos != (u64)~0) {
+		int len;
+		p = msg->buffer + strlen(msg->buffer);
+		if ((len = snprintf(p, remainder, " offset=\"%llu\"", fpos)) >=
+				remainder) {
+			pr_err("%s: Buffer overflowed\n", __func__);
+			goto nlmsg_failure2;
+		}
+		remainder -= len;
+	}
+	strncat(msg->buffer, "/>", remainder);
+
+	if (adev) {
+		int len;
+		p = msg->buffer + strlen(msg->buffer);
+		if ((len = snprintf(p, remainder,
+			"<anondevice major=\"%u\" minor=\"%d\"/>",
+			MAJOR(adev), MINOR(adev))) >= remainder) {
+			pr_err("%s: Buffer overflowed\n", __func__);
+			goto nlmsg_failure2;
+		}
+		remainder -= len;
+	}
+
+	p = msg->buffer + strlen(msg->buffer);
+	sprintf(p, "</%s>", __func__);
+
+	append_q(msg);
+	return;
+
+nlmsg_failure2:
+	kfree(msg);
+}
+
+/*
+ * For debugging, "src/file.c:function" enables a fake checksum failure
+ * to send netlink message whenever the function is called.
+ * A null string for src/file.c or function works as a wild card; thus
+ * ":" catches every checksum calculation. A null string or NULL pointer
+ * ("") disables debugging.
+ */
+static struct proc_dir_entry *btrfs_proc_root,
+				*btrfs_proc_mdcsrepair, *btrfs_proc_mdcsevent;
+
+static int btrfs_proc_mdcsrepair_read(struct seq_file *f, void *v)
+{
+	if (__btrfs_proc_mdcsrepair_debug && *__btrfs_proc_mdcsrepair_debug)
+		seq_printf(f, "%s", __btrfs_proc_mdcsrepair_debug);
+	seq_putc(f, '\n');
+	return 0;
+}
+
+static ssize_t btrfs_proc_mdcsrepair_write(struct file *file,
+			const char __user *buffer,
+			size_t count, loff_t *ppos)
+{
+	ssize_t rv;
+
+	kfree(__btrfs_proc_mdcsrepair_debug);
+	if (!(__btrfs_proc_mdcsrepair_debug = kmalloc(count + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	if ((rv = copy_from_user(__btrfs_proc_mdcsrepair_debug,
+				buffer, count))) {
+		kfree(__btrfs_proc_mdcsrepair_debug);
+		__btrfs_proc_mdcsrepair_debug = NULL;
+		return rv;
+	}
+	if (__btrfs_proc_mdcsrepair_debug[count - 1] == '\n')
+		__btrfs_proc_mdcsrepair_debug[count - 1] = '\0';
+	else
+		__btrfs_proc_mdcsrepair_debug[count] = '\0';
+	if (!__btrfs_proc_mdcsrepair_debug[0]) {
+		kfree(__btrfs_proc_mdcsrepair_debug);
+		__btrfs_proc_mdcsrepair_debug = NULL;
+	}
+	return count;
+}
+
+static int btrfs_proc_mdcsrepair_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, btrfs_proc_mdcsrepair_read, NULL);
+}
+
+static const struct proc_ops btrfs_proc_mdcsrepair_fops = {
+	.proc_lseek	= seq_lseek,
+	.proc_read	= seq_read,
+	.proc_write	= btrfs_proc_mdcsrepair_write,
+	.proc_open	= btrfs_proc_mdcsrepair_open,
+	.proc_release= single_release,
+};
+
+static int btrfs_proc_mdcsevent_read(struct seq_file *f, void *v)
+{
+	struct mdcs_msg *m = NULL;
+	int err = 0;
+
+	do {
+		/* wait for repair requests to come */
+		err = wait_event_interruptible(mdcs_waiter,
+				!list_empty(&mdcs_msg_q.list));
+	} while (!err && !(m = retrieve_q()));
+
+	if (m) {
+		seq_printf(f, "%s", m->buffer);
+		kfree(m);
+	}
+	return err;
+}
+
+static int btrfs_proc_mdcsevent_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, btrfs_proc_mdcsevent_read, NULL);
+}
+
+static const struct proc_ops btrfs_proc_mdcsevent_fops = {
+	.proc_lseek	= seq_lseek,
+	.proc_read	= seq_read,
+	.proc_open	= btrfs_proc_mdcsevent_open,
+	.proc_release= single_release,
+};
+
+static int __init btrfs_mdcs_init(void)
+{
+	spin_lock_init(&mdcs_lock);
+	INIT_LIST_HEAD(&mdcs_msg_q.list);
+	atomic_set(&mdcs_q_len, 0);
+
+	if (!(btrfs_proc_root = proc_mkdir("fs/btrfs", NULL))) {
+		return -EIO;
+	}
+	if (!(btrfs_proc_mdcsrepair =
+		proc_create("mdcsrepair",
+			S_IFREG | S_IRUGO | S_IWUSR, btrfs_proc_root,
+			&btrfs_proc_mdcsrepair_fops))) {
+		remove_proc_entry("fs/btrfs", NULL);
+		return -EIO;
+	}
+
+	if (!(btrfs_proc_mdcsevent =
+		proc_create("mdcsevent",
+			S_IFREG | S_IRUSR, btrfs_proc_root,
+			&btrfs_proc_mdcsevent_fops))) {
+		remove_proc_entry("fs/btrfs/mdcsrepair", NULL);
+		remove_proc_entry("fs/btrfs", NULL);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit btrfs_mdcs_exit(void)
+{
+	struct mdcs_msg *m;
+
+	while ((m = retrieve_q()))
+		kfree(m);
+	remove_proc_entry("fs/btrfs/mdcsevent", NULL);
+	remove_proc_entry("fs/btrfs/mdcsrepair", NULL);
+	kfree(__btrfs_proc_mdcsrepair_debug);
+	__btrfs_proc_mdcsrepair_debug = NULL;
+}
+
+module_init(btrfs_mdcs_init);
+module_exit(btrfs_mdcs_exit);
+
+MODULE_AUTHOR("<hiro.sugawara@netgear.com>");
+MODULE_DESCRIPTION("BTRFS checksum corrector");
+MODULE_LICENSE("GPL");
diff -ruN a/fs/btrfs/cslink.h b/fs/btrfs/cslink.h
--- a/fs/btrfs/cslink.h	1970-01-01 08:00:00.000000000 +0800
+++ b/fs/btrfs/cslink.h	2024-05-07 15:46:53.885848990 +0800
@@ -0,0 +1,113 @@
+#ifndef __BTRFS_CSLINK__
+#define __BTRFS_CSLINK__
+
+#include <linux/ctype.h>
+
+void btrfs_csum_data(void);
+void btrfs_csum_final(void);
+
+#define	CSL_INTRAFILEPOS	(1<<0)	/* Obsolete */
+
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+void mdcsrepair_procfs(const char *filesystem, const char *place,
+		u64 inum,
+		const u8 *expected, const u8 *computed,
+		size_t cslen, const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, dev_t adev, u64 fpos, u64 flags);
+
+/*
+ * For debugging, <file>:<func> or :<inum> is compared to simulate
+ * a CRC error for each code execution.
+ * A nil string before and after ":" works as a wild card,
+ * so that ":" alone matches any (i.e. will always generate fake error).
+ */
+extern char *__btrfs_proc_mdcsrepair_debug;
+
+#if defined(DEBUG_CSLINK)
+#define btrfs_mdcsrepair_hit(...)	true
+#else
+static inline
+bool btrfs_mdcsrepair_hit(bool cond, const void *expected,
+			const char *__file, const char *__func, u64 inum)
+{
+	const char *colon = __btrfs_proc_mdcsrepair_debug;
+
+	if (cond && *((u32 *)expected))
+		return true;
+
+	if (!colon || !*colon)
+		return false;
+
+	/* Check for <file> field before ":" */
+	if (*colon != ':' &&
+		(strncmp(colon, __file, strlen(__file)) ||
+			*(colon += strlen(__file)) != ':'))
+		return false;
+
+	/* Now colon points to ':'. */
+	colon++;
+	if (isdigit(*colon)) {
+		char *end;
+		u64 restrict_inum = simple_strtoull(colon, &end, 10);
+
+		return !*end && inum == restrict_inum;
+	}
+	return !*colon || !strcmp(colon, __func);
+}
+#endif
+/* Definition in inode.c */
+u64 btrfs_log2phys(struct btrfs_inode *inode, u64 logical, u64 len, dev_t *dev);
+#else
+static inline
+void mdcsrepair_procfs(const char *filesystem, const char *place,
+		const u8 *expected, const u8 *computed,
+		size_t cslen, const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, u64 inum, u64 fpos, u64 flags) {}
+
+static inline
+u64 btrfs_log2phys(struct btrfs_inode *inode, u64 logical, u64 len, dev_t *dev)
+{
+	*dev = 0;
+	return (u64)~0;
+}
+#endif
+
+/* Debug macros */
+#if defined(DEBUG_MDCS)
+#define __MDCS(_good, _bad, _size, _len, _pos, _dev, _ino)	\
+	do {	\
+		u8 *_gp = (u8 *)(_good), *_bp = (u8 *)(_bad); int _i;	\
+		pr_emerg("%s:%d G:", __FILE__, __LINE__);	\
+		for (_i = 0; _i < (_size); _i++)	\
+			pr_emerg("%02x", _gp[_i]);	\
+		pr_emerg(" B:");	\
+		for (_i = 0; _i < (_size); _i++)	\
+			pr_emerg("%02x", _bp[_i]);	\
+		pr_emerg(" %lu @ %llu dev=%u:%u ino=%llu\n",	\
+			(size_t)(_len), (_pos),		\
+			(unsigned int)MAJOR(_dev),	\
+			(unsigned int)MINOR(_dev),	\
+			(u64)(_ino));	\
+	} while (0)
+#else
+#define __MDCS(...)	do {} while(0)
+#endif
+
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+#define __btrfs_cslink(cond, inum, expected, computed, cslen, ...)      \
+	do {								\
+		if (btrfs_mdcsrepair_hit(cond, expected, __FILE__,	\
+					__func__, (inum))) {		\
+			mdcsrepair_procfs("btrfs", __func__, inum,	\
+					expected, computed, cslen,	\
+					__VA_ARGS__);			\
+			cond = memcmp(computed, expected, cslen);	\
+		}							\
+	} while (0)
+#else
+#define __btrfs_cslink(...)	do {} while(0)
+#endif
+
+#endif	/* __BTRFS_CSLINK__ */
diff -ruN a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
--- a/fs/btrfs/disk-io.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/disk-io.c	2024-05-07 15:46:53.895849050 +0800
@@ -53,6 +53,10 @@
 #include "scrub.h"
 #include "super.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 #define BTRFS_SUPER_FLAG_SUPP	(BTRFS_HEADER_FLAG_WRITTEN |\
 				 BTRFS_HEADER_FLAG_RELOC |\
 				 BTRFS_SUPER_FLAG_ERROR |\
@@ -62,6 +66,8 @@
 
 static int btrfs_cleanup_transaction(struct btrfs_fs_info *fs_info);
 static void btrfs_error_commit_super(struct btrfs_fs_info *fs_info);
+static struct btrfs_super_block *__btrfs_read_dev_super(
+	struct block_device *bdev, u64 *bytenrp);
 
 static void btrfs_free_csum_hash(struct btrfs_fs_info *fs_info)
 {
@@ -142,8 +148,11 @@
  * algorithm. Pass the raw disk superblock data.
  */
 int btrfs_check_super_csum(struct btrfs_fs_info *fs_info,
-			   const struct btrfs_super_block *disk_sb)
+			   const struct btrfs_super_block *disk_sb,
+			   unsigned long long start,
+			   struct block_device *bdev)
 {
+	int err;
 	char result[BTRFS_CSUM_SIZE];
 	SHASH_DESC_ON_STACK(shash, fs_info->csum_shash);
 
@@ -157,8 +166,21 @@
 	crypto_shash_digest(shash, (const u8 *)disk_sb + BTRFS_CSUM_SIZE,
 			    BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE, result);
 
-	if (memcmp(disk_sb->csum, result, fs_info->csum_size))
-		return 1;
+	__MDCS(disk_sb->csum, result, fs_info->csum_size,
+		BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE,
+		start + BTRFS_CSUM_SIZE, bdev->bd_dev, 0);
+
+	err = memcmp(disk_sb->csum, result, fs_info->csum_size);
+	if (err) {
+		/* netgear patch only support crc32c by now, hard code for CRC32 */
+		if (disk_sb->csum_type == BTRFS_CSUM_TYPE_CRC32)
+			__btrfs_cslink(err, 0, disk_sb->csum, result, fs_info->csum_size,
+					btrfs_csum_final, start + BTRFS_CSUM_SIZE,
+					BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE,
+					bdev->bd_dev, 0, (u64)~0, 0);
+		if (err)
+			return 1;
+	}
 
 	return 0;
 }
@@ -380,7 +402,7 @@
 			      CSUM_FMT_VALUE(csum_size, header_csum),
 			      CSUM_FMT_VALUE(csum_size, result),
 			      btrfs_header_level(eb));
-		ret = -EUCLEAN;
+		ret = btrfs_test_opt(fs_info, USEBACKUPROOT) ? 0 : -EUCLEAN;
 		goto out;
 	}
 
@@ -3174,6 +3196,7 @@
 	struct btrfs_root *chunk_root;
 	int ret;
 	int level;
+	u64 super_bytenr;
 
 	ret = init_mount_fs_info(fs_info, sb);
 	if (ret)
@@ -3200,7 +3223,7 @@
 	/*
 	 * Read super block and check the signature bytes only
 	 */
-	disk_super = btrfs_read_dev_super(fs_devices->latest_dev->bdev);
+	disk_super = __btrfs_read_dev_super(fs_devices->latest_dev->bdev, &super_bytenr);
 	if (IS_ERR(disk_super)) {
 		ret = PTR_ERR(disk_super);
 		goto fail_alloc;
@@ -3232,7 +3255,7 @@
 	 * We want to check superblock checksum, the type is stored inside.
 	 * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).
 	 */
-	if (btrfs_check_super_csum(fs_info, disk_super)) {
+	if (btrfs_check_super_csum(fs_info, disk_super, super_bytenr, fs_devices->latest_dev->bdev)) {
 		btrfs_err(fs_info, "superblock checksum mismatch");
 		ret = -EINVAL;
 		btrfs_release_disk_super(disk_super);
@@ -3713,7 +3736,7 @@
 }
 
 
-struct btrfs_super_block *btrfs_read_dev_super(struct block_device *bdev)
+static struct btrfs_super_block *__btrfs_read_dev_super(struct block_device *bdev, u64 *bytenrp)
 {
 	struct btrfs_super_block *super, *latest = NULL;
 	int i;
@@ -3738,9 +3761,17 @@
 		}
 	}
 
+	if (bytenrp)
+		*bytenrp = btrfs_super_bytenr(super);
+
 	return super;
 }
 
+struct btrfs_super_block *btrfs_read_dev_super(struct block_device *bdev)
+{
+	return __btrfs_read_dev_super(bdev, NULL);
+}
+
 /*
  * Write superblock @sb to the @device. Do not wait for completion, all the
  * pages we use for writing are locked.
diff -ruN a/fs/btrfs/disk-io.h b/fs/btrfs/disk-io.h
--- a/fs/btrfs/disk-io.h	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/disk-io.h	2024-05-07 15:46:53.895849050 +0800
@@ -42,7 +42,9 @@
 void btrfs_clear_oneshot_options(struct btrfs_fs_info *fs_info);
 int btrfs_start_pre_rw_mount(struct btrfs_fs_info *fs_info);
 int btrfs_check_super_csum(struct btrfs_fs_info *fs_info,
-			   const struct btrfs_super_block *disk_sb);
+			   const struct btrfs_super_block *disk_sb,
+			   unsigned long long start,
+			   struct block_device *bdev);
 int __cold open_ctree(struct super_block *sb,
 	       struct btrfs_fs_devices *fs_devices,
 	       char *options);
diff -ruN a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c
--- a/fs/btrfs/extent_io.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/extent_io.c	2024-05-07 15:56:00.949101999 +0800
@@ -40,6 +40,13 @@
 
 static struct kmem_cache *extent_buffer_cache;
 
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+int extent_fiemap_log2phys(struct btrfs_inode *inode,
+			   struct fiemap_extent_info *fieinfo,
+			   u64 foffset, u64 loffset, u64 len,
+			   u32 flags);
+#endif
+
 #ifdef CONFIG_BTRFS_DEBUG
 static inline void btrfs_leak_debug_add_eb(struct extent_buffer *eb)
 {
@@ -2822,7 +2829,7 @@
 			       struct btrfs_backref_share_check_ctx *backref_ctx,
 			       u64 disk_bytenr, u64 extent_offset,
 			       u64 extent_gen,
-			       u64 start, u64 end)
+			       u64 start, u64 end, bool dophys)
 {
 	const u64 i_size = i_size_read(&inode->vfs_inode);
 	u64 cur_offset = start;
@@ -2876,6 +2883,14 @@
 
 				checked_extent_shared = true;
 			}
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+			if (dophys)
+				ret = extent_fiemap_log2phys(inode, fieinfo,
+					prealloc_start,
+					disk_bytenr + extent_offset,
+					prealloc_len, prealloc_flags);
+			else
+#endif
 			ret = emit_fiemap_extent(fieinfo, cache, prealloc_start,
 						 disk_bytenr + extent_offset,
 						 prealloc_len, prealloc_flags);
@@ -2884,6 +2899,15 @@
 			extent_offset += prealloc_len;
 		}
 
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+		if (dophys)
+			ret = extent_fiemap_log2phys(inode, fieinfo,
+				delalloc_start, 0,
+				delalloc_end + 1 - delalloc_start,
+				FIEMAP_EXTENT_DELALLOC |
+				FIEMAP_EXTENT_UNKNOWN);
+		else
+#endif
 		ret = emit_fiemap_extent(fieinfo, cache, delalloc_start, 0,
 					 delalloc_end + 1 - delalloc_start,
 					 FIEMAP_EXTENT_DELALLOC |
@@ -2923,6 +2947,14 @@
 			else if (ret > 0)
 				prealloc_flags |= FIEMAP_EXTENT_SHARED;
 		}
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+		if (dophys)
+			ret = extent_fiemap_log2phys(inode, fieinfo,
+				prealloc_start,
+				disk_bytenr + extent_offset,
+				prealloc_len, prealloc_flags);
+		else
+#endif
 		ret = emit_fiemap_extent(fieinfo, cache, prealloc_start,
 					 disk_bytenr + extent_offset,
 					 prealloc_len, prealloc_flags);
@@ -3009,8 +3041,8 @@
 	return 0;
 }
 
-int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,
-		  u64 start, u64 len)
+static int __extent_fiemap(struct btrfs_inode *inode,
+	struct fiemap_extent_info *fieinfo, u64 start, u64 len, bool dophys)
 {
 	const u64 ino = btrfs_ino(inode);
 	struct extent_state *cached_state = NULL;
@@ -3097,7 +3129,8 @@
 			ret = fiemap_process_hole(inode, fieinfo, &cache,
 						  &delalloc_cached_state,
 						  backref_ctx, 0, 0, 0,
-						  prev_extent_end, hole_end);
+						  prev_extent_end, hole_end,
+						  dophys);
 			if (ret < 0) {
 				goto out_unlock;
 			} else if (ret > 0) {
@@ -3132,6 +3165,12 @@
 		if (extent_type == BTRFS_FILE_EXTENT_INLINE) {
 			flags |= FIEMAP_EXTENT_DATA_INLINE;
 			flags |= FIEMAP_EXTENT_NOT_ALIGNED;
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+			if (dophys)
+				ret = extent_fiemap_log2phys(inode, fieinfo,
+					key.offset, 0, extent_len, flags);
+			else
+#endif
 			ret = emit_fiemap_extent(fieinfo, &cache, key.offset, 0,
 						 extent_len, flags);
 		} else if (extent_type == BTRFS_FILE_EXTENT_PREALLOC) {
@@ -3140,13 +3179,14 @@
 						  backref_ctx,
 						  disk_bytenr, extent_offset,
 						  extent_gen, key.offset,
-						  extent_end - 1);
+						  extent_end - 1, dophys);
 		} else if (disk_bytenr == 0) {
 			/* We have an explicit hole. */
 			ret = fiemap_process_hole(inode, fieinfo, &cache,
 						  &delalloc_cached_state,
 						  backref_ctx, 0, 0, 0,
-						  key.offset, extent_end - 1);
+						  key.offset, extent_end - 1,
+						  dophys);
 		} else {
 			/* We have a regular extent. */
 			if (fieinfo->fi_extents_max) {
@@ -3160,6 +3200,13 @@
 					flags |= FIEMAP_EXTENT_SHARED;
 			}
 
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+			if (dophys)
+				ret = extent_fiemap_log2phys(inode, fieinfo,
+					key.offset, disk_bytenr + extent_offset,
+					extent_len, flags);
+			else
+#endif
 			ret = emit_fiemap_extent(fieinfo, &cache, key.offset,
 						 disk_bytenr + extent_offset,
 						 extent_len, flags);
@@ -3194,7 +3241,8 @@
 	if (!stopped && prev_extent_end < range_end) {
 		ret = fiemap_process_hole(inode, fieinfo, &cache,
 					  &delalloc_cached_state, backref_ctx,
-					  0, 0, 0, prev_extent_end, range_end - 1);
+					  0, 0, 0, prev_extent_end, range_end - 1,
+					  dophys);
 		if (ret < 0)
 			goto out_unlock;
 		prev_extent_end = range_end;
@@ -3259,6 +3307,12 @@
 	return ret;
 }
 
+int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,
+		__u64 start, __u64 len, bool dophys)
+{
+	return __extent_fiemap(inode, fieinfo, start, len, dophys);
+}
+
 static void __free_extent_buffer(struct extent_buffer *eb)
 {
 	kmem_cache_free(extent_buffer_cache, eb);
diff -ruN a/fs/btrfs/extent_io.h b/fs/btrfs/extent_io.h
--- a/fs/btrfs/extent_io.h	2024-05-07 14:48:32.406485759 +0800
+++ b/fs/btrfs/extent_io.h	2024-05-07 15:46:53.895849050 +0800
@@ -193,7 +193,7 @@
 			    struct writeback_control *wbc);
 void extent_readahead(struct readahead_control *rac);
 int extent_fiemap(struct btrfs_inode *inode, struct fiemap_extent_info *fieinfo,
-		  u64 start, u64 len);
+		  u64 start, u64 len, bool dophys);
 int set_page_extent_mapped(struct page *page);
 void clear_page_extent_mapped(struct page *page);
 
diff -ruN a/fs/btrfs/fiemap_physical.c b/fs/btrfs/fiemap_physical.c
--- a/fs/btrfs/fiemap_physical.c	1970-01-01 08:00:00.000000000 +0800
+++ b/fs/btrfs/fiemap_physical.c	2024-05-07 15:46:53.895849050 +0800
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014 NETGEAR, Inc.  All rights reserved.
+ * Copyright (C) 2014 Hiro Sugawara  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/blkdev.h>
+#include <linux/kdev_t.h>
+#include <linux/proc_fs.h>
+#include <linux/kthread.h>
+#include <linux/list.h>
+#include <net/netlink.h>
+#include <net/genetlink.h>
+#include "ctree.h"
+#include "disk-io.h"
+#include "btrfs_inode.h"
+#include "volumes.h"
+
+static int fiemap_fill_next_extent_physical(struct fiemap_extent_info *fieinfo,
+			u64 fpos, u64 llength, u64 phys, u64 len, u32 flags,
+			dev_t dev)
+{
+	struct fiemap_extent __user *extent =
+			fieinfo->fi_extents_start + fieinfo->fi_extents_mapped;
+	typeof(extent->fe_pdev) pdev = new_encode_dev(dev);
+	typeof(extent->fe_loglength) llen = llength;
+
+	int ret = fiemap_fill_next_extent(fieinfo, fpos, phys, len,
+		flags | FIEMAP_EXTENT_PHYSICAL | FIEMAP_EXTENT_LOGLENGTH);
+
+	if (ret < 0)
+		return ret;
+	if (copy_to_user(&extent->fe_pdev, &pdev, sizeof(pdev)))
+		return -EFAULT;
+	if (copy_to_user(&extent->fe_loglength, &llen, sizeof(llen)))
+		return -EFAULT;
+	return ret;
+}
+
+int extent_fiemap_log2phys(struct btrfs_inode *inode,
+			   struct fiemap_extent_info *fieinfo,
+			   u64 foffset, u64 logical, u64 len, u32 flags)
+{
+	struct btrfs_fs_info *fs_info = inode->root->fs_info;
+	struct btrfs_io_context *bbio;
+	int ret, i;
+	u64 length = len;
+
+	if ((ret = btrfs_map_block(fs_info, BTRFS_MAP_READ, logical, &length,
+				   &bbio, NULL, NULL, 0)))
+		return ret;
+	for (i = 0; i < bbio->num_stripes; i++) {
+		if ((ret = fiemap_fill_next_extent_physical(fieinfo, foffset,
+				length, bbio->stripes[i].physical, len,
+				(bbio->num_stripes > 1) &&
+					(i < bbio->num_stripes - 1)
+						? FIEMAP_EXTENT_MORESTRIPE
+						: 0,
+				bbio->stripes[i].dev->bdev->bd_dev)))
+			break;
+	}
+	kfree(bbio);
+	return ret;
+}
diff -ruN a/fs/btrfs/file.c b/fs/btrfs/file.c
--- a/fs/btrfs/file.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/file.c	2024-05-07 15:46:53.895849050 +0800
@@ -207,6 +207,7 @@
 	struct btrfs_ref ref = { 0 };
 	struct btrfs_key key;
 	struct btrfs_key new_key;
+	struct btrfs_key next_key;
 	u64 ino = btrfs_ino(inode);
 	u64 search_start = args->start;
 	u64 disk_bytenr = 0;
@@ -320,6 +321,17 @@
 			goto delete_extent_item;
 		}
 
+		/* handle two extents overlap during replaying log tree */
+		if (path->slots[0] < btrfs_header_nritems(leaf) - 1) {
+			btrfs_item_key_to_cpu(leaf, &next_key, path->slots[0] + 1);
+			if (next_key.objectid == key.objectid &&
+			    next_key.type == key.type &&
+			    extent_end > next_key.offset) {
+				WARN_ON(1);
+				extent_end = next_key.offset;
+			}
+		}
+
 		if (extent_end <= search_start) {
 			path->slots[0]++;
 			goto next_slot;
diff -ruN a/fs/btrfs/inode.c b/fs/btrfs/inode.c
--- a/fs/btrfs/inode.c	2024-05-07 14:48:32.436485938 +0800
+++ b/fs/btrfs/inode.c	2024-05-07 15:59:49.910463477 +0800
@@ -9,6 +9,7 @@
 #include <linux/blk-cgroup.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/device.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
 #include <linux/time.h>
@@ -71,6 +72,7 @@
 #include "super.h"
 #include "orphan.h"
 #include "backref.h"
+#include "cslink.h"
 
 struct btrfs_iget_args {
 	u64 ino;
@@ -3266,6 +3268,97 @@
 	return 0;
 }
 
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+/*
+ * map logical device position to physical device position and its device ID.
+ *
+ * simplified excerpts from volumes.c:__btrfs_map_block() and
+ * volumes.c:btrfs_map_bio().
+ */
+u64 btrfs_log2phys(struct btrfs_inode *inode, u64 logical, u64 len, dev_t *dev)
+{
+	struct btrfs_fs_info *fs_info = inode->root->fs_info;
+	struct extent_map_tree *em_tree = &fs_info->mapping_tree;
+	struct extent_map *em;
+	struct map_lookup *map;
+	u64 physical, offset, stripe_nr, stripe_offset, stripe_index;
+	u32 stripe_len;
+
+	read_lock(&em_tree->lock);
+	em = lookup_extent_mapping(em_tree, logical, len);
+	read_unlock(&em_tree->lock);
+
+	if (!em) {
+		pr_warn("%s: cannot lookup extent mapping for %llu\n",
+				__func__, logical);
+		return (u64)~0;
+	}
+
+	map = em->map_lookup;
+	if (map->type & (BTRFS_BLOCK_GROUP_RAID1|BTRFS_BLOCK_GROUP_RAID10)) {
+		pr_warn("%s: not supporting RAID1/10", __func__);
+		return (u64)~0;
+	}
+
+	offset = logical - em->start;
+	stripe_nr = offset;
+	stripe_len = btrfs_calc_stripe_length(em);
+	do_div(stripe_nr, stripe_len);
+	stripe_offset = offset - stripe_nr * stripe_len;
+	stripe_index = do_div(stripe_nr, map->num_stripes);
+
+	/* TODO: Untested for multiple stipe cases (RAID0). */
+	physical =  map->stripes[stripe_index].physical +
+			stripe_offset + stripe_nr * stripe_len;
+	*dev = map->stripes[stripe_index].dev->bdev->bd_dev;
+	free_extent_map(em);
+	return physical;
+}
+
+/*
+ * map file position to physical device position and its device ID.
+ *
+ *	Done in 2 stages
+ *		#1: logical extent - FIEMAP equivalent
+ *		#2: physical extent - call to btrfs_log2phys() above
+ */
+static u64 fpos2phys(struct btrfs_inode *inode, u64 fpos, u64 len, dev_t *dev)
+{
+	struct extent_map *em;
+	u64 logical;
+
+	em = btrfs_get_extent(inode, NULL, 0, fpos, len);
+	if (IS_ERR(em) || !em) {
+		pr_err("%s: cannot get extent mapping for %llu\n",
+				__func__, fpos);
+		return (u64)~0;
+	}
+	logical = em->block_start + fpos - em->start;
+	free_extent_map(em);
+
+	return btrfs_log2phys(inode, logical, len, dev);
+}
+
+/* Keep this a macro as we pass __FILE__ and __func_ to other functions. */
+#define __btrfs_cslink_inode(cond, expected, computed, csumlen,	\
+				csfunc, fpos, length, inode)	\
+do {	\
+	if (btrfs_mdcsrepair_hit((cond), (expected),		\
+		__FILE__, __func__, btrfs_ino(inode))) {	\
+		dev_t dev;					\
+		u64 physical = fpos2phys((inode), (fpos), (length), &dev); \
+		mdcsrepair_procfs("btrfs", __func__,    	\
+			btrfs_ino(inode),			\
+			(expected), (computed), (csumlen),	\
+			(csfunc), physical, (length),		\
+			dev, inode->root->anon_dev,		\
+			(fpos), 0);	\
+	}	\
+} while (0)
+#else
+#define __btrfs_cslink_inode(...)	do {} while (0)
+#endif
+
 /*
  * Verify the checksum of a single data sector.
  *
@@ -3288,6 +3381,8 @@
 	u64 end = file_offset + bv->bv_len - 1;
 	u8 *csum_expected;
 	u8 csum[BTRFS_CSUM_SIZE];
+	const u16 csum_size = btrfs_super_csum_size(fs_info->super_copy);
+	int err;
 
 	ASSERT(bv->bv_len == fs_info->sectorsize);
 
@@ -3305,14 +3400,30 @@
 
 	csum_expected = bbio->csum + (bio_offset >> fs_info->sectorsize_bits) *
 				fs_info->csum_size;
-	if (btrfs_check_sector_csum(fs_info, bv->bv_page, bv->bv_offset, csum,
-				    csum_expected))
-		goto zeroit;
+
+	__MDCS(csum_expected, csum, csum_size, PAGE_CACHE_SIZE,
+	       bbio->file_offset + bio_offset, BTRFS_I(inode)->root->anon_dev,
+	       btrfs_ino(inode));
+
+	err = btrfs_check_sector_csum(fs_info, bv->bv_page, bv->bv_offset, csum,
+				    csum_expected);
+	if (err) {
+		/* netgear patch only support crc32c by now, hard code for CRC32 */
+		if (fs_info->super_copy->csum_type == BTRFS_CSUM_TYPE_CRC32) {
+			__btrfs_cslink_inode(err, csum_expected, csum, csum_size,
+				btrfs_csum_final, bbio->file_offset + bio_offset,
+				PAGE_SIZE, inode);
+		}
+		if (err)
+			goto zeroit;
+	}
 	return true;
 
 zeroit:
 	btrfs_print_data_csum_error(inode, file_offset, csum, csum_expected,
 				    bbio->mirror_num);
+	if (btrfs_test_opt(inode->root->fs_info, USEBACKUPROOT))
+		return 0;
 	if (dev)
 		btrfs_dev_stat_inc_and_print(dev, BTRFS_DEV_STAT_CORRUPTION_ERRS);
 	memzero_bvec(bv);
@@ -5959,6 +6070,13 @@
 		put_unaligned(name_len, &entry->name_len);
 		put_unaligned(fs_ftype_to_dtype(ftype), &entry->type);
 		btrfs_dir_item_key_to_cpu(leaf, di, &location);
+
+		/* Skip the snapper '.snapshots' subvolume */
+		if (location.type == BTRFS_ROOT_ITEM_KEY &&
+		    strncmp(name_ptr, ".snapshots", 10) == 0) {
+			continue;
+		}
+
 		put_unaligned(location.objectid, &entry->ino);
 		put_unaligned(found_key.offset, &entry->offset);
 		entries++;
@@ -7825,6 +7943,11 @@
 {
 	struct btrfs_inode *btrfs_inode = BTRFS_I(inode);
 	int	ret;
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+	unsigned int physical = fieinfo->fi_flags & FIEMAP_FLAG_PHYSICAL;
+
+	fieinfo->fi_flags &= ~FIEMAP_FLAG_PHYSICAL;
+#endif
 
 	ret = fiemap_prep(inode, fieinfo, start, &len, 0);
 	if (ret)
@@ -7865,7 +7988,12 @@
 		}
 	}
 
-	ret = extent_fiemap(btrfs_inode, fieinfo, start, len);
+#ifdef CONFIG_BTRFS_FIEMAP_PHYSICAL
+	if (physical)
+		ret = extent_fiemap(btrfs_inode, fieinfo, start, len, true);
+	else
+#endif
+	ret = extent_fiemap(btrfs_inode, fieinfo, start, len, false);
 	btrfs_inode_unlock(btrfs_inode, BTRFS_ILOCK_SHARED);
 
 	return ret;
diff -ruN a/fs/btrfs/inode-item.c b/fs/btrfs/inode-item.c
--- a/fs/btrfs/inode-item.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/inode-item.c	2024-05-07 15:46:53.895849050 +0800
@@ -370,14 +370,13 @@
 	btrfs_free_path(path);
 
 	if (ret == -EMLINK) {
-		struct btrfs_super_block *disk_super = fs_info->super_copy;
 		/* We ran out of space in the ref array. Need to
 		 * add an extended ref. */
-		if (btrfs_super_incompat_flags(disk_super)
-		    & BTRFS_FEATURE_INCOMPAT_EXTENDED_IREF)
-			ret = btrfs_insert_inode_extref(trans, root, name,
-							inode_objectid,
-							ref_objectid, index);
+		ret = btrfs_insert_inode_extref(trans, root, name,
+						inode_objectid,
+						ref_objectid, index);
+		if (!ret)
+			btrfs_set_fs_incompat(fs_info, EXTENDED_IREF);
 	}
 
 	return ret;
diff -ruN a/fs/btrfs/Kconfig b/fs/btrfs/Kconfig
--- a/fs/btrfs/Kconfig	2024-05-07 14:48:32.396485699 +0800
+++ b/fs/btrfs/Kconfig	2024-05-07 15:46:53.895849050 +0800
@@ -109,3 +109,17 @@
 	  reference problems or verifying they didn't break something.
 
 	  If unsure, say N.
+
+config BTRFS_MDCSREPAIR
+	bool "Btrfs RAID-based auto data repair"
+	depends on BTRFS_FS
+	help
+	  Enable kernel to user program NETLINK communication for
+	  automtically repairing of corrupted data using CRC chechsum
+	  and RAID data redundancy.
+
+config BTRFS_FIEMAP_PHYSICAL
+	bool "Btrfs physical address output of FIEMAP"
+	depends on BTRFS_FS
+	help
+	  Enable BTRFS to report physical address for FIEMAP ioctl.
diff -ruN a/fs/btrfs/Makefile b/fs/btrfs/Makefile
--- a/fs/btrfs/Makefile	2024-05-07 14:48:32.396485699 +0800
+++ b/fs/btrfs/Makefile	2024-05-07 15:46:53.895849050 +0800
@@ -40,6 +40,8 @@
 btrfs-$(CONFIG_BTRFS_FS_REF_VERIFY) += ref-verify.o
 btrfs-$(CONFIG_BLK_DEV_ZONED) += zoned.o
 btrfs-$(CONFIG_FS_VERITY) += verity.o
+btrfs-$(CONFIG_BTRFS_MDCSREPAIR) += cslink.o
+btrfs-$(CONFIG_BTRFS_FIEMAP_PHYSICAL) += fiemap_physical.o
 
 btrfs-$(CONFIG_BTRFS_FS_RUN_SANITY_TESTS) += tests/free-space-tests.o \
 	tests/extent-buffer-tests.o tests/btrfs-tests.o \
diff -ruN a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.c
--- a/fs/btrfs/qgroup.c	2024-05-07 14:48:32.436485938 +0800
+++ b/fs/btrfs/qgroup.c	2024-05-07 15:46:53.905849110 +0800
@@ -1091,10 +1091,18 @@
 		btrfs_item_key_to_cpu(leaf, &found_key, slot);
 
 		if (found_key.type == BTRFS_ROOT_REF_KEY) {
+			struct btrfs_root *root;
 
 			/* Release locks on tree_root before we access quota_root */
 			btrfs_release_path(path);
 
+			key.objectid = found_key.offset;
+			key.type = BTRFS_ROOT_ITEM_KEY;
+			key.offset = (u64)-1;
+			root = btrfs_get_new_fs_root(fs_info, key.objectid, 0);
+			if (IS_ERR(root) || btrfs_root_readonly(root))
+				goto next_item;
+
 			ret = add_qgroup_item(trans, quota_root,
 					      found_key.offset);
 			if (ret) {
@@ -1128,6 +1136,8 @@
 				continue;
 			}
 		}
+
+next_item:
 		ret = btrfs_next_item(tree_root, path);
 		if (ret < 0) {
 			btrfs_abort_transaction(trans, ret);
diff -ruN a/fs/btrfs/relocation.c b/fs/btrfs/relocation.c
--- a/fs/btrfs/relocation.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/relocation.c	2024-05-07 15:46:53.905849110 +0800
@@ -1291,7 +1291,26 @@
 			new_ptr_gen = 0;
 		}
 
-		if (WARN_ON(new_bytenr > 0 && new_bytenr == old_bytenr)) {
+		/*
+		 * When we create the reloc root (which is a snapshot of the
+		 * subvolume tree) we set its last_snapshot field (as well as
+		 * for the subvolume's tree root) to the value of the current
+		 * transaction generation minus 1 (at create_reloc_root()).
+		 * This means that at walk_down_reloc_tree() we can catch
+		 * pointers (bytenr/generation pairs) with a generation
+		 * matching the generation of the transaction where we created
+		 * the reloc root, so those pointers correspond to tree blocks
+		 * that were either created before or after the reloc root was
+		 * created. If walk_down_reloc_tree() gave us a path that points
+		 * to a tree block that was created (or COWed) before the reloc
+		 * root was created and in the same transaction where the reloc
+		 * root was created, we have nothing to do and can safely return
+		 * (the tree block is already in both trees).
+		 */
+		if (new_bytenr > 0 && new_bytenr == old_bytenr) {
+			ASSERT(new_ptr_gen == old_ptr_gen);
+			ASSERT(new_ptr_gen ==
+			       btrfs_root_last_snapshot(&src->root_item) + 1);
 			ret = level;
 			break;
 		}
diff -ruN a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
--- a/fs/btrfs/scrub.c	2024-05-07 14:48:32.436485938 +0800
+++ b/fs/btrfs/scrub.c	2024-05-07 15:46:53.905849110 +0800
@@ -24,6 +24,7 @@
 #include "accessors.h"
 #include "file-item.h"
 #include "scrub.h"
+#include "cslink.h"
 
 /*
  * This is only the first step towards a full-features scrub. It reads all
@@ -229,6 +230,55 @@
 	struct btrfs_device	*dev;
 };
 
+#ifdef CONFIG_BTRFS_MDCSREPAIR
+#define __BTRFS_CSLINK(cond, exp, comp, size, sb, offset, blklen) 	\
+do {									\
+	__btrfs_cslink(cond, scrub_get_inum(sb), (exp), (comp), (size),	\
+		btrfs_csum_final, (sb)->physical + (offset), 		\
+		(blklen) - (offset), (sb)->dev->bdev->bd_dev,		\
+		0, (u64)~0, 0);						\
+	cond = cond != 0 ? 1 : 0;					\
+} while (0)
+
+static int scrub_get_inum_cb(u64 inum, u64 offset, u64 num_bytes,
+	u64 root, void *inump)
+{
+	*(u64 *)inump = inum;
+	return 0;
+}
+
+static u64 scrub_get_inum(struct scrub_stripe *stripe)
+{
+	struct btrfs_key found_key;
+	u64 flags = 0;
+	struct btrfs_path *path = btrfs_alloc_path();
+	u64 extent_item_pos;
+	u64 inum = 0;
+
+	if (!path)
+		return inum;
+
+	if (extent_from_logical(stripe->bg->fs_info,
+		stripe->logical, path, &found_key, &flags) < 0)
+		goto out;
+	extent_item_pos = stripe->logical - found_key.objectid;
+	if (!(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK)) {
+		struct btrfs_backref_walk_ctx ctx = { 0 };
+
+		ctx.bytenr = found_key.objectid;
+		ctx.extent_item_pos = extent_item_pos;
+		ctx.fs_info = stripe->bg->fs_info;
+		iterate_extent_inodes(&ctx, true, scrub_get_inum_cb, &inum);
+	}
+	btrfs_release_path(path);
+out:
+	btrfs_free_path(path);
+	return inum;
+}
+#else
+#define __BTRFS_CSLINK(...)	do {} while (0) 
+#endif
+
 static void release_scrub_stripe(struct scrub_stripe *stripe)
 {
 	if (!stripe)
@@ -661,6 +711,12 @@
 	}
 
 	crypto_shash_final(shash, calculated_csum);
+
+	__MDCS(on_disk_csum, calculated_csum, fs_info->csum_size,
+		BTRFS_STRIPE_LEN - BTRFS_CSUM_SIZE,
+		stripe->physical + BTRFS_CSUM_SIZE,
+		stripe->dev->bdev->bd_dev, scrub_get_inum(stripe));
+
 	if (memcmp(calculated_csum, on_disk_csum, fs_info->csum_size) != 0) {
 		bitmap_set(&stripe->meta_error_bitmap, sector_nr, sectors_per_tree);
 		bitmap_set(&stripe->error_bitmap, sector_nr, sectors_per_tree);
@@ -669,6 +725,14 @@
 			      logical, stripe->mirror_num,
 			      CSUM_FMT_VALUE(fs_info->csum_size, on_disk_csum),
 			      CSUM_FMT_VALUE(fs_info->csum_size, calculated_csum));
+
+		/* netgear patch only support crc32c by now, hard code for CRC32 */
+		if (fs_info->super_copy->csum_type == BTRFS_CSUM_TYPE_CRC32) {
+			__BTRFS_CSLINK(stripe->init_nr_csum_errors, on_disk_csum,
+				calculated_csum, fs_info->csum_size, stripe,
+				BTRFS_CSUM_SIZE, BTRFS_STRIPE_LEN);
+		}
+
 		return;
 	}
 	if (stripe->sectors[sector_nr].generation !=
@@ -2693,7 +2757,8 @@
 
 	if (ret < 0)
 		return ret;
-	ret = btrfs_check_super_csum(fs_info, sb);
+	ret = btrfs_check_super_csum(fs_info, sb, btrfs_sb_offset(0),
+		dev->bdev);
 	if (ret != 0) {
 		btrfs_err_rl(fs_info,
 			"super block at physical %llu devid %llu has bad csum",
diff -ruN a/fs/btrfs/super.c b/fs/btrfs/super.c
--- a/fs/btrfs/super.c	2024-05-07 14:48:32.426485878 +0800
+++ b/fs/btrfs/super.c	2024-05-07 15:46:53.905849110 +0800
@@ -772,11 +772,12 @@
 				goto out;
 			}
 			if (intarg == 0) {
-				btrfs_info(info,
+				if (!remounting)
+					btrfs_info(info,
 					   "using default commit interval %us",
 					   BTRFS_DEFAULT_COMMIT_INTERVAL);
 				intarg = BTRFS_DEFAULT_COMMIT_INTERVAL;
-			} else if (intarg > 300) {
+			} else if (intarg > 300 && !remounting) {
 				btrfs_warn(info, "excessive commit interval %d",
 					   intarg);
 			}
@@ -2283,7 +2284,7 @@
 		goto out;
 	}
 
-	if (btrfs_check_super_csum(fs_info, sb)) {
+	if (btrfs_check_super_csum(fs_info, sb, btrfs_sb_offset(0), dev->bdev)) {
 		btrfs_err(fs_info, "csum for on-disk super block no longer matches");
 		ret = -EUCLEAN;
 		goto out;
diff -ruN a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c
--- a/fs/btrfs/transaction.c	2024-05-07 14:48:32.436485938 +0800
+++ b/fs/btrfs/transaction.c	2024-05-07 15:46:53.905849110 +0800
@@ -1840,10 +1840,13 @@
 	 * To co-operate with that hack, we do hack again.
 	 * Or snapshot will be greatly slowed down by a subtree qgroup rescan
 	 */
-	ret = qgroup_account_snapshot(trans, root, parent_root,
-				      pending->inherit, objectid);
-	if (ret < 0)
-		goto fail;
+	/* Don't automatically add a qgroup for read-only snapshots */
+	if (!(root_flags & BTRFS_ROOT_SUBVOL_RDONLY)) {
+		ret = qgroup_account_snapshot(trans, root, parent_root,
+					      pending->inherit, objectid);
+		if (ret < 0)
+			goto fail;
+	}
 
 	ret = btrfs_insert_dir_item(trans, &fname.disk_name,
 				    BTRFS_I(parent_inode), &key, BTRFS_FT_DIR,
diff -ruN a/include/linux/i2c.h b/include/linux/i2c.h
--- a/include/linux/i2c.h	2024-05-07 14:48:33.626493014 +0800
+++ b/include/linux/i2c.h	2024-05-07 15:46:53.905849110 +0800
@@ -848,6 +848,9 @@
 	i2c_unlock_bus(adap, I2C_LOCK_ROOT_ADAPTER);
 }
 
+/* Packet Error Checking only for PMBUS's write_operations */
+#define I2C_CLIENT_PEC_PMBUS_WRITE_ONLY	0x02
+
 /* i2c adapter classes (bitmask) */
 #define I2C_CLASS_HWMON		(1<<0)	/* lm_sensors, ... */
 #define I2C_CLASS_DDC		(1<<3)	/* DDC bus on graphics adapters */
diff -ruN a/include/linux/input/smtc/misc/sx8635_i2c_reg.h b/include/linux/input/smtc/misc/sx8635_i2c_reg.h
--- a/include/linux/input/smtc/misc/sx8635_i2c_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/input/smtc/misc/sx8635_i2c_reg.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,41 @@
+/*
+ * SX8635 Cap Touch specific registers
+ *
+ * Copyright 2011 Semtech Corp.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef _SX8635_I2C_REG_H_
+#define _SX8635_I2C_REG_H_
+#include "sx863x_i2c_reg.h"
+/*
+ *  I2C Registers
+ */
+#define SX863X_CAPSTATMSB_REG     0x01
+
+#define SX863X_WHLPOSMSB_REG  0x03
+#define SX863X_WHLPOSLSB_REG  0x04
+
+#define SX863X_CAPSTAT_BUTTON11        0x800
+#define SX863X_CAPSTAT_BUTTON10        0x400
+#define SX863X_CAPSTAT_BUTTON9         0x200
+#define SX863X_CAPSTAT_BUTTON8         0x100
+
+
+/*
+ *  I2C Register Values
+ */
+
+
+#define SX863X_IRQSRC_WHEEL_FLAG      0x08
+
+/*      CapStatMsb */
+/* Did wheel rotate clockwise? */
+#define SX863X_CAPSTATMSB_WHL_CWISE   0x40
+/* Did wheel rotate counter-clockwise? */
+#define SX863X_CAPSTATMSB_WHL_CCWISE  0x20
+/* Was wheel touched or released? */
+#define SX863X_CAPSTATMSB_WHL_TOUCHED 0x10
+
+#endif /* _SX8635_I2C_REG_H_*/
diff -ruN a/include/linux/input/smtc/misc/sx8635_platform_data.h b/include/linux/input/smtc/misc/sx8635_platform_data.h
--- a/include/linux/input/smtc/misc/sx8635_platform_data.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/input/smtc/misc/sx8635_platform_data.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,306 @@
+/* !
+ * \file sx8635_platform_data.h
+ *
+ * SX8635 Platform Data
+ *
+ * Copyright 2012 Semtech Corp.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef _SX8635_PLATFORM_DATA_H_
+#define _SX8635_PLATFORM_DATA_H_
+
+#include <linux/slab.h>
+#include <linux/input.h>
+
+/*
+ * \defgroup INTENSITY_GROUP LED Intensities
+ * \{
+ */
+/*! Off Intensity Code
+ */
+#define SMTC_OFF_INTENSITY 0
+/*! On Intensity Code
+ */
+#define SMTC_ON_INTENSITY 255
+/*! Proximity Intensity Code
+ */
+#define SMTC_PROX_INTENSITY 76  // ~ 30%
+/*!  \}
+ */
+
+/*
+ * \defgroup IO_GROUP IO Numbers for LEDs
+ * \{
+ */
+/*! IO for the LED corresponding to Wheel Up
+ */
+#define WHEEL_UP_LED 0
+/*! IO for the LED corresponding to Wheel Right
+ */
+#define WHEEL_RIGHT_LED 1
+/*! IO for the LED corresponding to Wheel Down
+ */
+#define WHEEL_DOWN_LED 2
+/*! IO for the LED corresponding to Wheel Left
+ */
+#define WHEEL_LEFT_LED 3
+/*! IO for the LED corresponding to the middle button
+ */
+#define MIDDLE_BUTTON_LED 4
+/*! IO for the LED corresponding to the LOGO
+ */
+#define LOGO_LED 5
+/*!  \}
+ */
+
+
+/*! \brief Section ID codes used for Wheel and Button information
+ */
+enum _touchSectionIDs {
+  UNKNOWN_SECTION,ALL_OFF,WHEEL_UP,WHEEL_DOWN,WHEEL_LEFT,WHEEL_RIGHT,MAX_WHEEL_STATES,BUTTON_MIDDLE,BUTTON_PROX
+};
+
+/*! \brief State codes used for Wheel and Button information
+ */
+enum _states {
+  /*! In case an error or something else unknown occurs, use this
+   */
+  UNKNOWN,
+  /*! When user releases the touch, this is the event to use.
+   * If previous was TOUCH, send touch/no touch.
+   * If previous was MOVE or STOPPED, do nothing
+   */
+  RELEASED,
+  /*! When user touches a button or the wheel, go here. Does not mean to send
+   * data but the next event will determine what to send (MOVE or RELEASED)
+   * Record initial position
+   * No events should be sent out
+   * LEDs will be processed on the other section
+   */
+  TOUCH,
+  /*! When user moves passed threshold in clock wise motion send this.
+   */
+  MOVE_CWISE,
+  /*! When user moves passed threshold in counter clock wise motion send this.
+   */
+  MOVE_CCWISE,
+  /*! This is the event that is used after a wheel event occurred and user is
+   * not moving the wheel.  This only should be used as the main event IF a
+   * move has already occurred. For example, if the user TOUCHES but does not
+   * trigger a move, the main event should stay as TOUCHED so that when
+   * RELEASE occurs, the touch event gets sent.
+   */
+  STOPPED
+};
+
+
+/************************************************/
+/*! \brief Input struct. Right now just need a keycode
+ */
+struct _inputEvent {
+  int key;
+};
+typedef struct _inputEvent inputEvent_t;
+/************************************************/
+
+
+
+/************************************************/
+/*! \brief LED IO mapping struct
+ */
+struct _ledInfo {
+  /*! The IO the variable is referring to
+   */
+  u8 io;
+  /*! The intensity to set the IO to
+   */
+  u8 intensity;
+};
+/*! \brief Struct to hold the size and array of LED IO mappings
+ */
+struct _ioGroup {
+  /*! Size of the array
+   */
+  int size;
+  /*! Array of LED IO mappings
+   */
+  struct _ledInfo *led;
+};
+typedef struct _ioGroup ioGroup_t;
+typedef struct _ioGroup *pioGroup_t;
+/************************************************/
+
+
+/********************************************************/
+/*! \brief Struct containing information related to a speific
+ * wheel or button section.
+ */
+struct _touchSection {
+  /*! The Section ID associated with this variable
+   */
+  int sectionID;
+  /*! Array of what to set the IOs for LEDs to when this section is active
+   */
+  struct _ledInfo *pLEDState;
+  /*! Pointer to the Input to use for this section
+   */
+  inputEvent_t *pInputState;
+  /*! Size of pLEDState
+   */
+  int nLEDStateSize;
+  /*! \brief Current state of this section.
+   * \description This does not need to be filled in as it is changed in the
+   * code when copies of the section are made.
+   */
+  int state;
+  /*! \brief Minimum section's position when relating to a wheel section.
+   * \description This does not need to be filled in as it is changed in the
+   * code when copies of the section are made.
+   */
+  int minSection;
+  /*! \brief Maximum section's position when relating to a wheel section.
+   * \description This does not need to be filled in as it is changed in the
+   * code when copies of the section are made.
+   */
+  int maxSection;
+  /*! \brief Current section's position when relating to a wheel section.
+   * \description This does not need to be filled in as it is changed in the
+   * code when copies of the section are made.
+   */
+  int position;
+};
+typedef struct _touchSection touchSection_t;
+/********************************************************/
+
+
+/********************************************************/
+/*! \brief Struct containing information related to the wheel and
+ * button information.
+ */
+struct _touchInformation {
+
+  /*! Array for button sections (middle/prox)
+   */
+  touchSection_t *buttonSectionGroup;
+  /*! Size of the button section array
+   */
+  int nButtonSectionGroupSize;
+  /*! Array for the wheel sections
+   */
+  touchSection_t *wheelSectionGroup;
+  /*! Size of the wheel section array
+   */
+  int nWheelSectionGroupSize;
+
+  /*! Input key that should be used for a CWISE move
+   */
+  inputEvent_t *moveCWISE_InputState;
+  /*! Input key that should be used for a CCWISE movement
+   */
+  inputEvent_t *moveCCWISE_InputState;
+
+  /*! The number of wheel sensors (must coincide with SPM settings)
+   */
+  int nSensors;
+  /*! A shift amount from the max value to define how far the wheel position
+   * must be changed to be seen as a move (rotate)
+   */
+  int move_threshold_factor;
+
+  /*! Section to use when nothing is touch or in proximity
+   */
+  touchSection_t *offSection;
+  /*! Section to set when startig the proximity timer
+   */
+  touchSection_t *proxSection;
+   /*! Amount of steps to use when fading out/in
+   */
+  int nLEDIncrementSteps;
+  /*! Delay between each fade out/in steps (in milliseconds)
+   */
+  int nLEDDelayBetweenSteps;
+  /*! Timeout delay for when using the proximity timer (in milliseconds)
+   */
+  int nLEDTimeoutOffDelay;
+
+  /*! Whether to fade in when proximity first appears
+   */
+  char bLEDFadeInEnable;
+  /*! Whether to fade out when proximity is removed
+   */
+  char bLEDFadeOutEnable;
+
+  /*! \brief Max position value of the wheel
+   *  \description This is calculated inside the driver.
+   */
+  int max_value;
+  /*! \brief Move threshold for the wheel
+   *  \description This is calculated inside the driver.
+   */
+  int move_threshold;
+  /*! \brief Copy of the last section that was used
+   *  \description This is calculated inside the driver.
+   */
+  touchSection_t lastSentSection;
+  /*! \brief Input to use when sending key events
+   *  \description This is calculated inside the driver.
+   */
+  struct input_dev *input;
+};
+typedef struct _touchInformation touchInformation_t;
+/********************************************************/
+
+
+
+/*! \brief Structure containing register address and value
+ */
+struct smtc_reg_data {
+  /*! Register Address
+   */
+  unsigned char reg;
+  /*! Register Value
+   */
+  unsigned char val;
+};
+typedef struct smtc_reg_data smtc_reg_data_t;
+typedef struct smtc_reg_data *psmtc_reg_data_t;
+
+/*! \brief Main struct containing spm, i2c, touch, nirq, etc
+ */
+struct sx8635_platform_data {
+  /*! Number of i2c registers to initialize
+   */
+  int i2c_reg_num;
+  /*! Number of spm registers to initialize
+   */
+  int spm_cfg_num;
+  /*! Array of i2c registers
+   */
+  struct smtc_reg_data *i2c_reg;
+  /*! Array of spm registers
+   */
+  struct smtc_reg_data *spm_cfg;
+
+  /*! Pointer to touch information structure
+   */
+  struct _touchInformation *touchInformation;
+
+  /*! \brief Function pointer to nirq status
+   * \description Since we use ACPI this is actually not needed
+   * but here in case things change
+   */
+  int (*get_is_nirq_low)(void);
+  /*! Function pointer that can contain platform data to initialize
+   */
+  int     (*init_platform_hw)(void);
+  /*! Function pointer that can contain platform data exiting information
+   */
+  void    (*exit_platform_hw)(void);
+
+};
+typedef struct sx8635_platform_data sx8635_platform_data_t;
+typedef struct sx8635_platform_data *psx8635_platform_data_t;
+
+#endif
diff -ruN a/include/linux/input/smtc/misc/sx8635_spm_cfg.h b/include/linux/input/smtc/misc/sx8635_spm_cfg.h
--- a/include/linux/input/smtc/misc/sx8635_spm_cfg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/input/smtc/misc/sx8635_spm_cfg.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,140 @@
+/*
+ * SX8635 Cap Touch specific registers
+ * Defines are written as 3X to make it easier when using them in code
+ *
+ * Copyright 2012 Semtech Corp.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef _SX8635_SPM_REG_H_
+#define _SX8635_SPM_REG_H_
+#include "sx863x_spm_cfg.h"
+
+/*
+ * spm address map supplemental for SX8635
+ */
+
+#define SX863X_CAPMODE11_8_SPM 0x0A /* default QSM: 0xAA */
+#define SX863X_CAPSENSITIVITY8_9_SPM 0x11 /* default QSM: 0x00 */
+#define SX863X_CAPSENSITIVITY10_11_SPM 0x12 /* default QSM: 0x00 */
+#define SX863X_CAPTHRESH8_SPM 0x1B /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH9_SPM 0x1C /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH10_SPM 0x1D /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH11_SPM 0x1E /* default QSM: 0xA0 */
+
+#define SX863X_WHLCFG_SPM             0x27
+#define SX863X_WHLSTUCKATTIMEOUT_SPM  0x28
+#define SX863X_WHLHYSTERESIS_SPM      0x29
+#define SX863X_WHLNORMMSB_SPM         0x2B
+#define SX863X_WHLNORMLSB_SPM         0x2C
+#define SX863X_WHLAVGTHRESH_SPM       0x2D
+#define SX863X_WHLCOMPNEGTHRESH_SPM   0x2E
+#define SX863X_WHLCOMPNEGCNTMAX_SPM   0x2F
+#define SX863X_WHLROTATETHRESH_SPM    0x30
+#define SX863X_WHLOFFSET_SPM          0x31
+
+/*
+ * SPM Values
+ */
+/*    CapMode11_8          */
+#define SX863X_CAPMODE11_8_CAP11_BUTTON 0x40
+#define SX863X_CAPMODE11_8_CAP10_BUTTON 0x10
+#define SX863X_CAPMODE11_8_CAP9_BUTTON 0x04
+#define SX863X_CAPMODE11_8_CAP8_BUTTON 0x01
+
+#define SX863X_CAPMODE11_8_CAP11_WHEEL 0xC0
+#define SX863X_CAPMODE11_8_CAP10_WHEEL 0x30
+#define SX863X_CAPMODE11_8_CAP9_WHEEL  0x0C
+#define SX863X_CAPMODE11_8_CAP8_WHEEL  0x03
+/*    CapMode7_4          */
+#define SX863X_CAPMODE7_4_CAP7_WHEEL   0xC0
+#define SX863X_CAPMODE7_4_CAP6_WHEEL   0x30
+#define SX863X_CAPMODE7_4_CAP5_WHEEL   0x0C
+#define SX863X_CAPMODE7_4_CAP4_WHEEL   0x03
+/*    CapMode3_0          */
+#define SX863X_CAPMODE3_0_CAP3_WHEEL   0xC0
+#define SX863X_CAPMODE3_0_CAP2_WHEEL   0x30
+#define SX863X_CAPMODE3_0_CAP1_WHEEL   0x0C
+#define SX863X_CAPMODE3_0_CAP0_WHEEL   0x03
+/*    CapSensitivity8_9   */
+#define SX863X_CAPSENSITIVITY8_9_MSK 0x77
+#define SX863X_CAPSENSITIVITY8_9_DEFAULT 0x00
+/*    CapSensitivity10_11   */
+#define SX863X_CAPSENSITIVITY10_11_MSK 0x77
+#define SX863X_CAPSENSITIVITY10_11_DEFAULT 0x00
+
+/*    CapThresh8   */
+#define SX863X_CAPTHRESH8_640 0xA0
+#define SX863X_CAPTHRESH8_DEFAULT SX863X_CAPTHRESH8_640
+/*    CapThresh9   */
+#define SX863X_CAPTHRESH9_640 0xA0
+#define SX863X_CAPTHRESH9_DEFAULT SX863X_CAPTHRESH9_640
+/*    CapThresh10   */
+#define SX863X_CAPTHRESH10_640 0xA0
+#define SX863X_CAPTHRESH10_DEFAULT SX863X_CAPTHRESH10_640
+/*    CapThresh11   */
+#define SX863X_CAPTHRESH11_640 0xA0
+#define SX863X_CAPTHRESH11_DEFAULT SX863X_CAPTHRESH11_640
+
+/*    WhlCfg              */
+#define SX863X_WHLCFG_RELEASE_DEBOUNCE_OFF 0x00
+#define SX863X_WHLCFG_RELEASE_DEBOUNCE_2   0x04
+#define SX863X_WHLCFG_RELEASE_DEBOUNCE_3   0x08
+#define SX863X_WHLCFG_RELEASE_DEBOUNCE_4   0x0C
+
+#define SX863X_WHLCFG_TOUCH_DEBOUNCE_OFF 0x00
+#define SX863X_WHLCFG_TOUCH_DEBOUNCE_2   0x01
+#define SX863X_WHLCFG_TOUCH_DEBOUNCE_3   0x02
+#define SX863X_WHLCFG_TOUCH_DEBOUNCE_4   0x03
+
+#define SX863X_WHLCFG_DEFAULT SX863X_WHLCFG_RELEASE_DEBOUNCE_OFF | \
+                              SX863X_WHLCFG_TOUCH_DEBOUNCE_OFF
+
+
+#define SX863X_WHLSTUCKATTIMEOUT_OFF   0x00
+#define SX863X_WHLSTUCKATTIMEOUT_1S    0x01
+#define SX863X_WHLSTUCKATTIMEOUT_255S   0xFF
+#define SX863X_WHLSTUCKATTIMEOUT_DEFAULT SX863X_WHLSTUCKATTIMEOUT_OFF
+
+
+#define SX863X_WHLNORM_320  0x0140
+#define SX863X_WHLNORM_DEFAULT SX863X_WHLNORM_320
+
+
+
+#define SX863X_WHLHYSTERESIS_O     0x00
+#define SX863X_WHLHYSTERESIS_4     0x01
+#define SX863X_WHLHYSTERESIS_12    0x03
+#define SX863X_WHLHYSTERESIS_1020  0xFF
+#define SX863X_WHLHYSTERESIS_DEFAULT SX863X_WHLHYSTERESIS_12
+
+#define SX863X_WHLAVGTHRESH_O     0x00
+#define SX863X_WHLAVGTHRESH_4     0x01
+#define SX863X_WHLAVGTHRESH_320   0x50
+#define SX863X_WHLAVGTHRESH_1020  0xFF
+#define SX863X_WHLAVGTHRESH_DEFAULT SX863X_WHLAVGTHRESH_320
+
+#define SX863X_WHLCOMPNEGTHRESH_O     0x00
+#define SX863X_WHLCOMPNEGTHRESH_4     0x01
+#define SX863X_WHLCOMPNEGTHRESH_320   0x50
+#define SX863X_WHLCOMPNEGTHRESH_1020  0xFF
+#define SX863X_WHLCOMPNEGTHRESH_DEFAULT SX863X_WHLCOMPNEGTHRESH_320
+
+#define SX863X_WHLCOMPNEGCNTMAX_RESERVED   0x00
+#define SX863X_WHLCOMPNEGCNTMAX_1SAMPLE    0x01
+#define SX863X_WHLCOMPNEGCNTMAX_255SAMPLES 0xFF
+#define SX863X_WHLCOMPNEGCNTMAX_DEFAULT SX863X_WHLCOMPNEGCNTMAX_1SAMPLE
+
+#define SX863X_WHLROTATETHRESH_0PERCENT   0x00
+#define SX863X_WHLROTATETHRESH_2PERCENT   0x02
+#define SX863X_WHLROTATETHRESH_100PERCENT  0x64
+#define SX863X_WHLROTATETHRESH_DEFAULT SX863X_WHLROTATETHRESH_2PERCENT
+
+#define SX863X_WHLOFFSET_0       0x00
+#define SX863X_WHLOFFSET_1_256   0x01
+#define SX863X_WHLOFFSET_255_256 0xFF
+#define SX863X_WHLOFFSET_DEFAULT SX863X_WHLOFFSET_0
+
+
+#endif /* _SX8635_SPM_REG_H_*/
diff -ruN a/include/linux/input/smtc/misc/sx863x_i2c_reg.h b/include/linux/input/smtc/misc/sx863x_i2c_reg.h
--- a/include/linux/input/smtc/misc/sx863x_i2c_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/input/smtc/misc/sx863x_i2c_reg.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,157 @@
+/*
+ * SX863X Cap Touch
+ * Currently Supports:
+ *  SX8636
+ * Future Supports:
+ *  SX8634, SX8635, SX8644, etc
+ *
+ * Copyright 2011 Semtech Corp.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef _SX863X_I2C_REG_H_
+#define _SX863X_I2C_REG_H_
+
+/*
+ *  I2C Registers
+ */
+#define SX863X_IRQSRC_REG         0x00
+#define SX863X_RESERVED_0x01_REG  0x01
+#define SX863X_CAPSTATLSB_REG     0x02
+#define SX863X_RESERVED_0x03_REG  0x03
+#define SX863X_RESERVED_0x04_REG  0x04
+#define SX863X_RESERVED_0x05_REG  0x05
+#define SX863X_RESERVED_0x06_REG  0x06
+#define SX863X_GPISTAT_REG        0x07
+#define SX863X_SPMSTAT_REG        0x08
+#define SX863X_COMPOPMODE_REG     0x09
+#define SX863X_GPOCTRL_REG        0x0A
+#define SX863X_GPPID_REG          0x0B
+#define SX863X_GPPINTENSITY_REG   0x0C
+#define SX863X_SPMCFG_REG         0x0D
+#define SX863X_SPMBASEADDR_REG    0x0E
+#define SX863X_RESERVED_0x0F_REG  0x0F
+#define SX863X_SPMKEYMSB_REG      0xAC
+#define SX863X_SPMKEYLSB_REG      0xAD
+#define SX863X_SOFTRESET_REG      0xB1
+
+
+/*
+ *  I2C Register Values
+ */
+/*      IrqSrc 0:Inactive 1:Active     */
+#define SX863X_IRQSRC_RESERVED_0x80       0x80
+#define SX863X_IRQSRC_NVM_BURN_FLAG       0x40
+#define SX863X_IRQSRC_SPM_WRITE_FLAG      0x20
+#define SX863X_IRQSRC_GPI_FLAG            0x10
+#define SX863X_IRQSRC_RESERVED_0x08       0x08
+#define SX863X_IRQSRC_BUTTON_FLAG         0x04
+#define SX863X_IRQSRC_COMPENSATION_FLAG   0x02
+#define SX863X_IRQSRC_OPERATING_MODE_FLAG 0x01
+
+
+#define SX863X_CAPSTAT_BUTTON7         0x080
+#define SX863X_CAPSTAT_BUTTON6         0x040
+#define SX863X_CAPSTAT_BUTTON5         0x020
+#define SX863X_CAPSTAT_BUTTON4         0x010
+#define SX863X_CAPSTAT_BUTTON3         0x008
+#define SX863X_CAPSTAT_BUTTON2         0x004
+#define SX863X_CAPSTAT_BUTTON1         0x002
+#define SX863X_CAPSTAT_BUTTON0         0x001
+
+
+
+/*      CapStatLsb 0:Released 1:Touched     */
+#define SX863X_CAPSTATLSB_BUTTON7         0x80
+#define SX863X_CAPSTATLSB_BUTTON6         0x40
+#define SX863X_CAPSTATLSB_BUTTON5         0x20
+#define SX863X_CAPSTATLSB_BUTTON4         0x10
+#define SX863X_CAPSTATLSB_BUTTON3         0x08
+#define SX863X_CAPSTATLSB_BUTTON2         0x04
+#define SX863X_CAPSTATLSB_BUTTON1         0x02
+#define SX863X_CAPSTATLSB_BUTTON0         0x01
+
+/*      GpiStat 0:Low 1:High     */
+#define SX863X_GPISTAT_7         0x80
+#define SX863X_GPISTAT_6         0x40
+#define SX863X_GPISTAT_5         0x20
+#define SX863X_GPISTAT_4         0x10
+#define SX863X_GPISTAT_3         0x08
+#define SX863X_GPISTAT_2         0x04
+#define SX863X_GPISTAT_1         0x02
+#define SX863X_GPISTAT_0         0x01
+
+/*      SpmStat                  */
+#define SX863X_SPMSTAT_RESERVED_0xF0  0xF0
+#define SX863X_SPMSTAT_NVMVALID       0x08
+#define SX863X_SPMSTAT_NVMCOUNT_MSK       0x07
+#define SX863X_SPMSTAT_NVMCOUNT_NONE      0x00
+#define SX863X_SPMSTAT_NVMCOUNT_ONCE      0x01
+#define SX863X_SPMSTAT_NVMCOUNT_TWICE     0x02
+#define SX863X_SPMSTAT_NVMCOUNT_THREE     0x03
+#define SX863X_SPMSTAT_NVMCOUNT_MORETHERE 0x04
+
+/*      CompOpMode                  */
+#define SX863X_COMPOPMODE_RESERVED_0xF8           0x00
+#define SX863X_COMPOPMODE_COMPENSATION            0x04
+#define SX863X_COMPOPMODE_OPERATINGMODE_MSK       0x03
+#define SX863X_COMPOPMODE_OPERATINGMODE_ACTIVE    0x00
+#define SX863X_COMPOPMODE_OPERATINGMODE_DOZE      0x01
+#define SX863X_COMPOPMODE_OPERATINGMODE_SLEEP     0x02
+#define SX863X_COMPOPMODE_OPERATINGMODE_RESERVED  0x03
+
+/*      GpoCtrl 0:OFF 1:ON     */
+#define SX863X_GPOCTRL_ON7         0x80
+#define SX863X_GPOCTRL_ON6         0x40
+#define SX863X_GPOCTRL_ON5         0x20
+#define SX863X_GPOCTRL_ON4         0x10
+#define SX863X_GPOCTRL_ON3         0x08
+#define SX863X_GPOCTRL_ON2         0x04
+#define SX863X_GPOCTRL_ON1         0x02
+#define SX863X_GPOCTRL_ON0         0x01
+
+/*      GppPinId  */
+#define SX863X_GPPPINID_RESERVED_0xF8  0xF8
+#define SX863X_GPPPINID_GPPID_MSK      0x07
+#define SX863X_GPPPINID_GPPID_GPP0     0x00
+#define SX863X_GPPPINID_GPPID_GPP1     0x01
+#define SX863X_GPPPINID_GPPID_GPP2     0x02
+#define SX863X_GPPPINID_GPPID_GPP3     0x03
+#define SX863X_GPPPINID_GPPID_GPP4     0x04
+#define SX863X_GPPPINID_GPPID_GPP5     0x05
+#define SX863X_GPPPINID_GPPID_GPP6     0x06
+#define SX863X_GPPPINID_GPPID_GPP7     0x07
+
+/*      GppIntensity Specify 0 - 255 */
+#define SX863X_GPPPINTENSITY_MSK  0xFF
+
+/*      SoftReset */
+#define SX863X_SOFTRESET_COMMAND1  0xDE
+#define SX863X_SOFTRESET_COMMAND2  0x00
+
+/*      SpmCfg */
+#define SX863X_SPMCFG_RESERVED_0xC0    0xC0
+#define SX863X_SPMCFG_I2CSPM_MSK       0x30
+#define SX863X_SPMCFG_I2CSPM_OFF       0x00
+#define SX863X_SPMCFG_I2CSPM_ON        0x10
+#define SX863X_SPMCFG_I2CSPM_RESERVED1 0x20
+#define SX863X_SPMCFG_I2CSPM_RESERVED2 0x30
+#define SX863X_SPMCFG_RWSPM_MSK        0x08
+#define SX863X_SPMCFG_RWSPM_WRITE      0x00
+#define SX863X_SPMCFG_RWSPM_READ       0x08
+#define SX863X_SPMCFG_RESERVED_0x07    0x07
+#define SX863X_SPMCFG_MONITORMODE_MSK  0x04
+#define SX863X_SPMCFG_MONITORMODE_OFF  0x00
+#define SX863X_SPMCFG_MONITORMODE_ON   0x04
+
+/*  SpmBaseAddr Specify 0x00 - 0x78 (mod 8) */
+#define SX863X_SPMBASEADDR_MSK  0xFF
+
+/*  SpmKeyMsb  */
+#define SX863X_SPMKEYMSB_UNLOCK 0x62
+
+/*  SpmKeyLsb  */
+#define SX863X_SPMKEYLSB_UNLOCK 0x9D
+
+#endif /* _SX863X_I2C_REG_H_*/
diff -ruN a/include/linux/input/smtc/misc/sx863x_spm_cfg.h b/include/linux/input/smtc/misc/sx863x_spm_cfg.h
--- a/include/linux/input/smtc/misc/sx863x_spm_cfg.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/linux/input/smtc/misc/sx863x_spm_cfg.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,701 @@
+/*
+ * SX863X Cap Touch
+ * Currently Supports:
+ *  SX8636
+ * Future Supports:
+ *  SX8634, SX8635
+ *
+ * Copyright 2011 Semtech Corp.
+ *
+ * Licensed under the GPL-2 or later.
+ */
+
+#ifndef _SX863X_SPM_REG_H_
+#define _SX863X_SPM_REG_H_
+
+/*
+ * spm address map... (currently only showing SX8636 )
+ */
+
+/* Reserved 0x00, 0x01, 0x02, 0x03 */
+/*  --  General --  */
+#define SX863X_I2CADDRESS_SPM       0x04 /* default QSM: 0x2B */
+#define SX863X_ACTIVESCANPERIOD_SPM 0x05 /* default QSM: 0x02 */
+#define SX863X_DOZESCANPERIOD_SPM   0x06 /* default QSM: 0x0D */
+#define SX863X_PASSIVETIMER_SPM     0x07 /* default QSM: 0x00 */
+/* Reserved 0x08 */
+/*  --  Capacitive Sensors --  */
+#define SX863X_CAPEMODEMISC_SPM     0x09 /* default QSM: 0x01 */
+/* Reserved 0x0A */
+#define SX863X_CAPMODE7_4_SPM 0x0B /* default QSM: 0x55 */
+#define SX863X_CAPMODE3_0_SPM 0x0C /* default QSM: 0x55 */
+#define SX863X_CAPSENSITIVITY0_1_SPM 0x0D /* default QSM: 0x00 */
+#define SX863X_CAPSENSITIVITY2_3_SPM 0x0E /* default QSM: 0x00 */
+#define SX863X_CAPSENSITIVITY4_5_SPM 0x0F /* default QSM: 0x00 */
+#define SX863X_CAPSENSITIVITY6_7_SPM 0x10 /* default QSM: 0x00 */
+/* Reserved 0x11, 0x12 */
+#define SX863X_CAPTHRESH0_SPM 0x13 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH1_SPM 0x14 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH2_SPM 0x15 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH3_SPM 0x16 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH4_SPM 0x17 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH5_SPM 0x18 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH6_SPM 0x19 /* default QSM: 0xA0 */
+#define SX863X_CAPTHRESH7_SPM 0x1A /* default QSM: 0xA0 */
+/* Reserved 0x1B, 0x1C, 0x1D, 0x1E */
+#define SX863X_CAPPERCOMP_SPM 0x1F /* default QSM: 0x00 */
+/* Reserved 0x20 */
+/*  --  Button --  */
+#define SX863X_BTNCFG_SPM            0x21 /* default QSM: 0x30 */
+#define SX863X_BTNAVGTHRESH_SPM      0x22 /* default QSM: 0x50 */
+#define SX863X_BTNCOMPNEGTHRESH_SPM  0x23 /* default QSM: 0x50 */
+#define SX863X_BTNCOMPNEGCNTMAX_SPM  0x24 /* default QSM: 0x01 */
+#define SX863X_BTNHYSTERESIS_SPM     0x25 /* default QSM: 0x0A */
+#define SX863X_BTNSTUCKATTIMEOUT_SPM 0x26 /* default QSM: 0x00 */
+/* Reserved 0x27, 0x28, 0x29, 0x2A, 0x2B,
+ * 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32 */
+/*  --  Mapping --  */
+#define SX863X_MAPWAKEUPSIZE_SPM       0x33 /* default QSM: 0x00 */
+#define SX863X_MAPWAKEUPVALUE0_SPM     0x34 /* default QSM: 0x00 */
+#define SX863X_MAPWAKEUPVALUE1_SPM     0x35 /* default QSM: 0x00 */
+#define SX863X_MAPWAKEUPVALUE2_SPM     0x36 /* default QSM: 0x00 */
+#define SX863X_MAPAUTOLIGHT0_SPM       0x37 /* default QSM: 0x76 */
+#define SX863X_MAPAUTOLIGHT1_SPM       0x38 /* default QSM: 0x54 */
+#define SX863X_MAPAUTOLIGHT2_SPM       0x39 /* default QSM: 0x32 */
+#define SX863X_MAPAUTOLIGHT3_SPM       0x3A /* default QSM: 0x10 */
+#define SX863X_MAPAUTOLIGHTGRP0MSB_SPM 0x3B /* default QSM: 0x00 */
+#define SX863X_MAPAUTOLIGHTGRP0LSB_SPM 0x3C /* default QSM: 0x00 */
+#define SX863X_MAPAUTOLIGHTGRP1MSB_SPM 0x3D /* default QSM: 0x00 */
+#define SX863X_MAPAUTOLIGHTGRP1LSB_SPM 0x3E /* default QSM: 0x00 */
+/* Reserved 0x3F */
+#define SX863X_GPIOMODE7_4_SPM						0x40
+#define SX863X_GPIOMODE3_0_SPM						0x41
+#define SX863X_GPIOOUTPWRUP_SPM					0x42
+#define SX863X_GPIOAUTOLIGHT_SPM					0x43
+#define SX863X_GPIOPOLARITY_SPM					0x44
+#define SX863X_GPIOINTENSITYON0_SPM				0x45
+#define SX863X_GPIOINTENSITYON1_SPM				0x46
+#define SX863X_GPIOINTENSITYON2_SPM				0x47
+#define SX863X_GPIOINTENSITYON3_SPM				0x48
+#define SX863X_GPIOINTENSITYON4_SPM				0x49
+#define SX863X_GPIOINTENSITYON5_SPM				0x4A
+#define SX863X_GPIOINTENSITYON6_SPM				0x4B
+#define SX863X_GPIOINTENSITYON7_SPM				0x4C
+#define SX863X_GPIOINTENSITYOFF0_SPM				0x4D
+#define SX863X_GPIOINTENSITYOFF1_SPM				0x4E
+#define SX863X_GPIOINTENSITYOFF2_SPM				0x4F
+#define SX863X_GPIOINTENSITYOFF3_SPM				0x50
+#define SX863X_GPIOINTENSITYOFF4_SPM				0x51
+#define SX863X_GPIOINTENSITYOFF5_SPM				0x52
+#define SX863X_GPIOINTENSITYOFF6_SPM				0x53
+#define SX863X_GPIOINTENSITYOFF7_SPM				0x54
+/* Reserved 0x55 */
+#define SX863X_GPIOFUNCTION_SPM					0x56
+#define SX863X_GPIOINCFACTOR_SPM					0x57
+#define SX863X_GPIODECFACTOR_SPM					0x58
+#define SX863X_GPIOINCTIME7_6_SPM					0x59
+#define SX863X_GPIOINCTIME5_4_SPM					0x5A
+#define SX863X_GPIOINCTIME3_2_SPM					0x5B
+#define SX863X_GPIOINCTIME1_0_SPM					0x5C
+#define SX863X_GPIODECTIME7_6_SPM					0x5D
+#define SX863X_GPIODECTIME5_4_SPM					0x5E
+#define SX863X_GPIODECTIME3_2_SPM					0x5F
+#define SX863X_GPIODECTIME1_0_SPM					0x60
+#define SX863X_GPIOOFFDELAY7_6_SPM					0x61
+#define SX863X_GPIOOFFDELAY5_4_SPM					0x62
+#define SX863X_GPIOOFFDELAY3_2_SPM					0x63
+#define SX863X_GPIOOFFDELAY1_0_SPM					0x64
+#define SX863X_GPIOPULLUPDOWN7_4_SPM				0x65
+#define SX863X_GPIOPULLUPDOWN3_0_SPM				0x66
+#define SX863X_GPIOINTERRUPT7_4_SPM					0x67
+#define SX863X_GPIOINTERRUPT3_0_SPM					0x68
+#define SX863X_GPIODEBOUNCE_SPM					0x69
+/* Reserved 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F */
+/* -- Proximity -- */
+#define SX863X_CAPPROXENABLE_SPM						0x70
+/* Reserved 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
+ * 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E */
+/* -- SPM Crc -- */
+#define SX863X_CRC_SPM								0x7F
+/* Monitor Addressing */
+#define SX863X_CAPRAW_0_MSB_SPM					0x80
+#define SX863X_CAPRAW_0_LSB_SPM					0x81
+#define SX863X_CAPRAW_1_MSB_SPM					0x82
+#define SX863X_CAPRAW_1_LSB_SPM					0x83
+#define SX863X_CAPRAW_2_MSB_SPM					0x84
+#define SX863X_CAPRAW_2_LSB_SPM					0x85
+#define SX863X_CAPRAW_3_MSB_SPM					0x86
+#define SX863X_CAPRAW_3_LSB_SPM					0x87
+#define SX863X_CAPRAW_4_MSB_SPM					0x88
+#define SX863X_CAPRAW_4_LSB_SPM					0x89
+#define SX863X_CAPRAW_5_MSB_SPM					0x8A
+#define SX863X_CAPRAW_5_LSB_SPM					0x8B
+#define SX863X_CAPRAW_6_MSB_SPM					0x8C
+#define SX863X_CAPRAW_6_LSB_SPM					0x8D
+#define SX863X_CAPRAW_7_MSB_SPM					0x8E
+#define SX863X_CAPRAW_7_LSB_SPM					0x8F
+
+#define SX863X_CAPAVG_0_MSB_SPM					0x9A
+#define SX863X_CAPAVG_0_LSB_SPM					0x9B
+#define SX863X_CAPAVG_1_MSB_SPM					0x9C
+#define SX863X_CAPAVG_1_LSB_SPM					0x9D
+#define SX863X_CAPAVG_2_MSB_SPM					0x9E
+#define SX863X_CAPAVG_2_LSB_SPM					0x9F
+#define SX863X_CAPAVG_3_MSB_SPM					0xA0
+#define SX863X_CAPAVG_3_LSB_SPM					0xA1
+#define SX863X_CAPAVG_4_MSB_SPM					0xA2
+#define SX863X_CAPAVG_4_LSB_SPM					0xA3
+#define SX863X_CAPAVG_5_MSB_SPM					0xA4
+#define SX863X_CAPAVG_5_LSB_SPM					0xA5
+#define SX863X_CAPAVG_6_MSB_SPM					0xA6
+#define SX863X_CAPAVG_6_LSB_SPM					0xA7
+#define SX863X_CAPAVG_7_MSB_SPM					0xA8
+#define SX863X_CAPAVG_7_LSB_SPM					0xA9
+
+/* DIFF information. NOTE: 8 bit boundary start at 0xB0 */
+#define SX863X_CAPDIFF_0_MSB_SPM					0xB4
+#define SX863X_CAPDIFF_0_LSB_SPM					0xB5
+#define SX863X_CAPDIFF_1_MSB_SPM					0xB6
+#define SX863X_CAPDIFF_1_LSB_SPM					0xB7
+#define SX863X_CAPDIFF_2_MSB_SPM					0xB8
+#define SX863X_CAPDIFF_2_LSB_SPM					0xB9
+#define SX863X_CAPDIFF_3_MSB_SPM					0xBA
+#define SX863X_CAPDIFF_3_LSB_SPM					0xBB
+#define SX863X_CAPDIFF_4_MSB_SPM					0xBC
+#define SX863X_CAPDIFF_4_LSB_SPM					0xBD
+#define SX863X_CAPDIFF_5_MSB_SPM					0xBE
+#define SX863X_CAPDIFF_5_LSB_SPM					0xBF
+#define SX863X_CAPDIFF_6_MSB_SPM					0xC0
+#define SX863X_CAPDIFF_6_LSB_SPM					0xC1
+#define SX863X_CAPDIFF_7_MSB_SPM					0xC2
+#define SX863X_CAPDIFF_7_LSB_SPM					0xC3
+/* Monitor mode period */
+/* for 8 bit boundary use 0xF8 */
+#define SX863X_CAP_MONITOR_PERIOD_SPM			0xF9
+
+
+
+
+/*
+ * SPM Values
+ */
+/*  --  General --  */
+/*    I2C Address     */
+#define SX863X_I2CADDRESS_MSK       0x7F
+/*    Active Scan Period    */
+#define SX863X_ACTIVESCANPERIOD_30MS 0x02
+#define SX863X_ACTIVESCANPERIOD_DEFAULT SX863X_ACTIVESCANPERIOD_30MS
+/*    Doze Scan Period    */
+#define SX863X_DOZESCANPERIOD_195MS   0x0D
+#define SX863X_DOZESCANPERIOD_DEFAULT   SX863X_DOZESCANPERIOD_195MS
+/*    Passive Timer        */
+#define SX863X_PASSIVETIMER_OFF     0x00
+#define SX863X_PASSIVETIMER_DEFAULT SX863X_PASSIVETIMER_OFF
+/*  --  Capacitive Sensors --  */
+/*    CapModeMisc         */
+#define SX863X_CAPEMODEMISC_MSK         0x05
+#define SX863X_CAPEMODEMISC_COMMON      0x01
+#define SX863X_CAPEMODEMISC_INDIVIDUAL  0x04
+/*    CapMode7_4          */
+#define SX863X_CAPMODE7_4_CAP7_BUTTON 0x40
+#define SX863X_CAPMODE7_4_CAP6_BUTTON 0x10
+#define SX863X_CAPMODE7_4_CAP5_BUTTON 0x04
+#define SX863X_CAPMODE7_4_CAP4_BUTTON 0x01
+/*    CapMode3_0          */
+#define SX863X_CAPMODE3_0_CAP3_BUTTON 0x40
+#define SX863X_CAPMODE3_0_CAP2_BUTTON 0x10
+#define SX863X_CAPMODE3_0_CAP1_BUTTON 0x04
+#define SX863X_CAPMODE3_0_CAP0_BUTTON 0x01
+/*    CapSensitivity0_1   */
+#define SX863X_CAPSENSITIVITY0_1_MSK 0x77
+#define SX863X_CAPSENSITIVITY0_1_DEFAULT 0x00
+/*    CapSensitivity2_3   */
+#define SX863X_CAPSENSITIVITY2_3_MSK 0x77
+#define SX863X_CAPSENSITIVITY2_3_DEFAULT 0x00
+/*    CapSensitivity4_5   */
+#define SX863X_CAPSENSITIVITY4_5_MSK 0x77
+#define SX863X_CAPSENSITIVITY4_5_DEFAULT 0x00
+/*    CapSensitivity6_7   */
+#define SX863X_CAPSENSITIVITY6_7_MSK 0x77
+#define SX863X_CAPSENSITIVITY6_7_DEFAULT 0x00
+
+/*    CapThresh0   */
+#define SX863X_CAPTHRESH0_640 0xA0
+#define SX863X_CAPTHRESH0_DEFAULT SX863X_CAPTHRESH0_640
+/*    CapThresh1   */
+#define SX863X_CAPTHRESH1_640 0xA0
+#define SX863X_CAPTHRESH1_DEFAULT SX863X_CAPTHRESH1_640
+/*    CapThresh2   */
+#define SX863X_CAPTHRESH2_640 0xA0
+#define SX863X_CAPTHRESH2_DEFAULT SX863X_CAPTHRESH2_640
+/*    CapThresh3   */
+#define SX863X_CAPTHRESH3_640 0xA0
+#define SX863X_CAPTHRESH3_DEFAULT SX863X_CAPTHRESH3_640
+/*    CapThresh4   */
+#define SX863X_CAPTHRESH4_640 0xA0
+#define SX863X_CAPTHRESH4_DEFAULT SX863X_CAPTHRESH4_640
+/*    CapThresh5   */
+#define SX863X_CAPTHRESH5_640 0xA0
+#define SX863X_CAPTHRESH5_DEFAULT SX863X_CAPTHRESH5_640
+/*    CapThresh6   */
+#define SX863X_CAPTHRESH6_640 0xA0
+#define SX863X_CAPTHRESH6_DEFAULT SX863X_CAPTHRESH6_640
+/*    CapThresh7   */
+#define SX863X_CAPTHRESH7_640 0xA0
+#define SX863X_CAPTHRESH7_DEFAULT SX863X_CAPTHRESH7_640
+
+/*    CapPerComp  */
+#define SX863X_CAPPERCOMP_MSK 0x0F
+#define SX863X_CAPPERCOMP_OFF 0x00
+#define SX863X_CAPPERCOMP_DEFAULT SX863X_CAPPERCOMP_OFF
+/* -- Proximity -- */
+/*    CapProxEnable */
+#define SX863X_CAPPROXENABLE_OFF	0x46
+#define SX863X_CAPPROXENABLE_ON 	0x74
+/*  --  Button --  */
+/*    BtnCfg        */
+#define SX863X_BTNCFG_REPORT_MULTIPLE 0x00
+#define SX863X_BTNCFG_REPORT_SINGLE   0x40
+#define SX863X_BTNCFG_REPROT_DEFAULT  SX863X_BTNCFG_REPORT_MULTIPLE
+#define SX863X_BTNCFG_INTERRUPT_MASKED  0x00
+#define SX863X_BTNCFG_INTERRUPT_TOUCHED  0x10
+#define SX863X_BTNCFG_INTERRUPT_RELEASE  0x20
+#define SX863X_BTNCFG_INTERRUPT_BOTH     0x30
+#define SX863X_BTNCFG_INTERRUPT_DEFAULT  SX863X_BTNCFG_INTERRUPT_BOTH
+#define SX863X_BTNCFG_RELEASE_DEBOUNCE_OFF      0x00
+#define SX863X_BTNCFG_RELEASE_DEBOUNCE_2SAMPLE  0x04
+#define SX863X_BTNCFG_RELEASE_DEBOUNCE_3SAMPLE  0x08
+#define SX863X_BTNCFG_RELEASE_DEBOUNCE_4SAMPLE  0x0C
+#define SX863X_BTNCFG_TOUCH_DEBOUNCE_OFF      0x00
+#define SX863X_BTNCFG_TOUCH_DEBOUNCE_2SAMPLE  0x01
+#define SX863X_BTNCFG_TOUCH_DEBOUNCE_3SAMPLE  0x02
+#define SX863X_BTNCFG_TOUCH_DEBOUNCE_4SAMPLE  0x03
+/*    BtnAvgThresh    */
+#define SX863X_BTNAVGTHRESH_320      0x50
+#define SX863X_BTNAVGTHRESH_DEFAULT SX863X_BTNAVGTHRESH_320
+/*    BtnCompNegThresh  */
+#define SX863X_BTNCOMPNEGTHRESH_320  0x50
+#define SX863X_BTNCOMPNEGTHRESH_DEFAULT SX863X_BTNCOMPNEGTHRESH_320
+/*    BtnCompNegCntMax  */
+#define SX863X_BTNCOMPNEGCNTMAX_1SAMPLE  0x01
+#define SX863X_BTNCOMPNEGCNTMAX_DEFAULT SX863X_BTNCOMPNEGCNTMAX_1SAMPLE
+/*    BtnHysteresis   */
+#define SX863X_BTNHYSTERESIS_10PERCENT  0x0A
+#define SX863X_BTNHYSTERESIS_DEFAULT  SX863X_BTNHYSTERESIS_10PERCENT
+/*    BtnStuckAtTimeout   */
+#define SX863X_BTNSTUCKATTIMEOUT_OFF 0x00
+#define SX863X_BTNSTUCKATTIMEOUT_DEFAULT SX863X_BTNSTUCKATTIMEOUT_OFF
+/*  --  Mapping --  */
+/*    MapWakeupSize   */
+#define SX863X_MAPWAKEUPSIZE_MSK            0x07
+#define SX863X_MAPWAKEUPSIZE_ANY            0x00
+#define SX863X_MAPWAKEUPSIZE_KEY0           0x01
+#define SX863X_MAPWAKEUPSIZE_KEY0_1         0x02
+#define SX863X_MAPWAKEUPSIZE_KEY0_1_2       0x03
+#define SX863X_MAPWAKEUPSIZE_KEY0_1_2_3     0x04
+#define SX863X_MAPWAKEUPSIZE_KEY0_1_2_3_4   0x05
+#define SX863X_MAPWAKEUPSIZE_KEY0_1_2_3_4_5 0x06
+#define SX863X_MAPWAKEUPSIZE_NONE           0x07
+/*    MapWakeupValue0  */
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN1 0x10
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN2 0x20
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN3 0x30
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN4 0x40
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN5 0x50
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN6 0x60
+#define SX863X_MAPWAKEUPVALUE0_KEY5_BTN7 0x70
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN1 0x01
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN2 0x02
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN3 0x03
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN4 0x04
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN5 0x05
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN6 0x06
+#define SX863X_MAPWAKEUPVALUE0_KEY4_BTN7 0x07
+
+/*    MapWakeupValue1  */
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN1 0x10
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN2 0x20
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN3 0x30
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN4 0x40
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN5 0x50
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN6 0x60
+#define SX863X_MAPWAKEUPVALUE1_KEY3_BTN7 0x70
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN1 0x01
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN2 0x02
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN3 0x03
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN4 0x04
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN5 0x05
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN6 0x06
+#define SX863X_MAPWAKEUPVALUE1_KEY2_BTN7 0x07
+
+/*    MapWakeupValue2  */
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN1 0x10
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN2 0x20
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN3 0x30
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN4 0x40
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN5 0x50
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN6 0x60
+#define SX863X_MAPWAKEUPVALUE2_KEY1_BTN7 0x70
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN0 0x00
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN1 0x01
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN2 0x02
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN3 0x03
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN4 0x04
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN5 0x05
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN6 0x06
+#define SX863X_MAPWAKEUPVALUE2_KEY0_BTN7 0x07
+/*      MapAutoLight0   */
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN0 0x000
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN1 0x10
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN2 0x20
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN3 0x30
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN4 0x40
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN5 0x50
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN6 0x60
+#define SX863X_MAPAUTOLIGHT0_GPIO7_BTN7 0x70
+#define SX863X_MAPAUTOLIGHT0_GPIO7_GROUP0 0xC0
+#define SX863X_MAPAUTOLIGHT0_GPIO7_GROUP1 0xD0
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN1 0x01
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN2 0x02
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN3 0x03
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN4 0x04
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN5 0x05
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN6 0x06
+#define SX863X_MAPAUTOLIGHT0_GPIO6_BTN7 0x07
+#define SX863X_MAPAUTOLIGHT0_GPIO6_GROUP0 0x0C
+#define SX863X_MAPAUTOLIGHT0_GPIO6_GROUP1 0x0D
+/*      MapAutoLight1   */
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN1 0x10
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN2 0x20
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN3 0x30
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN4 0x40
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN5 0x50
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN6 0x60
+#define SX863X_MAPAUTOLIGHT1_GPIO5_BTN7 0x70
+#define SX863X_MAPAUTOLIGHT1_GPIO5_GROUP0 0xC0
+#define SX863X_MAPAUTOLIGHT1_GPIO5_GROUP1 0xD0
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN1 0x01
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN2 0x02
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN3 0x03
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN4 0x04
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN5 0x05
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN6 0x06
+#define SX863X_MAPAUTOLIGHT1_GPIO4_BTN7 0x07
+#define SX863X_MAPAUTOLIGHT1_GPIO4_GROUP0 0x0C
+#define SX863X_MAPAUTOLIGHT1_GPIO4_GROUP1 0x0D
+/*      MapAutoLight2   */
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN1 0x10
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN2 0x20
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN3 0x30
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN4 0x40
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN5 0x50
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN6 0x60
+#define SX863X_MAPAUTOLIGHT2_GPIO3_BTN7 0x70
+#define SX863X_MAPAUTOLIGHT2_GPIO3_GROUP0 0xC0
+#define SX863X_MAPAUTOLIGHT2_GPIO3_GROUP1 0xD0
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN1 0x01
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN2 0x02
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN3 0x03
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN4 0x04
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN5 0x05
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN6 0x06
+#define SX863X_MAPAUTOLIGHT2_GPIO2_BTN7 0x07
+#define SX863X_MAPAUTOLIGHT2_GPIO2_GROUP0 0x0C
+#define SX863X_MAPAUTOLIGHT2_GPIO2_GROUP1 0x0D
+/*      MapAutoLight3   */
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN1 0x10
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN2 0x20
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN3 0x30
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN4 0x40
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN5 0x50
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN6 0x60
+#define SX863X_MAPAUTOLIGHT3_GPIO1_BTN7 0x70
+#define SX863X_MAPAUTOLIGHT3_GPIO1_GROUP0 0xC0
+#define SX863X_MAPAUTOLIGHT3_GPIO1_GROUP1 0xD0
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN0 0x00
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN1 0x01
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN2 0x02
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN3 0x03
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN4 0x04
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN5 0x05
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN6 0x06
+#define SX863X_MAPAUTOLIGHT3_GPIO0_BTN7 0x07
+#define SX863X_MAPAUTOLIGHT3_GPIO0_GROUP0 0x0C
+#define SX863X_MAPAUTOLIGHT3_GPIO0_GROUP1 0x0D
+/*    MapAutoLightGrp0Lsb   */
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN7 0x80
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN6 0x40
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN5 0x20
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN4 0x10
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN3 0x08
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN2 0x04
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN1 0x02
+#define SX863X_MAPAUTOLIGHTGRP0LSB_BTN0 0x01
+/*    MapAutoLightGrp1Lsb     */
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN7 0x80
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN6 0x40
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN5 0x20
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN4 0x10
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN3 0x08
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN2 0x04
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN1 0x02
+#define SX863X_MAPAUTOLIGHTGRP1LSB_BTN0 0x01
+/*    GpioMode7_4   */
+#define SX863X_GPIOMODE7_4_GPIO7_GPO  0x00
+#define SX863X_GPIOMODE7_4_GPIO7_GPP  0x40
+#define SX863X_GPIOMODE7_4_GPIO7_GPI  0x80
+#define SX863X_GPIOMODE7_4_GPIO6_GPO  0x00
+#define SX863X_GPIOMODE7_4_GPIO6_GPP  0x10
+#define SX863X_GPIOMODE7_4_GPIO6_GPI  0x20
+#define SX863X_GPIOMODE7_4_GPIO5_GPO  0x00
+#define SX863X_GPIOMODE7_4_GPIO5_GPP  0x04
+#define SX863X_GPIOMODE7_4_GPIO5_GPI  0x08
+#define SX863X_GPIOMODE7_4_GPIO4_GPO  0x00
+#define SX863X_GPIOMODE7_4_GPIO4_GPP  0x01
+#define SX863X_GPIOMODE7_4_GPIO4_GPI  0x02
+/*    GpioMode3_0   */
+#define SX863X_GPIOMODE3_0_GPIO3_GPO  0x00
+#define SX863X_GPIOMODE3_0_GPIO3_GPP  0x40
+#define SX863X_GPIOMODE3_0_GPIO3_GPI  0x80
+#define SX863X_GPIOMODE3_0_GPIO2_GPO  0x00
+#define SX863X_GPIOMODE3_0_GPIO2_GPP  0x10
+#define SX863X_GPIOMODE3_0_GPIO2_GPI  0x20
+#define SX863X_GPIOMODE3_0_GPIO1_GPO  0x00
+#define SX863X_GPIOMODE3_0_GPIO1_GPP  0x04
+#define SX863X_GPIOMODE3_0_GPIO1_GPI  0x08
+#define SX863X_GPIOMODE3_0_GPIO0_GPO  0x00
+#define SX863X_GPIOMODE3_0_GPIO0_GPP  0x01
+#define SX863X_GPIOMODE3_0_GPIO0_GPI  0x02
+/*    GpioOutPwrUp    */
+#define SX863X_GPIOOUTPWRUP_GPIO7_ON	0x80
+#define SX863X_GPIOOUTPWRUP_GPIO6_ON	0x40
+#define SX863X_GPIOOUTPWRUP_GPIO5_ON	0x20
+#define SX863X_GPIOOUTPWRUP_GPIO4_ON	0x10
+#define SX863X_GPIOOUTPWRUP_GPIO3_ON	0x08
+#define SX863X_GPIOOUTPWRUP_GPIO2_ON	0x04
+#define SX863X_GPIOOUTPWRUP_GPIO1_ON	0x02
+#define SX863X_GPIOOUTPWRUP_GPIO0_ON	0x01
+/*    GpioAutoLight   */
+#define SX863X_GPIOAUTOLIGHT_GPIO7_ON	0x80
+#define SX863X_GPIOAUTOLIGHT_GPIO6_ON	0x40
+#define SX863X_GPIOAUTOLIGHT_GPIO5_ON	0x20
+#define SX863X_GPIOAUTOLIGHT_GPIO4_ON	0x10
+#define SX863X_GPIOAUTOLIGHT_GPIO3_ON	0x08
+#define SX863X_GPIOAUTOLIGHT_GPIO2_ON	0x04
+#define SX863X_GPIOAUTOLIGHT_GPIO1_ON	0x02
+#define SX863X_GPIOAUTOLIGHT_GPIO0_ON	0x01
+/*    GpioPolarity  0: Inverted, 1: Normal  */
+#define SX863X_GPIOPOLARITY_GPIO7_NORMAL	0x80
+#define SX863X_GPIOPOLARITY_GPIO6_NORMAL	0x40
+#define SX863X_GPIOPOLARITY_GPIO5_NORMAL	0x20
+#define SX863X_GPIOPOLARITY_GPIO4_NORMAL	0x10
+#define SX863X_GPIOPOLARITY_GPIO3_NORMAL	0x08
+#define SX863X_GPIOPOLARITY_GPIO2_NORMAL	0x04
+#define SX863X_GPIOPOLARITY_GPIO1_NORMAL	0x02
+#define SX863X_GPIOPOLARITY_GPIO0_NORMAL	0x01
+/* GpioIntensityOn0-7 ON Intensity Index */
+#define SX863X_GPIOINTENSITYONX_255   0xFF
+#define SX863X_GPIOINTENSITYONX_DEFAULT SX863X_GPIOINTENSITYONX_255
+/* GpioIntensityOff0-7 OFF Intensity Index */
+#define SX863X_GPIOINTENSITYOFFX_0   0x00
+#define SX863X_GPIOINTENSITYOFFX_DEFAULT SX863X_GPIOINTENSITYOFFX_0
+/* GpioFunction 0: Logarithmic (default) 1: Linear */
+#define SX863X_GPIOFUNCTION_GPIO7_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO7_LINEAR	0x80
+#define SX863X_GPIOFUNCTION_GPIO6_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO6_LINEAR	0x40
+#define SX863X_GPIOFUNCTION_GPIO5_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO5_LINEAR	0x20
+#define SX863X_GPIOFUNCTION_GPIO4_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO4_LINEAR	0x10
+#define SX863X_GPIOFUNCTION_GPIO3_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO3_LINEAR	0x08
+#define SX863X_GPIOFUNCTION_GPIO2_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO2_LINEAR	0x04
+#define SX863X_GPIOFUNCTION_GPIO1_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO1_LINEAR	0x02
+#define SX863X_GPIOFUNCTION_GPIO0_LOG	    0x00
+#define SX863X_GPIOFUNCTION_GPIO0_LINEAR	0x01
+
+/* GpioIncFactor 0: 1 (default) 1: Linear */
+#define SX863X_GPIOINCFACTOR_GPIO7_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO7_16	0x80
+#define SX863X_GPIOINCFACTOR_GPIO6_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO6_16	0x40
+#define SX863X_GPIOINCFACTOR_GPIO5_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO5_16	0x20
+#define SX863X_GPIOINCFACTOR_GPIO4_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO4_16	0x10
+#define SX863X_GPIOINCFACTOR_GPIO3_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO3_16	0x08
+#define SX863X_GPIOINCFACTOR_GPIO2_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO2_16	0x04
+#define SX863X_GPIOINCFACTOR_GPIO1_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO1_16	0x02
+#define SX863X_GPIOINCFACTOR_GPIO0_1	    0x00
+#define SX863X_GPIOINCFACTOR_GPIO0_16	0x01
+
+/* GpioIncFactor 0: 1 (default) 1: Linear */
+#define SX863X_GPIODECFACTOR_GPIO7_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO7_16	0x80
+#define SX863X_GPIODECFACTOR_GPIO6_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO6_16	0x40
+#define SX863X_GPIODECFACTOR_GPIO5_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO5_16	0x20
+#define SX863X_GPIODECFACTOR_GPIO4_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO4_16	0x10
+#define SX863X_GPIODECFACTOR_GPIO3_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO3_16	0x08
+#define SX863X_GPIODECFACTOR_GPIO2_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO2_16	0x04
+#define SX863X_GPIODECFACTOR_GPIO1_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO1_16	0x02
+#define SX863X_GPIODECFACTOR_GPIO0_1	    0x00
+#define SX863X_GPIODECFACTOR_GPIO0_16	0x01
+/*    GpioIncTime7_6  GpioIncTime*GpioIncFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIOINCTIME7_6_GPIO7_OFF	  0x00
+#define SX863X_GPIOINCTIME7_6_GPIO7_7_5MS	0xF0
+#define SX863X_GPIOINCTIME7_6_GPIO6_OFF	  0x00
+#define SX863X_GPIOINCTIME7_6_GPIO6_7_5MS	0x0F
+/*    GpioIncTime5_4  GpioIncTime*GpioIncFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIOINCTIME5_4_GPIO5_OFF	  0x00
+#define SX863X_GPIOINCTIME5_4_GPIO5_7_5MS	0xF0
+#define SX863X_GPIOINCTIME5_4_GPIO4_OFF	  0x00
+#define SX863X_GPIOINCTIME5_4_GPIO4_7_5MS	0x0F
+/*    GpioIncTime3_2  GpioIncTime*GpioIncFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIOINCTIME3_2_GPIO3_OFF	  0x00
+#define SX863X_GPIOINCTIME3_2_GPIO3_7_5MS	0xF0
+#define SX863X_GPIOINCTIME3_2_GPIO2_OFF	  0x00
+#define SX863X_GPIOINCTIME3_2_GPIO2_7_5MS	0x0F
+/*    GpioIncTime1_0  GpioIncTime*GpioIncFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIOINCTIME1_0_GPIO1_OFF	  0x00
+#define SX863X_GPIOINCTIME1_0_GPIO1_7_5MS	0xF0
+#define SX863X_GPIOINCTIME1_0_GPIO0_OFF	  0x00
+#define SX863X_GPIOINCTIME1_0_GPIO0_7_5MS	0x0F
+
+/*    GpioDecTime7_6  GpioDecTime*GpioDecFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIODECTIME7_6_GPIO7_OFF	  0x00
+#define SX863X_GPIODECTIME7_6_GPIO7_7_5MS	0xF0
+#define SX863X_GPIODECTIME7_6_GPIO6_OFF	  0x00
+#define SX863X_GPIODECTIME7_6_GPIO6_7_5MS	0x0F
+/*    GpioDecTime5_4  GpioDecTime*GpioDecFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIODECTIME5_4_GPIO5_OFF	  0x00
+#define SX863X_GPIODECTIME5_4_GPIO5_7_5MS	0xF0
+#define SX863X_GPIODECTIME5_4_GPIO4_OFF	  0x00
+#define SX863X_GPIODECTIME5_4_GPIO4_7_5MS	0x0F
+/*    GpioDecTime3_2  GpioDecTime*GpioDecFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIODECTIME3_2_GPIO3_OFF	  0x00
+#define SX863X_GPIODECTIME3_2_GPIO3_7_5MS	0xF0
+#define SX863X_GPIODECTIME3_2_GPIO2_OFF	  0x00
+#define SX863X_GPIODECTIME3_2_GPIO2_7_5MS	0x0F
+/*    GpioDecTime1_0  GpioDecTime*GpioDecFactor*(GpioIntensityOn-GpioIntensityOff) */
+#define SX863X_GPIODECTIME1_0_GPIO1_OFF	  0x00
+#define SX863X_GPIODECTIME1_0_GPIO1_7_5MS	0xF0
+#define SX863X_GPIODECTIME1_0_GPIO0_OFF	  0x00
+#define SX863X_GPIODECTIME1_0_GPIO0_7_5MS	0x0F
+
+/*    GpioOffDelay7_6   */
+#define SX863X_GPIOOFFDELAY7_6_GPIO7_OFF	  0x00
+#define SX863X_GPIOOFFDELAY7_6_GPIO7_3000MS	0xF0
+#define SX863X_GPIOOFFDELAY7_6_GPIO6_OFF	  0x00
+#define SX863X_GPIOOFFDELAY7_6_GPIO6_3000MS	0x0F
+/*    GpioOffDelay5_4 */
+#define SX863X_GPIOOFFDELAY5_4_GPIO5_OFF	  0x00
+#define SX863X_GPIOOFFDELAY5_4_GPIO5_3000MS	0xF0
+#define SX863X_GPIOOFFDELAY5_4_GPIO4_OFF	  0x00
+#define SX863X_GPIOOFFDELAY5_4_GPIO4_3000MS	0x0F
+/*    GpioOffDelay3_2 */
+#define SX863X_GPIOOFFDELAY3_2_GPIO3_OFF	  0x00
+#define SX863X_GPIOOFFDELAY3_2_GPIO3_3000MS	0xF0
+#define SX863X_GPIOOFFDELAY3_2_GPIO2_OFF	  0x00
+#define SX863X_GPIOOFFDELAY3_2_GPIO2_3000MS	0x0F
+/*    GpioOffDelay1_0 */
+#define SX863X_GPIOOFFDELAY1_0_GPIO1_OFF	  0x00
+#define SX863X_GPIOOFFDELAY1_0_GPIO1_3000MS	0xF0
+#define SX863X_GPIOOFFDELAY1_0_GPIO0_OFF	  0x00
+#define SX863X_GPIOOFFDELAY1_0_GPIO0_3000MS	0x0F
+
+/*    Gpio PullUpDown7_4 */
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO7_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO7_PULLUP   0x40
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO7_PULLDOWN 0x80
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO6_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO6_PULLUP   0x10
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO6_PULLDOWN 0x20
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO5_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO5_PULLUP   0x04
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO5_PULLDOWN 0x08
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO4_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO4_PULLUP   0x01
+#define SX863X_GPIOPULLUPDOWN7_4_GPIO4_PULLDOWN 0x02
+
+
+/*    Gpio PullUpDown3_0 */
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO3_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO3_PULLUP   0x40
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO3_PULLDOWN 0x80
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO2_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO2_PULLUP   0x10
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO2_PULLDOWN 0x20
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO1_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO1_PULLUP   0x04
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO1_PULLDOWN 0x08
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO0_NONE     0x00
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO0_PULLUP   0x01
+#define SX863X_GPIOPULLUPDOWN3_0_GPIO0_PULLDOWN 0x02
+/*    GpioInterrupt7_4    */
+#define SX863X_GPIOINTERRUPT7_4_GPIO7_NONE	  0x00
+#define SX863X_GPIOINTERRUPT7_4_GPIO7_RISING	0x40
+#define SX863X_GPIOINTERRUPT7_4_GPIO7_FALLING	0x80
+#define SX863X_GPIOINTERRUPT7_4_GPIO7_BOTH	  0xC0
+#define SX863X_GPIOINTERRUPT7_4_GPIO6_NONE	  0x00
+#define SX863X_GPIOINTERRUPT7_4_GPIO6_RISING	0x10
+#define SX863X_GPIOINTERRUPT7_4_GPIO6_FALLING	0x20
+#define SX863X_GPIOINTERRUPT7_4_GPIO6_BOTH	  0x30
+#define SX863X_GPIOINTERRUPT7_4_GPIO5_NONE	  0x00
+#define SX863X_GPIOINTERRUPT7_4_GPIO5_RISING	0x04
+#define SX863X_GPIOINTERRUPT7_4_GPIO5_FALLING	0x08
+#define SX863X_GPIOINTERRUPT7_4_GPIO5_BOTH	  0x0C
+#define SX863X_GPIOINTERRUPT7_4_GPIO4_NONE	  0x00
+#define SX863X_GPIOINTERRUPT7_4_GPIO4_RISING	0x01
+#define SX863X_GPIOINTERRUPT7_4_GPIO4_FALLING	0x02
+#define SX863X_GPIOINTERRUPT7_4_GPIO4_BOTH	  0x03
+/*    GpioInterrupt3_0    */
+#define SX863X_GPIOINTERRUPT3_0_GPIO3_NONE	  0x00
+#define SX863X_GPIOINTERRUPT3_0_GPIO3_RISING	0x40
+#define SX863X_GPIOINTERRUPT3_0_GPIO3_FALLING	0x80
+#define SX863X_GPIOINTERRUPT3_0_GPIO3_BOTH	  0xC0
+#define SX863X_GPIOINTERRUPT3_0_GPIO2_NONE	  0x00
+#define SX863X_GPIOINTERRUPT3_0_GPIO2_RISING	0x10
+#define SX863X_GPIOINTERRUPT3_0_GPIO2_FALLING	0x20
+#define SX863X_GPIOINTERRUPT3_0_GPIO2_BOTH	  0x30
+#define SX863X_GPIOINTERRUPT3_0_GPIO1_NONE	  0x00
+#define SX863X_GPIOINTERRUPT3_0_GPIO1_RISING	0x04
+#define SX863X_GPIOINTERRUPT3_0_GPIO1_FALLING	0x08
+#define SX863X_GPIOINTERRUPT3_0_GPIO1_BOTH	  0x0C
+#define SX863X_GPIOINTERRUPT3_0_GPIO0_NONE	  0x00
+#define SX863X_GPIOINTERRUPT3_0_GPIO0_RISING	0x01
+#define SX863X_GPIOINTERRUPT3_0_GPIO0_FALLING	0x02
+#define SX863X_GPIOINTERRUPT3_0_GPIO0_BOTH	  0x03
+/*    GpioDebounce    */
+#define SX863X_GPIODEBOUNCE_GPIO7_ON	0x80
+#define SX863X_GPIODEBOUNCE_GPIO6_ON	0x40
+#define SX863X_GPIODEBOUNCE_GPIO5_ON	0x20
+#define SX863X_GPIODEBOUNCE_GPIO4_ON	0x10
+#define SX863X_GPIODEBOUNCE_GPIO3_ON	0x08
+#define SX863X_GPIODEBOUNCE_GPIO2_ON	0x04
+#define SX863X_GPIODEBOUNCE_GPIO1_ON	0x02
+#define SX863X_GPIODEBOUNCE_GPIO0_ON	0x01
+
+#endif /* _SX863X_SPM_REG_H_*/
diff -ruN a/include/linux/mfd/lpc_ich.h b/include/linux/mfd/lpc_ich.h
--- a/include/linux/mfd/lpc_ich.h	2024-05-07 14:48:33.766493846 +0800
+++ b/include/linux/mfd/lpc_ich.h	2024-05-07 15:46:53.905849110 +0800
@@ -24,6 +24,7 @@
 	ICH_V10CORP_GPIO,
 	ICH_V10CONS_GPIO,
 	AVOTON_GPIO,
+	LPT_GPIO,
 };
 
 struct lpc_ich_info {
@@ -32,6 +33,7 @@
 	unsigned int gpio_version;
 	enum intel_spi_type spi_type;
 	u8 use_gpio;
+	struct pci_dev *pci_dev;
 };
 
 #endif
diff -ruN a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h
--- a/include/scsi/scsi_device.h	2024-05-07 14:48:34.436497832 +0800
+++ b/include/scsi/scsi_device.h	2024-05-07 15:46:53.905849110 +0800
@@ -10,6 +10,10 @@
 #include <linux/atomic.h>
 #include <linux/sbitmap.h>
 
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+#include <scsi/scsi_spinup.h>
+#endif
+
 struct bsg_device;
 struct device;
 struct request_queue;
@@ -281,6 +285,14 @@
 	struct mutex		state_mutex;
 	enum scsi_device_state sdev_state;
 	struct task_struct	*quiesced_by;
+
+#ifdef CONFIG_MV_STAGGERED_SPINUP
+	enum scsi_device_power_state sdev_power_state;  /*Used to save the disk current power state*/
+	struct timer_list spinup_timeout;	/* Used to time out the spinup process when done. */
+	unsigned int standby_timeout_secs;
+	struct timer_list standby_timeout;	/* Used to time out the standby timeout command. */
+#endif
+
 	unsigned long		sdev_data[];
 } __attribute__((aligned(sizeof(unsigned long))));
 
diff -ruN a/include/scsi/scsi_spinup.h b/include/scsi/scsi_spinup.h
--- a/include/scsi/scsi_spinup.h	1970-01-01 08:00:00.000000000 +0800
+++ b/include/scsi/scsi_spinup.h	2024-05-07 15:46:53.905849110 +0800
@@ -0,0 +1,42 @@
+/*
+ *  SCSI Spinup specific attributes.
+ *
+ *  Copyright (c) 2009 Marvell,  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef SCSI_SPINUP_H
+#define SCSI_SPINUP_H
+
+/*
+ * more defines of SCSI / ATA commands that are not defined by default
+ */
+#define STANDBY_IMMEDIATE     0xe0
+#define SLEEP                 0xe6
+#define STANDBY_TIMEOUT       0xe3
+#define VERIFY_10             0x13
+#define START_STOP_BIT        0x00000001
+
+enum scsi_device_power_state {
+	SDEV_PW_UNKNOWN = 0,		//0
+	SDEV_PW_STANDBY,		//1
+	SDEV_PW_STANDBY_TIMEOUT_WAIT,	//2
+	SDEV_PW_STANDBY_TIMEOUT_PASSED,	//3
+	SDEV_PW_SPINNING_UP,		//4
+	SDEV_PW_WAIT_FOR_SPIN_UP,	//5
+	SDEV_PW_ON,			//6
+};
+
+#endif /* SCSI_SPINUP_H */
diff -ruN a/include/target/target_core_base.h b/include/target/target_core_base.h
--- a/include/target/target_core_base.h	2024-05-07 14:48:34.526498367 +0800
+++ b/include/target/target_core_base.h	2024-05-07 15:46:53.905849110 +0800
@@ -194,6 +194,7 @@
 	TCM_ALUA_TG_PT_UNAVAILABLE		= R(0x21),
 	TCM_ALUA_STATE_TRANSITION		= R(0x22),
 	TCM_ALUA_OFFLINE			= R(0x23),
+	TCM_TP_SOFT_THRESHOLD_EXCEEDED		= R(0x24),
 #undef R
 };
 
diff -ruN a/include/uapi/linux/fiemap.h b/include/uapi/linux/fiemap.h
--- a/include/uapi/linux/fiemap.h	2024-05-07 14:48:34.656499138 +0800
+++ b/include/uapi/linux/fiemap.h	2024-05-07 15:46:53.905849110 +0800
@@ -20,9 +20,12 @@
 	__u64 fe_physical; /* physical offset in bytes for the start
 			    * of the extent from the beginning of the disk */
 	__u64 fe_length;   /* length in bytes for this extent */
-	__u64 fe_reserved64[2];
+	__u64 fe_reserved64[1];
+	__u64 fe_loglength;/* logical extent length
+			    * if FIEMAP_EXTENT_LOGLENGTH */
 	__u32 fe_flags;    /* FIEMAP_EXTENT_* flags for this extent */
-	__u32 fe_reserved[3];
+	__u32 fe_reserved[2];
+	__u32 fe_pdev;	   /* physical dev_t if FIEMAP_EXTENT_PHYSICAL */
 };
 
 struct fiemap {
@@ -44,6 +47,7 @@
 #define FIEMAP_FLAG_CACHE	0x00000004 /* request caching of the extents */
 
 #define FIEMAP_FLAGS_COMPAT	(FIEMAP_FLAG_SYNC | FIEMAP_FLAG_XATTR)
+#define FIEMAP_FLAG_PHYSICAL	0x80000000 /* report physical device extents */
 
 #define FIEMAP_EXTENT_LAST		0x00000001 /* Last extent in file. */
 #define FIEMAP_EXTENT_UNKNOWN		0x00000002 /* Data location unknown. */
@@ -66,5 +70,10 @@
 						    * merged for efficiency. */
 #define FIEMAP_EXTENT_SHARED		0x00002000 /* Space shared with other
 						    * files. */
+#define FIEMAP_EXTENT_LOGLENGTH		0x20000000 /* fe_loglength is valid. */
+#define FIEMAP_EXTENT_MORESTRIPE	0x40000000 /* One ore more physical
+						    * extent will follow. */
+#define FIEMAP_EXTENT_PHYSICAL		0x80000000 /* This extent represents
+						    * physical device */
 
 #endif /* _UAPI_LINUX_FIEMAP_H */
diff -ruN a/init/main.c b/init/main.c
--- a/init/main.c	2024-05-07 14:48:34.926500744 +0800
+++ b/init/main.c	2024-05-07 15:46:53.915849169 +0800
@@ -51,6 +51,7 @@
 #include <linux/cpu.h>
 #include <linux/cpuset.h>
 #include <linux/cgroup.h>
+#include <linux/dmi.h>
 #include <linux/efi.h>
 #include <linux/tick.h>
 #include <linux/sched/isolation.h>
@@ -1044,6 +1045,25 @@
 	pid_idr_init();
 	anon_vma_init();
 #ifdef CONFIG_X86
+	{
+		const char *product_name = dmi_get_system_info(DMI_PRODUCT_NAME);
+
+		if (!memcmp(product_name, "ReadyNAS 312", 12) ||
+		    !memcmp(product_name, "RN312", 5) ||
+		    !memcmp(product_name, "ReadyNAS 314", 12) ||
+		    !memcmp(product_name, "RN314", 5) ||
+		    !memcmp(product_name, "ReadyNAS 316", 12) ||
+		    !memcmp(product_name, "RN316", 5))
+		{
+			u32 v = inl(0x430);
+			printk(KERN_NOTICE "PMBASE+30h=%08x\n", v);
+			if (v & 0x40) {
+				outl((v & ~0x40) & 0xffffffff, 0x430);
+				printk(KERN_NOTICE "Fix bug#12655\n");
+			}
+		}
+	}
+
 	if (efi_enabled(EFI_RUNTIME_SERVICES))
 		efi_enter_virtual_mode();
 #endif
